<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="2" Comment="" Date="2012/01/22" Time="09:38:6000" NL="\10" Encoding="text">
<Insert>#include &lt;common/incl/common_api.h&gt;
#include &lt;sru/incl/sru_api.h&gt;

#include &lt;mmp_tal.h&gt;
#include &lt;mmp_os.h&gt;
#include "NatureDSP_Math.h"
#include "sru.h"
#include "sru_cm_turbo.h"
#include "sru_cm_vanilla.h"
//#include "mpu/src/extra_arm9e.h"
#include "amr_nb/src/amrcom/extra_extra_arm9e.h"

/*---------------------------------------------------------------------------*
 * Useful values
 *---------------------------------------------------------------------------*/

static const int32_t q31_reciprocal[11] = {
									0, 			// 1/0	
									Q31_ONE,
									Q31_HALF,
									Q31_THIRD,
									Q31_FOURTH,
									Q31_FIFTH,
									Q31_SIXTH,
									Q31_SEVENTH,
									Q31_EIGTH,
									Q31_NINTH,
									Q31_TENTH };


/*---------------------------------------------------------------------------*
 * SRU CM implementation
 *---------------------------------------------------------------------------*/


int32_t init_turbo_vad_ops(sru_call_t * call) {
		
	if (!call)
		return MMP_FAIL;
		
	call-&gt;cm_ops.cm_exec_call_op 		= &amp;cm_turbo_vad_exec_call;
	call-&gt;cm_ops.cm_init_conference_op	= &amp;cm_turbo_vad_init_conference;
	call-&gt;cm_ops.cm_join_to_conf_op		= &amp;cm_turbo_vad_join_to_conf;
	call-&gt;cm_ops.cm_leave_conf_op		= &amp;cm_turbo_vad_leave_conf;	
	
	return MMP_OK;
}

int32_t cm_turbo_vad_create(sru_state_t* sru_state) {

	int32_t conferee_size, conference_size;
	int32_t ports,calls,i;
	turbo_vad_conferee_state_t * conferee;

	if (!sru_state)
		return MMP_FAIL;
		
	conferee_size = sizeof(turbo_vad_conferee_state_t);
	conference_size = sizeof(turbo_vad_conference_state_t);
		
	ports = sru_state-&gt;sru_max_ports;
	calls = sru_state-&gt;sru_max_calls;

	if (!sru_state-&gt;sru_call_list || !sru_state-&gt;sru_port_list) {
		cm_turbo_vad_destroy(sru_state);
		return MMP_FAIL;
	}		
	
	// conferences
	for(i=0;i&lt;calls;i++) {
		sru_state-&gt;sru_call_list[i].conf_state = MMP_OS_MALLOC(conference_size);
		if (!sru_state-&gt;sru_call_list[i].conf_state) {
			cm_turbo_vad_destroy(sru_state);
			return MMP_FAIL;
		}			
	}
	
	// conferees
	for(i=0;i&lt;ports;i++) {
		conferee = (turbo_vad_conferee_state_t *) MMP_OS_MALLOC(conferee_size);
		if (!conferee) {
			cm_turbo_vad_destroy(sru_state);
			return MMP_FAIL;			
		}
		sru_state-&gt;sru_port_list[i].conferee_state = (void *) conferee;
		VADCreate(&amp;conferee-&gt;VADMem,NULL);	// VAD memory
		conferee-&gt;VADMem.mpMemory = MMP_OS_MALLOC(conferee-&gt;VADMem.mMemSize); // we assume one block is used
		if (!conferee-&gt;VADMem.mpMemory) {
			cm_turbo_vad_destroy(sru_state);
			return MMP_FAIL;			
		}
	}

	return MMP_OK;
	
} // cm_create_turbo_vad

int32_t cm_turbo_vad_destroy(sru_state_t* sru_state) {
	
	if (!sru_state)
		return MMP_OK;
		
	int32_t ports,calls,i;
	turbo_vad_conferee_state_t * conferee;
	
	ports = sru_state-&gt;sru_max_ports;
	calls = sru_state-&gt;sru_max_calls;
	
	if (sru_state-&gt;sru_call_list != NULL) {
	  // free conferences
	  for(i=0;i&lt;calls;i++) {
		  if (sru_state-&gt;sru_call_list[i].conf_state != NULL) {
			MMP_OS_FREE(sru_state-&gt;sru_call_list[i].conf_state);
			sru_state-&gt;sru_call_list[i].conf_state = NULL;
		}
	  }	
	}
	
	if (sru_state-&gt;sru_port_list != NULL) {
	  // free conferees
	  for(i=0;i&lt;ports;i++) {
		conferee = (turbo_vad_conferee_state_t *) sru_state-&gt;sru_port_list[i].conferee_state;
		if (conferee) {
			if (conferee-&gt;VADMem.mpMemory) {
				MMP_OS_FREE(conferee-&gt;VADMem.mpMemory);	
				conferee-&gt;VADMem.mpMemory = NULL;
			}
			MMP_OS_FREE(conferee);					
			sru_state-&gt;sru_port_list[i].conferee_state = NULL;
		}
	  }
	}
	return MMP_OK;
	
} // cm_destroy_turbo_vad


int32_t cm_turbo_vad_init_conferee(conferee_state_t* raw_state) {
	
	const tVADParams vad_params = {1 /* use prefilter */, 1 /* use VAD */, {NULL}};
	
	turbo_vad_conferee_state_t *state = (turbo_vad_conferee_state_t*) raw_state;

	if (!raw_state)
		return MMP_FAIL;	
	
	state-&gt;fsm_state = 0;
	state-&gt;VAD_decision = 0;
	state-&gt;VAD_handle = VADInit(&amp;state-&gt;VADMem, 1 /* nMemBlk */,&amp;vad_params);
	state-&gt;ar = 0;
	state-&gt;lar = 0;
	state-&gt;voice_est = INITIAL_ESTIMATION; //dbm in 1/100 units
	state-&gt;noise_est = INITIAL_ESTIMATION;
	state-&gt;power_est = INITIAL_ESTIMATION;
	state-&gt;duration = 0;	
	state-&gt;avtive_counter = 0;


	return MMP_OK;	
	
} // cm_turbo_vad_init_conferee


int32_t cm_turbo_vad_init_conference(conference_state_t* state_p) {
		
	int32_t i,j,k;
	
	if(!state_p)
		return MMP_FAIL;
		
	turbo_vad_conference_state_t * state = (turbo_vad_conference_state_t *) state_p;
	
	state-&gt;duration = 0;
	state-&gt;fifo_top_index =0;
	
			
	// init weights
	for(i=0;i&lt;SRU_MAX_CALL_PORTS ;i++) {		
		for(j=0;j&lt;SRU_MAX_CALL_PORTS  ;j++) {
			((state-&gt;coef))[i][j] = 0;			
			for(k=0;k&lt;AVG_FLTR_DEPTH;k++) {
				((state-&gt;weights))[i][j][k] = 0;
			}
		}
	}
	
	return MMP_OK;
}


int32_t cm_turbo_vad_join_to_conf(int32_t port_id) {
			
	return cm_turbo_vad_init_conferee(sru_find_port(port_id)-&gt;conferee_state);	
			
}



int32_t cm_turbo_vad_leave_conf(int32_t port_id) {
	
	return cm_turbo_vad_init_conferee(sru_find_port(port_id)-&gt;conferee_state);	

}


int32_t cm_turbo_vad_ar_2_score(int32_t ar) {
		
	return ar; // as simple as that
	
} // score()


int32_t cm_turbo_vad_fsm(turbo_vad_conferee_state_t * state, int32_t curr_VAD, int32_t prev_VAD, int32_t lar_shift) {
	
//	int i;
	int32_t ar,lar, fsm_state;
	
	ar = state-&gt;ar;
	lar = state-&gt;lar;
	
	fsm_state = state-&gt;fsm_state;
		
	switch (fsm_state)
	{	
		case 0: // NOT ACTIVE
		
			if(curr_VAD == 1){
				fsm_state = 1; // switch to FRONT END
				ar = ar+FI_DELTA;				
			}
			lar = MAX(lar-(LAR_STEP_DOWN&gt;&gt;lar_shift),0);
			break;
			
		case 1: // FE (Front End)
				
			if ((curr_VAD == 1) &amp;&amp; (prev_VAD == 1) &amp;&amp; (ar &lt; MAX_AR)) {
				ar = ar+FI_DELTA;				
			}	
			else if ((curr_VAD == 0) &amp;&amp; (prev_VAD == 0) &amp;&amp; (ar &gt; 0)) {
				ar = ar-FI_DELTA;
			}
			else if (ar &lt;= 0) {
				fsm_state = 0; // switch to NOT ACTIVE
			}
			else if (ar &gt;= MAX_AR){
				fsm_state = 2; // switch to ACTIVE
			}
					
			break;
			
		case 2: // ACTIVE
		
			if(curr_VAD == 0){
				fsm_state = 3; // switch to HANGOVER				
			}
			
			lar = MIN(L_add_ll(lar,(LAR_STEP_UP&gt;&gt;lar_shift)),MAX_LAR);
			state-&gt;avtive_counter +=1;
			break;
			
		case 3: // HANGOVER
				
			if ((curr_VAD == 1) &amp;&amp; (prev_VAD == 1) &amp;&amp; (ar &lt; MAX_AR)) {
				ar = ar+FO_DELTA;				
			}	
			else if ((curr_VAD == 0) &amp;&amp; (prev_VAD == 0) &amp;&amp; (ar &gt; 0)) {
				ar = ar-FO_DELTA;
			}
			else if (ar &lt;= 0) {
				fsm_state = 0; // switch to NOT ACTIVE
			}
			else if (ar &gt;= MAX_AR){
				fsm_state = 2; // switch to ACTIVE
			}
			lar = MIN(L_add_ll(lar,(LAR_STEP_UP&gt;&gt;lar_shift)),MAX_LAR);
			state-&gt;avtive_counter +=1;
			break;
								
		
		default: // reset
			
			fsm_state = 0;
			ar = 0;
				
	} // switch state
	
	// update
	state-&gt;ar = ar;
	state-&gt;lar = lar;
	state-&gt;fsm_state = fsm_state;
	
	return ar;		

} // cm_turbo_vad_fsm()


int32_t cm_turbo_vad_power(int16_t * restrict inputs, int32_t M) {
	

// first version (may overflow)
/*
	// calculate frame energy
	energy = 0;	
	for(i=M-1;i&gt;=0;i--) {
		sample_power = (inputs[i])*(inputs[i]);
		sample_power = sample_power+(1&lt;&lt;5); // round
		energy += sample_power&gt;&gt;6;		  // and scale
	}

	
	// energy = (real energy)/64
	
	if (M == 80) // NB
		return L_mpy_ll(energy,Q31_FOUR_FIFTH); 
	else // M == 160, WB
		return L_mpy_ll(energy,Q31_TWO_FIFTH);
		
*/	

//	second version

#ifdef ARM9E_OPTIMIZED	

    const int32_t *restrict x=(const int32_t *)(inputs);        
	
    int32_t i;
    int32_t x0,x1,y0,y1,energy;         

    NASSERT_ALIGN8(x);    
    _LDM2INC(x,x0,x1);
    energy=0;
    i = M&gt;&gt;2;    
	for(;i&gt;0;i--) {
        y0 = _SMULBB(x0,x0);        _ASM_VOLATILE;
        y0 = (y0+(1&lt;&lt;5))&gt;&gt;6;        _ASM_VOLATILE;  
        energy = _QADD(energy,y0);  _ASM_VOLATILE;
        y1 = _SMULTT(x0,x0);        _ASM_VOLATILE;
        y1 = (y1+(1&lt;&lt;5))&gt;&gt;6;        _ASM_VOLATILE;  
        energy = _QADD(energy,y1);  _ASM_VOLATILE;

        y0 = _SMULBB(x1,x1);        _ASM_VOLATILE;
        y0 = (y0+(1&lt;&lt;5))&gt;&gt;6;        _ASM_VOLATILE;  
        energy = _QADD(energy,y0);  _ASM_VOLATILE;
        y1 = _SMULTT(x1,x1);        _ASM_VOLATILE;
        y1 = (y1+(1&lt;&lt;5))&gt;&gt;6;        _ASM_VOLATILE;  
        energy = _QADD(energy,y1);  _ASM_VOLATILE;

        _LDM2INC(x,x0,x1);          _ASM_VOLATILE;  
    }

    /* at this point energy = real energy / 64 */

    if( M == 80) // NB
        return L_mpy_ll(energy,Q31_FOUR_FIFTH); // return (energy * 4/5) = (real energy / 80 ) = pow
    else // WB
        return L_mpy_ll(energy,Q31_TWO_FIFTH); // return (energy * 2/5) = (real energy / 160 ) = pow

#else

    int32_t i;
    int32_t energy; 

    int32_t sample_power;
    int32_t shift = 0;
	energy = 0;
	
	for(i=M-1;i&gt;=0;i--) {
		
		sample_power = (inputs[i])*(inputs[i]);
		if(energy &gt;= (1&lt;&lt;30)) {
			shift +=1;
			energy = (energy+1)&gt;&gt;1; // round and scale. energy = (real energy)/128
		}		
		if (shift &gt; 0) {
			sample_power = (sample_power+(1&lt;&lt;(shift-1)))&gt;&gt;shift; // round and scale
		}
		energy += sample_power;	  		
	}
	
	if( M == 80) { // NB
		shift = 6-shift;
		if (shift &gt;0) {
			energy = (energy+(1&lt;&lt;(shift-1)))&gt;&gt;shift; // round and scale. energy = (real energy)/64
		}
		return L_mpy_ll(energy,Q31_FOUR_FIFTH); // return (energy * 4/5) = (real energy / 80 ) = power
	}
	else { // WB
		shift = 7-shift;
		if (shift &gt;0) {
			energy = (energy+(1&lt;&lt;(shift-1)))&gt;&gt;shift; // round and scale. energy = (real energy)/128
		}
		return L_mpy_ll(energy,Q31_FOUR_FIFTH);				
	}

#endif	

    	
} // power



int16_t cm_turbo_vad_power_to_dbm(int32_t value) {

	const int16_t db_hundreds_rel =  0x20DE;
	int32_t power_root;
	int16_t db_hundreds;
	
	// return dbm value in  1/100 parts of dBm
	power_root = ((L_sqrt_l(value&lt;&lt;1))+1)&gt;&gt;1; // Q16.15	
	db_hundreds =  S_dB_l(power_root);	
	
	int16_t dbm_hundreds = db_hundreds-db_hundreds_rel;
	
	return dbm_hundreds;
	
} // int to dbm

int32_t cm_turbo_vad_dbm_to_power(int16_t dbm) {
		
	// dbm is in 1/100 parts of dB

// 	VERSION 1
 
	const int16_t db_max = 0x269; //	6.17 dbm
	int32_t  power_root = L_dB_s(dbm-db_max); //  sqrt(P)/2^15 in Q16.15 = sqrt(P) in Q0
	
	return power_root*power_root;
/*

// 	VERSION 2
 
	const int16_t  dbm_rel = 0x20DE; 		
	int32_t  root = L_dB_s(dbm+dbm_rel);
	root = root+(1&lt;&lt;14); // round 
	int32_t power = (root&gt;&gt;15)*(root&gt;&gt;15);
	return power;
*/

	
	
} // dbm_to_power


int32_t threshold(int32_t voice, int32_t noise) {
	
		int32_t tmp_th;
		int16_t voice_dbm,noise_dbm,th_dbm;
	
		if (noise &gt; voice) {
			//tmp_th = (int)round(((double)voice*ALPHA_TH));
			tmp_th = L_mpy_ls(voice,ALPHA_TH);
		}
		else {
			//tmp_th = (int)round(pow((double)voice,ZETTA_TH)*pow((double)noise,1-ZETTA_TH));
			
			voice_dbm = cm_turbo_vad_power_to_dbm(voice);
			noise_dbm = cm_turbo_vad_power_to_dbm(noise);
			
			th_dbm = (L_mpy_ls(ZETTA_TH,voice_dbm)+L_mpy_ls(ZETTA_TH_CMP,noise_dbm)+(1&lt;&lt;15))&gt;&gt;16;
			
			tmp_th = cm_turbo_vad_dbm_to_power(th_dbm);
			
		}
		
		// keep threshold in [MIN_TH,MAX_TH] interval
		if (tmp_th &gt; MAX_TH) {
			return MAX_TH;
		}
		else if (tmp_th &lt; MIN_TH) {
			return MIN_TH;
		}
		else {
			return tmp_th;
		}
} // threshold



int32_t cm_turbo_vad_get_power_VAD(int32_t voice_est,int32_t noise_est,int32_t power_est) {

	int32_t th;
		
	th = threshold(voice_est,noise_est); //threshold
	
	if ( power_est &lt; th) {
		return 0;
	} else {
		return 1;
	}
	
} // get_power_VAD



int32_t cm_turbo_vad_get_standard_VAD(turbo_vad_conferee_state_t *state, int16_t* samples, uint8_t *scratch) {
	
	const tVADStatus* status;
	
	VADProcess (state-&gt;VAD_handle,samples, scratch, 0 /* start bit */);
	status = VADGetStatus(state-&gt;VAD_handle);
		
	return status-&gt;mIsVoiceDetected;	
	//return 1; // when using only power vad
	

} // get_standard_VAD


int32_t cm_turbo_vad_get_turbo_VAD(int32_t stand_VAD, int32_t power_VAD) {
	
	return (stand_VAD &amp; power_VAD); 

} // get_turbo_VAD


int32_t cm_turbo_vad_calculate_gain(int32_t voice_est,int32_t duration) {
	
	int32_t gain, q16_15_1; // Q.15
	
	
	q16_15_1 = gain = 0x8000;	// 1;
	
	// activate gain ctrl only after GAIN_DURATION_TH_1 frames
	//  do it gradually untill GAIN_DURATION_TH_2 frames
	
	if (duration &gt;= GAIN_DURATION_TH_2) { // activate fully
		if (voice_est &gt; GAIN_SENSITIVITY_TH) { // is input high enough
			//gain = sqrt(((double)GAIN_REF_LEVEL)/((double)voice_est));
			//gain = (L_sqrt_l(L_div_ll(GAIN_REF_LEVEL,voice_est))+(1&lt;&lt;7))&gt;&gt;8;
			gain = L_shr_l(L_sqrt_l(L_div_ll(GAIN_REF_LEVEL,voice_est)),8);
		}		
	}
	else if (duration &gt; GAIN_DURATION_TH_1 ) { // activate gradually	
		if (voice_est &gt; GAIN_SENSITIVITY_TH) { // is input high enough
			//double a = ((double)(duration-GAIN_DURATION_TH_1))/((double)(GAIN_DURATION_TH_2-GAIN_DURATION_TH_1));
			//gain = sqrt(((double)GAIN_REF_LEVEL)/((double)voice_est));
			//gain = gain*a+1*(1-a);
			
			int16_t a = (int16_t) L_div_ll(duration-GAIN_DURATION_TH_1,GAIN_DURATION_TH_2-GAIN_DURATION_TH_1);			
			//printf("%d/%d = %d\n",duration-GAIN_DURATION_TH_1,GAIN_DURATION_TH_2-GAIN_DURATION_TH_1,(int)a);			
			//gain = (L_sqrt_l(L_div_ll(GAIN_REF_LEVEL,voice_est))+(1&lt;&lt;7))&gt;&gt;8;
			gain = L_shr_l(L_sqrt_l(L_div_ll(GAIN_REF_LEVEL,voice_est)),8);	
			//printf("gain = %d\n",gain&gt;&gt;15);
			gain = L_mpy_ls(gain,a)+L_mpy_ls(q16_15_1,(0x7fff-a));
			//printf("gain = %d\n\n",gain&gt;&gt;15);
		}
	}
	
	return gain;
	
} // calculate_gain


int32_t cm_turbo_vad_preprocess(sru_call_t * call, int32_t conferee_index, int32_t port_id,int32_t frame_pow, bool upsample, sru_scratch_t * sru_scratch) {
		
	// update duration, VAD &amp; voice, noise and power estimates	
	int32_t 	voice_est, noise_est, power_est;	
	int32_t		stand_VAD, power_VAD, prev_VAD, curr_VAD,ar;
	int32_t		z_p, z_p_c;
	sru_port_t * port = sru_find_port(port_id);
	conferee_state_t* state_raw = port-&gt;conferee_state;
	
	turbo_vad_conferee_state_t *state = (turbo_vad_conferee_state_t*) state_raw;
	
	port_type_t port_type= sru_find_port(port_id)-&gt;type;
	
	scratch_wb_buff_t * scratch_buff = sru_scratch-&gt;scratch_buff_array;
	
	int16_t * vad_buff = MMP_COMMON_BUFFER_POS(port-&gt;in_buff);
	
	if (state == NULL)
		return 0;
		
	//downsample wb inputs for VAD	
	if (port_type == PORT_TYPE_WIDE_BAND) {
		vad_buff = scratch_buff[conferee_index];
		Dn2xProcess(port-&gt;downsampling_state,MMP_COMMON_BUFFER_POS(port-&gt;in_buff), vad_buff, PCM_FRAME_SIZE_NB);		
	}
	
	
	
	if (upsample &amp;&amp; (port_type == PORT_TYPE_NARROW_BAND))  // upsample
		Up2xProcess(port-&gt;upsampling_state,MMP_COMMON_BUFFER_POS(port-&gt;in_buff), scratch_buff[conferee_index], PCM_FRAME_SIZE_NB);
	
	
	// read state	
	prev_VAD = state-&gt;VAD_decision;	
	voice_est = state-&gt;voice_est;d
	noise_est = state-&gt;noise_est;
	power_est = state-&gt;power_est;
					
	// updae power estimate (conditional exponantial average)
			
	if(frame_pow &gt; power_est) {
		z_p = Z_P1;
		z_p_c = Z_P1_CMP;
	}
	else {
		z_p = Z_P2;
		z_p_c = Z_P2_CMP;
	}	
	
	
/*	// get scaling factor to be used when calculatin estimates
	// Canceled - This is rather unnecessary since the transition to/from dBm units adds inaccuracy
 
	int32_t frame_pow_s = S_exp0_l(frame_pow);
	int32_t power_s = S_exp0_l(power_est);
	int32_t voice_s = S_exp0_l(voice_est);
	int32_t noise_s = S_exp0_l(noise_est);
	int32_t s;
*/	

	

/*	
	if (frame_pow_s &gt; power_s)
		s = power_s;
	else
		s = frame_pow_s;	
*/	

	//power_est = (int) round(((1-z_p)*((double)power_est)+z_p*(double)frame_pow));	
	/*power_est = (L_mpy_ll(power_est&lt;&lt;s,z_p_c)+L_mpy_ll(frame_pow&lt;&lt;s,z_p)+(1&lt;&lt;(s-1)))&gt;&gt;s;	*/	
	power_est = L_mpy_ll(power_est,z_p_c)+L_mpy_ll(frame_pow,z_p);		
	
	// standard VAD	
	stand_VAD = cm_turbo_vad_get_standard_VAD(state,vad_buff,sru_scratch-&gt;scratch_VAD_bit_buff);	
	
	// power_based_VAD
	power_VAD = cm_turbo_vad_get_power_VAD(voice_est,noise_est,power_est);	
	
	// VAD = turbo_VAD(stand_VAD,power_VAD)
	curr_VAD = cm_turbo_vad_get_turbo_VAD(stand_VAD,power_VAD);	
		
	// update state and ar
	ar = cm_turbo_vad_fsm(state,curr_VAD,prev_VAD,call-&gt;params.fo_multiplier);


/*	// update estimates
	// for simplicity use one scaling factor for voice and noise estimates

	
	if (noise_s &gt; voice_s)
		s = voice_s;
	else
		s = noise_s;
	
	if (s &gt; frame_pow_s)
		s = frame_pow_s;	
*/

	if (state-&gt;fsm_state == 0 ) { // state == NOT ACTIVE
		//noise_est = (int)round(((1-Z_N)*(double)noise_est+Z_N*(double)frame_pow));
		/*noise_est = (L_mpy_ll(noise_est&lt;&lt;s,Z_N_CMP)+L_mpy_ll(frame_pow&lt;&lt;s,Z_N)+(1&lt;&lt;(s-1)))&gt;&gt;s; */
		noise_est = L_mpy_ll(noise_est,Z_N_CMP)+L_mpy_ll(frame_pow,Z_N); 
		
		//voice_est = (int)round(((1-Z_L)*(double)voice_est));  // leakage
		/*voice_est = (L_mpy_ll(voice_est&lt;&lt;s,Z_L_CMP)+(1&lt;&lt;(s-1)))&gt;&gt;s; */
		voice_est = L_mpy_ll(voice_est,Z_L_CMP); // leakage
	}
	else if (state-&gt;fsm_state == 2 ) { // state == ACTIVE
		//voice_est = (int)round(((1-Z_V)*(double)voice_est+Z_V*(double)frame_pow));
		/*voice_est = (L_mpy_ll(voice_est&lt;&lt;s,Z_V_CMP)+L_mpy_ll(frame_pow&lt;&lt;s,Z_V)+(1&lt;&lt;(s-1)))&gt;&gt;s;*/
		voice_est = L_mpy_ll(voice_est,Z_V_CMP)+L_mpy_ll(frame_pow,Z_V);
	}
	
	// update state	
	state-&gt;VAD_decision = curr_VAD;	
	state-&gt;voice_est = voice_est;
	state-&gt;noise_est = noise_est;
	state-&gt;power_est = power_est;	
	
	// update duration
	state-&gt;duration += 1; 	

	// update gain
    if ((state-&gt;duration)&lt;&lt;(32-6) == 0) { // update gain once every 2^6 frames (~0.64 sec)
        state-&gt;gain = cm_turbo_vad_calculate_gain(voice_est,state-&gt;duration);
    }
	
	// calculate and return score	 
	return cm_turbo_vad_ar_2_score(ar);

}



void cm_turbo_vad_get_mixing_coef(int32_t lar[], int32_t score[], sru_call_t * call, mixing_coef_t * curr_frame_coef, sru_state_t* sru_state){
		
	int32_t 	i,j,i1,i2,i3,ones,active,long_active;
	int32_t		max1,max2,max3;
	int32_t 	l1,l2,l3;
	int32_t		maxlar1,maxlar2,maxlar3;
	int32_t		c1,c2,c; // Q31
			
	// find three with maximal scores and count score == MAX
	// among those with 0 score find three with maximal lar
	i1 = -1;
	i2 = -1;
	i3 = -1;
	max1 = 0;
	max2 = 0;
	max3 = 0;
	ones = 0;
	maxlar1 = 0;
	maxlar2 = 0;
	maxlar3 = 0;	
	l1 = -1;
	l2 = -1;
	l3 = -1;
	
	
	for (i=0; i&lt;sru_state-&gt;sru_max_call_ports;i++){

		if( score[i] == MAX_AR) {
			ones += 1;
		}
				
		if (score[i] &gt; max1 ) {				
				i3 = i2;
				i2 = i1;
				i1 = i;
				max3 = max2;
				max2 = max1;
				max1 = score[i];
		}
		
		else if(score[i] &gt; max2) {
				i3 = i2;
				i2 = i;				
				max3 = max2;
				max2 = score[i];
		}
		
		else if(score[i] &gt; max3) {				
				i3 = i;								
				max3 = score[i];
		}	

		else if (lar[i] &gt; maxlar1 ) {				
				l3 = l2;
				l2 = l1;
				l1 = i;
				maxlar3 = maxlar2;
				maxlar2 = maxlar1;
				maxlar1 = lar[i];
		}
		
		else if(lar[i] &gt; maxlar2) {
				l3 = l2;
				l2 = i;				
				maxlar3 = maxlar2;
				maxlar2 = lar[i];
		}
		
		else if(lar[i] &gt; maxlar3) {				
				l3 = i;								
				maxlar3 = lar[i];
		}	
	} // for
	
	// count active and long active
	
		
	// active

	if (max3 &gt; 0) 		// 3 active			
		active = 3;
	else if (max2 &gt; 0) 	// 2 active
		active = 2;
	else if (max1 &gt; 0) 	// 1 active
		active = 1;
	else 			 	// no one active 
		active = 0;
	
	// long active
		
	if (maxlar3 &gt; 0) 		// 3 active			
		long_active = 3;
	else if (maxlar2 &gt; 0) 	// 2 active
		long_active = 2;
	else if (maxlar1 &gt; 0) 	// 1 active
		long_active = 1;
	else 			 	// no one active 
		long_active = 0;
		
	long_active = MIN(call-&gt;params.enhancement_factor,long_active);
	
	
	// assign mixing coefficients
	
	// clear coef[][]	
	for (i=sru_state-&gt;sru_max_call_ports-1;i&gt;=0;i--) { // coefficients for out port i			
		for (j=sru_state-&gt;sru_max_call_ports-1;j&gt;=0;j--) {	 // coefficient j
				(*curr_frame_coef)[i][j] = 0;			
		}
	}

	
	if (ones &gt; 2) { // if more than 2 have max score give them all equal coefficient 
				
		//c1 = 1.0/ones;
		//c2 = 1.0/(ones-1);

		
		c1 = q31_reciprocal[ones];
		c2 = q31_reciprocal[ones-1];
	
		for (i=sru_state-&gt;sru_max_call_ports-1;i&gt;=0;i--) { // coefficients for out port i
		
			if (-1 == call-&gt;ports[i])
				continue;
			
			if (score[i] == MAX_AR) {
				c = c2;
			}
			
			else {
				c = c1;
			}
			
			for (j=sru_state-&gt;sru_max_call_ports-1;j&gt;=0;j--) {	
				if ((score[j] == MAX_AR) &amp;&amp; (j != i) ){ 
					(*curr_frame_coef)[i][j] = c;
				}
			} // for coefficient j
			
		} // for out port i
		
	} // if (ones &gt; 2)

	else { // select up to 2 speakers with max score

		for (i=sru_state-&gt;sru_max_call_ports-1;i&gt;=0;i--) { // coefficients for out port i
			
			int32_t i1_eff, i2_eff, l1_eff, l2_eff;
			int32_t	active_eff,long_active_eff;
			
			if (-1 == call-&gt;ports[i])
				continue;				
			
			
			// set effective values resulting
			// from exclusion of input i
			
			// default values
			i1_eff = i1;
			i2_eff = i2;
			l1_eff = l1;
			l2_eff = l2;
			
			active_eff = active;
			long_active_eff = long_active;
			
			if ((active &gt; 0) &amp;&amp; (i == i1)) {
				active_eff = active-1;
				i1_eff = i2;
				i2_eff = i3;				
			}
			else if ((active &gt; 1) &amp;&amp; (i == i2)) {
				active_eff = active-1;
				i2_eff = i3;
			}
			else if ((long_active &gt; 0) &amp;&amp; (i == l1)) {
				long_active_eff = long_active-1;
				l1_eff = l2;
				l2_eff = l3;				
			}
			else if ((long_active &gt; 1) &amp;&amp; (i == l2)) {
				long_active_eff = long_active-1;
				l2_eff = l3;
			}	
				
			
			if (active_eff &gt; 2)	
				active_eff = 2; // only 2 will be mixed

				
			switch(active_eff) {
		
				case 2:		
					(*curr_frame_coef)[i][i1_eff] = Q31_HALF;
					(*curr_frame_coef)[i][i2_eff] = Q31_HALF;
					break;
					
				case 1:					
					if (long_active_eff &gt; 0) { 
						(*curr_frame_coef)[i][i1_eff] = Q31_ONE-(lar[l1]/2);
						(*curr_frame_coef)[i][l1_eff] = (lar[l1]/2);				
					}
					else {
						(*curr_frame_coef)[i][i1_eff] = Q31_ONE;
					}
					break;
				
				case 0:					
					if (long_active_eff &gt; 1) { 
						(*curr_frame_coef)[i][l1] = lar[l1]/2;
						(*curr_frame_coef)[i][l2] = lar[l2]/2;							
					}
					else if (long_active_eff == 1) {
						(*curr_frame_coef)[i][l1] = lar[l1];
					}				
					break;					
					
				default:
				
					break;
					
			} // switch (active_eff)
			
		} // for (out port i)
		
	} // else (ones &lt;= 2)
		
/*	pre enhancment implemntation
 * 
	else { // select up to 2 speakers with max score

			
		if (3 == active) { // 3 active			
			c1 = Q31_HALF;// Q31 0.5;
			c2 = Q31_HALF;// Q31 0.5;	
		}
		else if ( 2 == active) { // 2 active
			c1 = Q31_HALF;// Q31 0.5;
			c2 = Q31_ONE; // Q31 ~1
		}
		else if (1 == active) { // 1 active
			c1 = Q31_ONE; // Q31 ~1
			c2 = 0;
		}
		else { // no one active	
				return;
		}					
					
		
		for (i=sru_state-&gt;sru_max_call_ports-1;i&gt;=0;i--) { // coefficients for out port i
		
			if (-1 == call-&gt;ports[i])
				continue;			
				
			if ( i == i1 ) {
				if (active &gt;= 2)
					(*curr_frame_coef)[i][i2] = c2;
					
				if (active &gt;= 3)
					(*curr_frame_coef)[i][i3] = c2;
			}				
			else if (i == i2) {
				
				(*curr_frame_coef)[i][i1] = c2;
					
				if (active &gt;= 3)
					(*curr_frame_coef)[i][i3] = c2;
			}
			else {
				(*curr_frame_coef)[i][i1] = c1;
				
				if (active &gt;= 2)
					(*curr_frame_coef)[i][i2] = c1;
			}
			
		} // for (out port i)
		
	} // else (ones &lt;= 2)
*/
	
} // mixing_coef



void cm_turbo_vad_average_coef(mixing_coef_t * current_frame_coef,turbo_vad_conference_state_t * state, sru_state_t * sru_state) {
	
	int32_t top = state-&gt;fifo_top_index; // top of fifo weights fifo
	mixing_w_fifo_t * weights;
	int16_t filter[AVG_FLTR_DEPTH];
	int32_t i,j,k;
	int32_t sum;
	mixing_coef_t * coef;
	
	
	//const double A[AVG_FLTR_DEPTH] = {0.2864,0.2175,0.1155,0.0791,0.0603,0.0487,0.0408,0.0352,0.0309,0.0276,0.0249,0.0331}; // average filter
	const int16_t A[AVG_FLTR_DEPTH] = {A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11}; // average filter Q15

	weights = &amp;(state-&gt;weights);
	coef = &amp;(state-&gt;coef);

	// allign filter A
	for(k=0;k&lt;=top;k++) {
		filter[top-k] = A[k]; 
	}	
	for(k=top+1;k&lt;AVG_FLTR_DEPTH;k++) {
		filter[AVG_FLTR_DEPTH+top-k] = A[k];
	}	
	
	// calculate average	
	for(i=0;i&lt;sru_state-&gt;sru_max_call_ports;i++) {
		for(j=0;j&lt;sru_state-&gt;sru_max_call_ports;j++) {
			(*weights)[i][j][top] = (*current_frame_coef)[i][j]; // update weights fifo
			
			//calculate averaged coeeficients
			// 	we will update the average only in case current frame value is different from the previous average
			// 	equality is rather frequent and is most likely to happen when coeficients == 0/1
			int32_t v1 = (*coef)[i][j];
			int32_t v2 = (*current_frame_coef)[i][j];
			//if ( (*current_frame_coef)[i][j] != (*coef)[i][j]){
			if ( v1 != v2){
				sum = 0;
				for(k=0;k&lt;AVG_FLTR_DEPTH;k++) {
					//(*coef)[i][j] += filter[k]*((*weights)[i][j][k]);
					int32_t x = (*weights)[i][j][k];
					int16_t y = filter[k];
					sum = L_mac_ls(sum,x,y);
					//sum = L_mac_ls(sum,(*weights)[i][j][k],filter[k]);
				}
				(*coef)[i][j] = sum;
			}
		}
	}
	
	// update fifo top index (wrap around)
	top += 1;
	if (top &gt;= AVG_FLTR_DEPTH)
		state-&gt;fifo_top_index = top-AVG_FLTR_DEPTH;
	else
		state-&gt;fifo_top_index = top;	
	
} // average_coef



void cm_turbo_vad_mac_vector(int16_t * restrict in_vec,int32_t a,int32_t gain, int32_t * restrict accum, int32_t M) {

//	int32_t i;
	int32_t c;

	//gain = (gain+(1&lt;&lt;5))&gt;&gt;6; // convert to Q.9 (gain is less than 63 for sure)

    c = L_mpy_ll(a,gain); // effective coefficient (including the gain) Q16.15 

#ifdef ARM9E_OPTIMIZED
    {
    
    const int32_t *restrict x=(const int32_t *)(in_vec);        
	const int32_t *restrict y=(const int32_t *)(accum);
    int32_t x0;
    int32_t y0,y1;
    NASSERT_ALIGN4(x);
    NASSERT_ALIGN4(y);

    c = c&gt;&gt;6; // gain Q16.15 ==&gt;Q6.9

    _LDRINC(x,x0);
    y0 = *y;
    M = M&gt;&gt;1;
	for(;M&gt;0;M--) {
        __SMLABB(y0,x0,c);  _ASM_VOLATILE;
        y1 = *(y+1);        _ASM_VOLATILE;
        _STRINC(y,y0);      _ASM_VOLATILE;
        __SMLATB(y1,x0,c);  _ASM_VOLATILE;
        _STRINC(y,y1);      _ASM_VOLATILE;
        _LDRINC(x,x0);      _ASM_VOLATILE;
        y0 = *y;            _ASM_VOLATILE;
        
        //in_val = ((int32_t)in_vec[M])&lt;&lt;16; // Q.15 =&gt; Q.31
        //accum[M] = L_mac_ll(accum[M],c,in_val); // Q16.15xQ.31
	}
    }
#else
	for(M--;M&gt;=0;M--) {
        int32_t in_val;

		//accum[i] += a*((double)in_vec[i]);
		//accum[i] = L_mac_ll(accum[i],a,L_mul_ls((gain+(1&lt;&lt;14))&gt;&gt;15,in_vec[i])); // gain is Q16.15. Better possibility is shift in_vec left and take high bits of mul
		//accum[i] = L_mac_ll(accum[i],a,L_mul_ls(L_shr_l(gain,15),in_vec[i]));

        //accum[i] = L_mac_ll(accum[i],a,L_mul_ls(gain,in_vec[i])); //Q.9
        in_val = ((int32_t)in_vec[M])&lt;&lt;16; // Q.15 =&gt; Q.31
        accum[M] = L_mac_ll(accum[M],c,in_val); // Q16.15xQ.31

	}

#endif
	
} // mac_...

void cm_turbo_vad_clear_vector(int32_t * vec, int32_t M) {
	
//	int32_t i;
	
	mmp_os_memset((uint8_t*)vec, 0, M*4); // 4 bytes per sample
	/*
	for(i=M-1;i&gt;=0;i--) {
		vec[i] = 0;
	}
	 */ 
	
} // clear_...

/* misc conversions  saturation: Q16.15-&gt;Q15        */
inline_ int16_t S_sature_l (int32_t x)
{
//	return (int16_t)(L_shl_l(x,16)&gt;&gt;16);
#ifdef ARMV6
    return (int16_t)_SSAT(16,x);
#else
    if (x&gt;MAX_INT16) x=MAX_INT16;
    if (x&lt;MIN_INT16) x=MIN_INT16;
    return (int16_t)x;
#endif
}

void cm_turbo_vad_cast_vector(int32_t *in_vec, int16_t *out_vec, int32_t M) {

//	int32_t i;	
//	int32_t value;
	
#ifdef ARM9E_OPTIMIZED
    
    const int32_t *restrict x=(const int32_t *)(in_vec);
    const int32_t *restrict y=(const int32_t *)(out_vec);
    int32_t x0,x1,y0,y1;

    NASSERT_ALIGN8(x);
    _LDM2INC(x,x0,x1);            
    M = M&gt;&gt;1;
 	for(;M&gt;0;M--) {
        y0 = S_sature_l(x0&gt;&gt;9);     _ASM_VOLATILE; 
        y1 = S_sature_l(x1&gt;&gt;9);     _ASM_VOLATILE; 
        _ADDLSL(x0,y1,y0,16);       _ASM_VOLATILE;    
        _STRINC(y,x0);              _ASM_VOLATILE; 
        //out_vec[M] = S_sature_l(in_vec[M]&gt;&gt;9); // saturate
        _LDM2INC(x,x0,x1);          _ASM_VOLATILE;    
	}   	
#else
	for(M--;M&gt;=0;M--) {
		 //value = (in_vec[i]+(1&lt;&lt;8))&gt;&gt;9; // in_vec is Q.9
		 //out_vec[i] = S_sature_l(value); // saturate
         out_vec[M] = S_sature_l(in_vec[M]); // saturate Q16.15 =&gt; Q.15
	}

#endif
	
} //cast_and_clear_vector


void cm_turbo_vad_output_mix(sru_call_t * call,mixing_coef_t * coef,sru_state_t * sru_state) {
	
	sru_scratch_t * sru_scratch = sru_state-&gt;scratch;
	//turbo_vad_conference_state_t * conf_state = (turbo_vad_conference_state_t *) (call-&gt;conf_state);
		
	int32_t gain, coefficient;	
	
	int32_t *acc = sru_scratch-&gt;wb_32b_scratch_buff;	
	
	int32_t i,j,M;
		
	int16_t * in_buff;
	int16_t * out_buff;
	
	sru_port_t * in_port, * out_port;
	turbo_vad_conferee_state_t *conferee;
	
	scratch_wb_buff_t * scratch_buff = sru_scratch-&gt;scratch_buff_array;
	
	bool up_flag;

	for(i=0;i&lt;sru_state-&gt;sru_max_call_ports;i++) { // out for conferee i
	out_port = sru_find_port(call-&gt;ports[i]);
	  if(out_port) {
		  
		up_flag = 0;			
		
		if(out_port-&gt;type==PORT_TYPE_NARROW_BAND) {
			M = PCM_FRAME_SIZE_NB;
			out_buff = MMP_COMMON_BUFFER_POS(out_port-&gt;out_buff);
		}
		else if(call-&gt;num_wb_ports == 1) { // only 1 WB in call
			up_flag = 1;
			M = PCM_FRAME_SIZE_NB;
			out_buff = sru_scratch-&gt;nb_scratch_buff;		
		}
		else { // WB port &amp; call
			M = PCM_FRAME_SIZE_WB;
			out_buff = MMP_COMMON_BUFFER_POS(out_port-&gt;out_buff);
		}

		cm_turbo_vad_clear_vector(acc,M);

		for(j=0;j&lt;sru_state-&gt;sru_max_call_ports;j++) { // in from conferee j
		  coefficient = (*coef)[i][j];
		  if (coefficient &gt; 0) {
			in_port = sru_find_port(call-&gt;ports[j]);
			
			if (!in_port)  {
				continue;
			}
			
			if( ( (in_port-&gt;type == PORT_TYPE_NARROW_BAND) &amp;&amp; ( PCM_FRAME_SIZE_NB == M) )	||
				( (in_port-&gt;type == PORT_TYPE_WIDE_BAND) &amp;&amp; ( PCM_FRAME_SIZE_WB == M) )	) 
			{
				in_buff = MMP_COMMON_BUFFER_POS(in_port-&gt;in_buff);
			}

			else {
				in_buff = scratch_buff[j];	
			}
			conferee = (turbo_vad_conferee_state_t *) in_port-&gt;conferee_state;
			gain = (conferee-&gt;gain);			
			cm_turbo_vad_mac_vector(in_buff,coefficient,gain,acc,M);						
		  }
		}
		
		cm_turbo_vad_cast_vector(acc,out_buff,M);
		
		if(up_flag) {
			Up2xProcess(out_port-&gt;upsampling_state,out_buff, MMP_COMMON_BUFFER_POS(out_port-&gt;out_buff), PCM_FRAME_SIZE_NB);
		}		
	  }		
	}
	
	//free(acc);
			
} // output_mix

void cm_turbo_vad_set_cng_parameters(sru_call_t * call, sru_state_t * sru_state) {
	
	int32_t vad_decision;
	int32_t i,j;
	turbo_vad_conference_state_t *conf;
	
	for (i=0; i &lt; sru_state-&gt;sru_max_call_ports; i++) {		
		if (call-&gt;ports[i] == -1)
			continue;
		
		
		vad_decision = PCM_FRAME_STATUS_SILENCE;
		for (j=0; j &lt; sru_state-&gt;sru_max_call_ports; j++) {
			conf = (turbo_vad_conference_state_t *) call-&gt;conf_state; 		
			if (conf-&gt;coef[i][j] != 0) {
				vad_decision = PCM_FRAME_STATUS_VOICE;
				break;
			}
		}	
		
		sru_find_port(call-&gt;ports[i])-&gt;out_buff-&gt;status = vad_decision;
		// TODO: noise estimation (average ? last active ?)
	}
	
	
	
} // set_cng_parameters

int32_t cm_turbo_vad_mix_frame(sru_call_t * call, sru_state_t * sru_state) {
		
	sru_scratch_t * sru_scratch = sru_state-&gt;scratch;
	int32_t 		i;	
	int32_t 		M;	
	int32_t 		frame_pow[SRU_MAX_CALL_PORTS];	
	int32_t			score[SRU_MAX_CALL_PORTS]; // scores
	int32_t			lar[SRU_MAX_CALL_PORTS]; // scores
	mixing_coef_t	current_frame_coef; // coefficients before averaging
	sru_port_t 		*port;
	turbo_vad_conferee_state_t *conferee_state;
	
	turbo_vad_conference_state_t * conf_state = (turbo_vad_conference_state_t *) (call-&gt;conf_state);	
	int32_t *call_ports = call-&gt;ports; // Array of ports
		
	bool wb_call = (call-&gt;num_wb_ports &gt; 1);
	
	if (conf_state == NULL)
		return MMP_FAIL;
	
	// preprocess each conferee. update estimates, VADs, states, ar &amp; score
	for (i=0; i &lt; sru_state-&gt;sru_max_call_ports; i++) {		
		port = sru_find_port(call_ports[i]);
		if (port) {	
			if (port-&gt;type == PORT_TYPE_WIDE_BAND)
				M = PCM_FRAME_SIZE_WB;
			else
				M = PCM_FRAME_SIZE_NB;			
				
			frame_pow[i] = cm_turbo_vad_power(MMP_COMMON_BUFFER_POS(port-&gt;in_buff),M);
			score[i] = cm_turbo_vad_preprocess(call,i,port-&gt;id,frame_pow[i],wb_call,sru_scratch);			
			conferee_state = (turbo_vad_conferee_state_t *) port-&gt;conferee_state;
			lar[i] = conferee_state-&gt;lar;
			
		}
		else {
			score[i] = 0;
			lar[i] = 0;
		}
	}	 
	 

	// calculate mixing coefficients
	cm_turbo_vad_get_mixing_coef(lar, score, call, &amp;current_frame_coef, sru_state); // coefficients for current frame
	 
	// mix
	if (call-&gt;params.enable_smoothing) {
		cm_turbo_vad_average_coef(&amp;current_frame_coef,conf_state, sru_state); // final mixing coefficients (after averaging)
		cm_turbo_vad_output_mix(call,&amp;conf_state-&gt;coef,sru_state);
	}
	else {
		cm_turbo_vad_output_mix(call,&amp;current_frame_coef,sru_state);		// dont use averaging
	}
	
	// CNG parameters	
	cm_turbo_vad_set_cng_parameters(call,sru_state);
	
	// update conference duration
	conf_state-&gt;duration += 1;
	
	return MMP_OK;
	
} // mix_frame


int32_t cm_turbo_vad_exec_call(sru_call_t * call,bool fwd, sru_state_t * sru_state) {
		

	if (sru_state == NULL || call ==NULL)
		return MMP_FAIL;
	
      if (call-&gt;id &gt; 0 &amp;&amp; call-&gt;num_ports)
      {		  
		  	
		if (call-&gt;num_ports &lt;= CM_FALL_BACK_TH ) /* use vanilla if no more than FALL_BACK_TH participate */
			return cm_vanilla_exec_call(call, fwd, sru_state);
				
		// turbo VAD conference. mix only on fwd
		if (!fwd) 
			return MMP_OK;
								
		return cm_turbo_vad_mix_frame(call,sru_state);
	  }
	  
	  return MMP_OK;
	  
		  /* 2 participant mixing from early implementation.	   
		     Now, 2 participant call will be handled by vanilla (assuming TURBO_FALL_BACK_TH &gt;1)
		   
		  else { // 2 participant call		
			
			int32_t j,k,M;
			port_type_t out_port_type, in_port_type;
			sru_port_t * in_port, * out_port;
			int16_t * in_buff, *out_buff;
	  
			for ( k = 0; k &lt; sru_state-&gt;sru_max_call_ports; k++) 
			{
			int32_t p1 = call-&gt;ports[k];
			out_port = sru_find_port(p1);
          
			// Mix signals for remote out_buff only if fwd direction, 
			// or local out_buff only if rtn direction (i.e. fwd + local == 1) 
			if (p1 &lt; 0 || ((int32_t)fwd + (int32_t)(out_port-&gt;local)) != 1) 
				continue;
          
			out_buff = MMP_COMMON_BUFFER_POS(out_port-&gt;out_buff);
			out_port_type = out_port-&gt;type;
			//mmp_os_memset((uint8_t*)sru_tmp_buf, 0, sizeof(sru_tmp_buf));
          
			// Mix all parties except for oneself (only one such)
			for ( j = 0; j &lt; sru_state-&gt;sru_max_call_ports; j++) 
			{
				int32_t  p2 = call-&gt;ports[j];
				in_port = sru_find_port(p2);				
				if (p2 &lt; 0 || p2 == p1)
					continue;
            
				in_buff = MMP_COMMON_BUFFER_POS(in_port-&gt;in_buff);
				in_port_type = in_port-&gt;type;
				
				if ( (out_port_type == PORT_TYPE_WIDE_BAND) &amp;&amp; (in_port_type == PORT_TYPE_NARROW_BAND)) {
					
					// upsample directly to out_port
					Up2xProcess(in_port-&gt;upsampling_state,in_buff, out_buff, PCM_FRAME_SIZE_NB);
										
				}
				else if ((out_port_type == PORT_TYPE_NARROW_BAND) &amp;&amp; (in_port_type == PORT_TYPE_WIDE_BAND)) {
 
					// downsample directly to out_port
					Dn2xProcess(in_port-&gt;downsampling_state,in_buff, out_buff, PCM_FRAME_SIZE_NB);
					
				}
				else {
					if (in_port_type == PORT_TYPE_WIDE_BAND )
						M = PCM_FRAME_SIZE_WB;
					else
						M = PCM_FRAME_SIZE_NB;
						
					// simply copy buffers
					mmp_os_memcpy(out_buff,in_buff,M*2);//2 bytes per sample
				}
				
				break; // only one input (two way call)
				
				//for (m = 0; m &lt; PCM_FRAME_SIZE_NB; m++) {
				//	sru_tmp_buf[m] += in_buff[m];
				//}
				
				
			 } // in port loop
			} // out_port loop
			 
			 */
			 
  
} // call exec


int32_t cm_turbo_vad_get_conferee_stats(conferee_state_t* raw_state, mmp_conferee_stats_t * stats) {
	
	turbo_vad_conferee_state_t *state = (turbo_vad_conferee_state_t*) raw_state;

	if(!state)
		return MMP_FAIL;

	stats-&gt;duration = state-&gt;duration;
	stats-&gt;noise_level = cm_turbo_vad_power_to_dbm(state-&gt;noise_est); // units - [dbm/100]
	stats-&gt;voice_level = cm_turbo_vad_power_to_dbm(state-&gt;voice_est); // units - [dbm/100]
	stats-&gt;current_activity = (state-&gt;lar)&gt;&gt;27;  // 0-f
	stats-&gt;average_activity = L_div_ll(state-&gt;avtive_counter,state-&gt;duration)&gt;&gt;11;
	
	return MMP_OK;
}
</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2012/01/18" Time="17:28:30000">
<Copy StartSeek="0" EndSeek="26577"/>
<Copy StartSeek="26866" EndSeek="35772"/>
</Delta>
<Delta Version="1" Comment="" NL="\10" Encoding="text" Date="2012/01/19" Time="12:10:45000">
<Copy StartSeek="0" EndSeek="14457"/>
<Insert>	voice_est = state-&gt;voice_est;
</Insert>
<Copy StartSeek="14489" EndSeek="35773"/>
</Delta>
</DeltaFile>
