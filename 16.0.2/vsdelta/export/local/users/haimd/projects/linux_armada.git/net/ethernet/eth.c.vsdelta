<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="10" Comment="" Date="2013/02/20" Time="19:36:31000" NL="\10" Encoding="text">
<Insert>/*
 * INET		An implementation of the TCP/IP protocol suite for the LINUX
 *		operating system.  INET is implemented using the  BSD Socket
 *		interface as the means of communication with the user level.
 *
 *		Ethernet-type device handling.
 *
 * Version:	@(#)eth.c	1.0.7	05/25/93
 *
 * Authors:	Ross Biro
 *		Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;
 *		Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;
 *		Florian  La Roche, &lt;rzsfl@rz.uni-sb.de&gt;
 *		Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;
 *
 * Fixes:
 *		Mr Linux	: Arp problems
 *		Alan Cox	: Generic queue tidyup (very tiny here)
 *		Alan Cox	: eth_header ntohs should be htons
 *		Alan Cox	: eth_rebuild_header missing an htons and
 *				  minor other things.
 *		Tegge		: Arp bug fixes.
 *		Florian		: Removed many unnecessary functions, code cleanup
 *				  and changes for new arp and skbuff.
 *		Alan Cox	: Redid header building to reflect new format.
 *		Alan Cox	: ARP only when compiled with CONFIG_INET
 *		Greg Page	: 802.2 and SNAP stuff.
 *		Alan Cox	: MAC layer pointers/new format.
 *		Paul Gortmaker	: eth_copy_and_sum shouldn't csum padding.
 *		Alan Cox	: Protect against forwarding explosions with
 *				  older network drivers and IFF_ALLMULTI.
 *	Christer Weinigel	: Better rebuild header message.
 *             Andrew Morton    : 26Feb01: kill ether_setup() - use netdev_boot_setup().
 *
 *		This program is free software; you can redistribute it and/or
 *		modify it under the terms of the GNU General Public License
 *		as published by the Free Software Foundation; either version
 *		2 of the License, or (at your option) any later version.
 */
#include &lt;linux/module.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;linux/socket.h&gt;
#include &lt;linux/in.h&gt;
#include &lt;linux/inet.h&gt;
#include &lt;linux/ip.h&gt;
#include &lt;linux/netdevice.h&gt;
#include &lt;linux/etherdevice.h&gt;
#include &lt;linux/skbuff.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/if_ether.h&gt;
#include &lt;net/dst.h&gt;
#include &lt;net/arp.h&gt;
#include &lt;net/sock.h&gt;
#include &lt;net/ipv6.h&gt;
#include &lt;net/ip.h&gt;
#include &lt;net/dsa.h&gt;
#include &lt;asm/uaccess.h&gt;
#include &lt;asm/system.h&gt;

__setup("ether=", netdev_boot_setup);

/**
 * eth_header - create the Ethernet header
 * @skb:	buffer to alter
 * @dev:	source device
 * @type:	Ethernet type field
 * @daddr: destination address (NULL leave destination address)
 * @saddr: source address (NULL use device source address)
 * @len:   packet length (&lt;= skb-&gt;len)
 *
 *
 * Set the protocol type. For a packet of type ETH_P_802_3/2 we put the length
 * in here instead.
 */
int eth_header(struct sk_buff *skb, struct net_device *dev,
	       unsigned short type,
	       const void *daddr, const void *saddr, unsigned len)
{
	struct ethhdr *eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);

	if (type != ETH_P_802_3 &amp;&amp; type != ETH_P_802_2)
		eth-&gt;h_proto = htons(type);
	else
		eth-&gt;h_proto = htons(len);

	/*
	 *      Set the source hardware address.
	 */

	if (!saddr)
		saddr = dev-&gt;dev_addr;
	memcpy(eth-&gt;h_source, saddr, ETH_ALEN);

	if (daddr) {
		memcpy(eth-&gt;h_dest, daddr, ETH_ALEN);
		return ETH_HLEN;
	}

	/*
	 *      Anyway, the loopback-device should never use this function...
	 */

	if (dev-&gt;flags &amp; (IFF_LOOPBACK | IFF_NOARP)) {
		memset(eth-&gt;h_dest, 0, ETH_ALEN);
		return ETH_HLEN;
	}

	return -ETH_HLEN;
}
EXPORT_SYMBOL(eth_header);

/**
 * eth_rebuild_header- rebuild the Ethernet MAC header.
 * @skb: socket buffer to update
 *
 * This is called after an ARP or IPV6 ndisc it's resolution on this
 * sk_buff. We now let protocol (ARP) fill in the other fields.
 *
 * This routine CANNOT use cached dst-&gt;neigh!
 * Really, it is used only when dst-&gt;neigh is wrong.
 */
int eth_rebuild_header(struct sk_buff *skb)
{
	struct ethhdr *eth = (struct ethhdr *)skb-&gt;data;
	struct net_device *dev = skb-&gt;dev;

	switch (eth-&gt;h_proto) {
#ifdef CONFIG_INET
	case htons(ETH_P_IP):
		return arp_find(eth-&gt;h_dest, skb);
#endif
	default:
		printk(KERN_DEBUG
		       "%s: unable to resolve type %X addresses.\n",
		       dev-&gt;name, ntohs(eth-&gt;h_proto));

		memcpy(eth-&gt;h_source, dev-&gt;dev_addr, ETH_ALEN);
		break;
	}

	return 0;
}
EXPORT_SYMBOL(eth_rebuild_header);

/**
 * eth_type_trans - determine the packet's protocol ID.
 * @skb: received socket data
 * @dev: receiving network device
 *
 * The rule here is that we
 * assume 802.3 if the type field is short enough to be a length.
 * This is normal practice and works for any 'now in use' protocol.
 */
__be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev)
{
	struct ethhdr *eth;

	skb-&gt;dev = dev;
	skb_reset_mac_header(skb);
	skb_pull_inline(skb, ETH_HLEN);
	eth = eth_hdr(skb);

	if (unlikely(is_multicast_ether_addr(eth-&gt;h_dest))) {
		if (!compare_ether_addr_64bits(eth-&gt;h_dest, dev-&gt;broadcast))
			skb-&gt;pkt_type = PACKET_BROADCAST;
		else
			skb-&gt;pkt_type = PACKET_MULTICAST;
	}

	/*
	 *      This ALLMULTI check should be redundant by 1.4
	 *      so don't forget to remove it.
	 *
	 *      Seems, you forgot to remove it. All silly devices
	 *      seems to set IFF_PROMISC.
	 */

	else if (1 /*dev-&gt;flags&amp;IFF_PROMISC */ ) {
		if (unlikely(compare_ether_addr_64bits(eth-&gt;h_dest, dev-&gt;dev_addr)))
			skb-&gt;pkt_type = PACKET_OTHERHOST;
	}

	/*
	 * Some variants of DSA tagging don't have an ethertype field
	 * at all, so we check here whether one of those tagging
	 * variants has been configured on the receiving interface,
	 * and if so, set skb-&gt;protocol without looking at the packet.
	 */
	if (netdev_uses_dsa_tags(dev))
		return htons(ETH_P_DSA);
	if (netdev_uses_trailer_tags(dev))
		return htons(ETH_P_TRAILER);

	if (ntohs(eth-&gt;h_proto) &gt;= 1536)
		return eth-&gt;h_proto;

	/*
	 *      This is a magic hack to spot IPX packets. Older Novell breaks
	 *      the protocol design and runs IPX over 802.3 without an 802.2 LLC
	 *      layer. We look for FFFF which isn't a used 802.2 SSAP/DSAP. This
	 *      won't work for fault tolerant netware but does for the rest.
	 */
	if (skb-&gt;len &gt;= 2 &amp;&amp; *(unsigned short *)(skb-&gt;data) == 0xFFFF)
		return htons(ETH_P_802_3);

	/*
	 *      Real 802.2 LLC
	 */
	return htons(ETH_P_802_2);
}
EXPORT_SYMBOL(eth_type_trans);

/**
 * eth_header_parse - extract hardware address from packet
 * @skb: packet to extract header from
 * @haddr: destination buffer
 */
int eth_header_parse(const struct sk_buff *skb, unsigned char *haddr)
{
	const struct ethhdr *eth = eth_hdr(skb);
	memcpy(haddr, eth-&gt;h_source, ETH_ALEN);
	return ETH_ALEN;
}
EXPORT_SYMBOL(eth_header_parse);

/**
 * eth_header_cache - fill cache entry from neighbour
 * @neigh: source neighbour
 * @hh: destination cache entry
 * @type: Ethernet type field
 * Create an Ethernet header template from the neighbour.
 */
int eth_header_cache(const struct neighbour *neigh, struct hh_cache *hh, __be16 type)
{
	struct ethhdr *eth;
	const struct net_device *dev = neigh-&gt;dev;

	eth = (struct ethhdr *)
	    (((u8 *) hh-&gt;hh_data) + (HH_DATA_OFF(sizeof(*eth))));

	if (type == htons(ETH_P_802_3))
		return -1;

	eth-&gt;h_proto = type;
	memcpy(eth-&gt;h_source, dev-&gt;dev_addr, ETH_ALEN);
	memcpy(eth-&gt;h_dest, neigh-&gt;ha, ETH_ALEN);
	hh-&gt;hh_len = ETH_HLEN;
	return 0;
}
EXPORT_SYMBOL(eth_header_cache);

/**
 * eth_header_cache_update - update cache entry
 * @hh: destination cache entry
 * @dev: network device
 * @haddr: new hardware address
 *
 * Called by Address Resolution module to notify changes in address.
 */
void eth_header_cache_update(struct hh_cache *hh,
			     const struct net_device *dev,
			     const unsigned char *haddr)
{
	memcpy(((u8 *) hh-&gt;hh_data) + HH_DATA_OFF(sizeof(struct ethhdr)),
	       haddr, ETH_ALEN);
}
EXPORT_SYMBOL(eth_header_cache_update);

/**
 * eth_mac_addr - set new Ethernet hardware address
 * @dev: network device
 * @p: socket address
 * Change hardware address of device.
 *
 * This doesn't change hardware matching, so needs to be overridden
 * for most real devices.
 */
int eth_mac_addr(struct net_device *dev, void *p)
{
	struct sockaddr *addr = p;

	if (netif_running(dev))
		return -EBUSY;
	if (!is_valid_ether_addr(addr-&gt;sa_data))
		return -EADDRNOTAVAIL;
	memcpy(dev-&gt;dev_addr, addr-&gt;sa_data, ETH_ALEN);
	return 0;
}
EXPORT_SYMBOL(eth_mac_addr);

/**
 * eth_change_mtu - set new MTU size
 * @dev: network device
 * @new_mtu: new Maximum Transfer Unit
 *
 * Allow changing MTU size. Needs to be overridden for devices
 * supporting jumbo frames.
 */
int eth_change_mtu(struct net_device *dev, int new_mtu)
{
	if (new_mtu &lt; 68 || new_mtu &gt; ETH_DATA_LEN)
		return -EINVAL;
	dev-&gt;mtu = new_mtu;
	return 0;
}
EXPORT_SYMBOL(eth_change_mtu);

int eth_validate_addr(struct net_device *dev)
{
	if (!is_valid_ether_addr(dev-&gt;dev_addr))
		return -EADDRNOTAVAIL;

	return 0;
}
EXPORT_SYMBOL(eth_validate_addr);

const struct header_ops eth_header_ops ____cacheline_aligned = {
	.create		= eth_header,
	.parse		= eth_header_parse,
	.rebuild	= eth_rebuild_header,
	.cache		= eth_header_cache,
	.cache_update	= eth_header_cache_update,
};

/**
 * ether_setup - setup Ethernet network device
 * @dev: network device
 * Fill in the fields of the device structure with Ethernet-generic values.
 */
void ether_setup(struct net_device *dev)
{
	dev-&gt;header_ops		= &amp;eth_header_ops;
	dev-&gt;type		= ARPHRD_ETHER;
	dev-&gt;hard_header_len 	= ETH_HLEN;
	dev-&gt;mtu		= ETH_DATA_LEN;
	dev-&gt;addr_len		= ETH_ALEN;
	dev-&gt;tx_queue_len	= 1000;	/* Ethernet wants good queues */
	dev-&gt;flags		= IFF_BROADCAST|IFF_MULTICAST;
	dev-&gt;priv_flags		|= IFF_TX_SKB_SHARING;

	memset(dev-&gt;broadcast, 0xFF, ETH_ALEN);

}
EXPORT_SYMBOL(ether_setup);

/**
 * alloc_etherdev_mqs - Allocates and sets up an Ethernet device
 * @sizeof_priv: Size of additional driver-private structure to be allocated
 *	for this Ethernet device
 * @txqs: The number of TX queues this device has.
 * @rxqs: The number of RX queues this device has.
 *
 * Fill in the fields of the device structure with Ethernet-generic
 * values. Basically does everything except registering the device.
 *
 * Constructs a new net device, complete with a private data area of
 * size (sizeof_priv).  A 32-byte (not bit) alignment is enforced for
 * this private data area.
 */

struct net_device *alloc_etherdev_mqs(int sizeof_priv, unsigned int txqs,
				      unsigned int rxqs)
{
	return alloc_netdev_mqs(sizeof_priv, "eth%d", ether_setup, txqs, rxqs);
}
EXPORT_SYMBOL(alloc_etherdev_mqs);

static size_t _format_mac_addr(char *buf, int buflen,
			       const unsigned char *addr, int len)
{
	int i;
	char *cp = buf;

	for (i = 0; i &lt; len; i++) {
		cp += scnprintf(cp, buflen - (cp - buf), "%02x", addr[i]);
		if (i == len - 1)
			break;
		cp += scnprintf(cp, buflen - (cp - buf), ":");
	}
	return cp - buf;
}

ssize_t sysfs_format_mac(char *buf, const unsigned char *addr, int len)
{
	size_t l;

	l = _format_mac_addr(buf, PAGE_SIZE, addr, len);
	l += scnprintf(buf + l, PAGE_SIZE - l, "\n");
	return (ssize_t)l;
}
EXPORT_SYMBOL(sysfs_format_mac);
</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2013/02/07" Time="10:00:47000">
<Copy StartSeek="0" EndSeek="4611"/>
<Copy StartSeek="4663" EndSeek="4691"/>
<Copy StartSeek="4743" EndSeek="4776"/>
<Copy StartSeek="4828" EndSeek="4849"/>
<Insert>
</Insert>
<Copy StartSeek="4901" EndSeek="5103"/>
<Insert>
</Insert>
<Copy StartSeek="5156" EndSeek="11183"/>
</Delta>
<Delta Version="1" Comment="" NL="\10" Encoding="text" Date="2013/02/20" Time="19:07:31000">
<Copy StartSeek="0" EndSeek="5103"/>
<Insert>	printk(KERN_ERR "(%s:%d) \n", __func__, __LINE__);

</Insert>
<Copy StartSeek="5105" EndSeek="11132"/>
</Delta>
<Delta Version="2" Comment="" NL="\10" Encoding="text" Date="2013/02/20" Time="19:08:58000">
<Copy StartSeek="0" EndSeek="5103"/>
<Insert>	
</Insert>
<Copy StartSeek="5104" EndSeek="5462"/>
<Insert>
</Insert>
<Copy StartSeek="5514" EndSeek="11182"/>
</Delta>
<Delta Version="3" Comment="" NL="\10" Encoding="text" Date="2013/02/20" Time="19:09:11000">
<Copy StartSeek="0" EndSeek="4611"/>
<Insert>	printk(KERN_ERR "(%s:%d) \n", __func__, __LINE__);
</Insert>
<Copy StartSeek="4714" EndSeek="4742"/>
<Insert>	printk(KERN_ERR "(%s:%d) \n", __func__, __LINE__);
</Insert>
<Copy StartSeek="4742" EndSeek="4775"/>
<Insert>	printk(KERN_ERR "(%s:%d) \n", __func__, __LINE__);
</Insert>
<Copy StartSeek="4775" EndSeek="4796"/>
<Insert>	printk(KERN_ERR "(%s:%d) \n", __func__, __LINE__);
</Insert>
<Copy StartSeek="4798" EndSeek="5359"/>
<Insert>	printk(KERN_ERR "(%s:%d) \n", __func__, __LINE__);
</Insert>
<Copy StartSeek="5361" EndSeek="11029"/>
</Delta>
<Delta Version="4" Comment="" NL="\10" Encoding="text" Date="2013/02/20" Time="19:18:9000">
<Copy StartSeek="0" EndSeek="4658"/>
<Insert>		printk(KERN_ERR "(%s:%d) \n", __func__, __LINE__);
	}
</Insert>
<Copy StartSeek="4789" EndSeek="11104"/>
</Delta>
<Delta Version="5" Comment="" NL="\10" Encoding="text" Date="2013/02/20" Time="19:18:34000">
<Copy StartSeek="0" EndSeek="4594"/>
<Insert>	skb-&gt;dev = dev;
</Insert>
<Copy StartSeek="4594" EndSeek="4772"/>
<Copy StartSeek="4790" EndSeek="11105"/>
</Delta>
<Delta Version="6" Comment="" NL="\10" Encoding="text" Date="2013/02/20" Time="19:18:46000">
<Copy StartSeek="0" EndSeek="4594"/>
<Insert>	if (!skb || !skb-&gt;data || !skb-&gt;mac_header) {
		printk(KERN_ERR "(%s:%d) skb %p, skb-&gt;data %p, skb-&gt;mac %p\n",
		       __func__, __LINE__, skb, skb-&gt;data, skb-&gt;mac_header);
</Insert>
<Copy StartSeek="4720" EndSeek="11056"/>
</Delta>
<Delta Version="7" Comment="" NL="\10" Encoding="text" Date="2013/02/20" Time="19:24:4000">
<Copy StartSeek="0" EndSeek="4594"/>
<Insert>	if (!skb || !skb-&gt;data) {
</Insert>
<Copy StartSeek="4629" EndSeek="4831"/>
<Insert>	
</Insert>
<Copy StartSeek="4908" EndSeek="11139"/>
</Delta>
<Delta Version="8" Comment="" NL="\10" Encoding="text" Date="2013/02/20" Time="19:28:26000">
<Copy StartSeek="0" EndSeek="4629"/>
<Insert>		printk(KERN_ERR "(%s:%d) skb %p, skb-&gt;data %p,\n",
		       __func__, __LINE__, skb, skb-&gt;data);
</Insert>
<Copy StartSeek="4740" EndSeek="11151"/>
</Delta>
<Delta Version="9" Comment="" NL="\10" Encoding="text" Date="2013/02/20" Time="19:28:38000">
<Copy StartSeek="0" EndSeek="4594"/>
<Insert>	if (!skb || !skb-&gt;data || !dev) {
		printk(KERN_ERR "(%s:%d) skb %p, skb-&gt;data %p dev %p,\n",
		       __func__, __LINE__, skb, skb-&gt;data, dev);
	}

</Insert>
<Copy StartSeek="4594" EndSeek="4693"/>
<Insert>	if (!eth) {
		printk(KERN_ERR "(%s:%d) eth NULL\n", __func__, __LINE__);
	}
</Insert>
<Copy StartSeek="4694" EndSeek="5255"/>
<Insert>	
</Insert>
<Copy StartSeek="5256" EndSeek="10924"/>
</Delta>
</DeltaFile>
