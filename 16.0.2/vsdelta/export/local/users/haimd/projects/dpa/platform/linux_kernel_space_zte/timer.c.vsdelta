<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="2" Comment="" Date="2013/06/20" Time="15:21:21000" NL="\10" Encoding="text">
<Insert>/************************************************************************
* Copyright (C) 2012, Marvell Technology Group Ltd.
* All Rights Reserved.
*
* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
* the contents of this file may not be disclosed to third parties, copied
* or duplicated in any form, in whole or in part, without the prior
* written permission of Marvell Technology Group.
*
* timer.c
*
* Description:
*       Hardware timer implementation.
*
*******************************************************************************/

#include &lt;linux/kernel.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;arch/arm/mach-feroceon-kw2/include/mach/irqs.h&gt;

#include &lt;util/timer.h&gt;
#include &lt;util/mem.h&gt;
#include &lt;log/log.h&gt;
#include &lt;dpa_errors.h&gt;

/* CPU HW Timer register access */
#define TIMER_CTRL_REG             0x00020300 
#define TIMER_RELOAD_REG(x)        ((x &lt; 2) ? (TIMER_CTRL_REG + 0x10 + (x) * 8) : \
                                              (TIMER_CTRL_REG + 0x20 + (x) * 8))
#define TIMER_VAL_REG(x)           ((x &lt; 2) ? (TIMER_CTRL_REG + 0x14 + (x) * 8) : \
                                              (TIMER_CTRL_REG + 0x24 + (x) * 8))

#define TIMER_CTRL_EN_OFFS(x)      ((x &lt; 2) ? (x * 2) : (4 + x * 2))
#define TIMER_CTRL_EN_MASK(x)      (1 &lt;&lt; TIMER_CTRL_EN_OFFS(x))

#define TIMER_CTRL_AUTO_EN_OFFS(x) (TIMER_CTRL_EN_OFFS(x) + 1)
#define TIMER_CTRL_AUTO_EN_MASK(x) (1 &lt;&lt; TIMER_CTRL_AUTO_EN_OFFS(x))

#define BRIDGE_INT_TIMER_MASK(x)   (1 &lt;&lt; (4 + x)) /* Timer 2 and 3 */


/* DPA specific constants */
#define TIMER_ID_MIN                2
#define TIMER_ID_MAX                3


typedef struct {
  uint32_t init; /* True if initialized */
  uint32_t irq; /* Associated IRQ vector */
  uint32_t id; /* HW timer number */
  void (*handler)(void* cookie); /* Timer processing routine */
  void *cookie; /* User data passed to handler */
} timer_state_t;


/* Timer states */
static timer_state_t timer_list[TIMER_ID_MAX + 1];


/* LSP exported helper prototype to set IRQ timer handler */
void mv_set_timer_handler(void (*handler)(uint32_t));

/************************************************************
 *  Helper routines
 */


inline void timer_set_count(uint32_t id, uint32_t clk_cnt) {
  DPA_REG_WRITE(TIMER_VAL_REG(id), clk_cnt);
}


inline void timer_set_reload_count(uint32_t id, uint32_t clk_cnt) {
  DPA_REG_WRITE(TIMER_RELOAD_REG(id), clk_cnt);
}


static inline void timer_enable(uint32_t id, bool enable, bool repeat) {
  uint32_t reg_val;

  /* CPU timer enable bit */
  reg_val = DPA_REG_READ(TIMER_CTRL_REG);
  if (enable) {
      reg_val |= TIMER_CTRL_EN_MASK(id);
  } else {
      reg_val &amp;= ~TIMER_CTRL_EN_MASK(id);
  }

  /* CPU timer auto mode */
  if (repeat) {
      reg_val |= TIMER_CTRL_AUTO_EN_MASK(id);
  } else {
      reg_val &amp;= ~TIMER_CTRL_AUTO_EN_MASK(id);
  }

  DPA_REG_WRITE(TIMER_CTRL_REG, reg_val);

  /* Mbus-L bus to Mbus bridge mask */
  reg_val = DPA_REG_READ(BRIDGE_INT_MASK_REG);
  if (enable) {
      reg_val |= BRIDGE_INT_TIMER_MASK(id);
  } else {
      reg_val &amp;= ~BRIDGE_INT_TIMER_MASK(id);
  }

  DPA_REG_WRITE(BRIDGE_INT_MASK_REG, reg_val);
}


static inline void timer_done(uint32_t id) {
  uint32_t cause;

  cause = DPA_REG_READ(BRIDGE_INT_CAUSE_REG);
  cause &amp;= ~BRIDGE_INT_TIMER_MASK(id);
  DPA_REG_WRITE(BRIDGE_INT_CAUSE_REG, cause);
}


void timer_isr_handler(uint32_t timer) {
  timer_state_t *t = &amp;timer_list[timer];

  if (t-&gt;init &amp;&amp; t-&gt;id == timer) {
      t-&gt;handler(t-&gt;cookie);
  }
}


/************************************************************
 *  Public API
 */


int32_t timer_create(timer_params_t *p) {
  uint32_t irq;
  int32_t id = (p != NULL) ? p-&gt;id : -1;

  if (id &lt; TIMER_ID_MIN || id &gt; TIMER_ID_MAX || timer_list[id].init) {
      return DPA_INVALID_PARAM;
  }

  /* Register interrupt handler and unmask interrupt */
  irq = TIMER_IRQ_NUM(id);
  if (p-&gt;mode == TIMER_MODE_IRQ) {
      mv_set_timer_handler(timer_isr_handler);
  } else {
    dpa_os_fiq_alloc(irq);
    dpa_os_timer_set_handler(timer_isr_handler);
  }

  timer_list[id].handler = p-&gt;handler;
  timer_list[id].cookie = p-&gt;cookie;
  timer_list[id].irq = irq;
  timer_list[id].id = id;
  timer_list[id].init = true;

  /* Reset and enable timer */
  timer_stop(id);
  timer_enable(id, true, false);

  DPA_DBG("Created HW timer (%d), irq (%d), mode (%d)", id, irq, (uint32_t)p-&gt;mode);

  return DPA_OK;
}


int32_t timer_destroy(uint32_t id) {
  uint32_t irq;

  if (id &lt; TIMER_ID_MIN || id &gt; TIMER_ID_MAX || !timer_list[id].init) {
      return DPA_INVALID_PARAM;
  }

  /* Reset and disable timer */
  timer_stop(id);
  timer_enable(id, false, false);

  /* Mask FIQ vector */
  irq = TIMER_IRQ_NUM(id);
  dpa_os_fiq_free(irq);
  timer_list[id].init = false;

  DPA_DBG("Terminated HW timer (%d), irq (%d)", id, irq);

  return DPA_OK;
}



void timer_start(uint32_t id, uint32_t clk_cnt) {
  timer_set_count(id, 10 /*clk_cnt */);
}


void timer_start_repeat(uint32_t id, uint32_t clk_cnt) {
  /* TODO Optimize if called frequently: Auto mode can be enabled just once */
  timer_enable(id, true, true);
  timer_set_count(id, clk_cnt);
  timer_set_reload_count(id, clk_cnt);
}


void timer_stop(uint32_t id) {
  timer_set_reload_count(id, 0);
  timer_set_count(id, 0);
}
</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2013/06/18" Time="18:47:51000">
<Copy StartSeek="0" EndSeek="3970"/>
<Insert>    dpa_os_fiq_alloc(irq);
</Insert>
<Copy StartSeek="4033" EndSeek="5303"/>
</Delta>
<Delta Version="1" Comment="" NL="\10" Encoding="text" Date="2013/06/20" Time="15:18:22000">
<Copy StartSeek="0" EndSeek="3970"/>
<Insert>    if (dpa_os_irq_alloc(irq))
	    return DPA_IRQ_ALLOC_FAIL;
</Insert>
<Copy StartSeek="3997" EndSeek="5267"/>
</Delta>
</DeltaFile>
