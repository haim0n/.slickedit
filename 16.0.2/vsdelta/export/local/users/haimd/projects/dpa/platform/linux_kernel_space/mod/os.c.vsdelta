<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="8" Comment="" Date="2013/06/19" Time="12:02:2000" NL="\10" Encoding="text">
<Insert>/************************************************************************
* Copyright (C) 2012, Marvell Technology Group Ltd.
* All Rights Reserved.
* 
* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
* the contents of this file may not be disclosed to third parties, copied
* or duplicated in any form, in whole or in part, without the prior
* written permission of Marvell Technology Group.
* 
* os.h
*
* DESCRIPTION:
*   DPA OS abstraction layer implementation.
*
*******************************************************************************/

#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/version.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/time.h&gt;
#include &lt;linux/ctype.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/vmalloc.h&gt;
#include &lt;linux/byteorder/generic.h&gt;
#include &lt;asm/unaligned.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/spinlock.h&gt;
#include &lt;linux/pci.h&gt;
#include &lt;linux/interrupt.h&gt;


#include &lt;dpa_os.h&gt;
#include &lt;util/mem.h&gt;
#include &lt;util/string.h&gt;
#include &lt;util/cache_ops.h&gt;
#include &lt;log/log.h&gt;


#define OS_ERROR(format, args...) DPA_ERROR(format, ##args)
#define OS_WARNING(format, args...) DPA_WARNING(format, ##args)
#define OS_INFO(format, args...) DPA_INFO(format, ##args)


#define DPA_OS_DEBUG

#ifdef DPA_OS_DEBUG
  #define OS_DBG(format, args...)  DPA_DBG(format, ##args)
#else
  #define OS_DBG(format, args...)
#endif

/* OS layer statistics */
typedef struct {
  uint32_t  malloc_cnt; /* Total allocations */
  uint32_t  free_cnt; /* Total frees */
} dpa_os_stats_t;


/* SPA state */
static struct {
  bool           init; /* true if OS initialized */
  dpa_os_stats_t stats; /* Statistics */
} dpa_os_state;


/* Memory block header */
typedef struct {
  unsigned long size;
  void *mem;
} mem_hdr_t;


int dpa_os_init(dpa_os_config_t *cfg) {
  (void) cfg;

  if (cfg == NULL) {
      return -1;
  }

  /* FIXME Replace to IRQ fiq_set_handler(dpa_os_isr); */

  if (!dpa_os_state.init) {
      dpa_os_state.init = true;
  }

  return 0;
}


void dpa_os_shutdown(void) {
  if (dpa_os_state.init) {
      /* FIXME Replace to IRQ fiq_set_handler(NULL); */

      dpa_os_state.init = false;
  }
}


int dpa_os_gettimeofday(dpa_timeval_t *tv, dpa_timezone_t *tz) {
  struct timeval tval;

  do_gettimeofday(&amp;tval);
  tv-&gt;tv_sec = tval.tv_sec;
  tv-&gt;tv_usec = tval.tv_usec;
  return 0;
}


void dpa_os_msleep(unsigned int msec) {
  msleep(msec);
}


void dpa_os_log(int level, const char* format,...) {
  va_list   argptr;
  int32_t   len;
  char      buf[512];

  va_start( argptr, format);
  len = 0;
  len += dpa_vsnprintf(buf+len,sizeof(buf)-len,format,argptr);
  va_end( argptr);

  switch (level) {
    case DPA_OS_LOG_EMERG:
      printk(KERN_EMERG "%s\n", buf);
     break;
    case DPA_OS_LOG_ALERT:
      printk(KERN_ALERT "%s\n", buf);
      break;
    case DPA_OS_LOG_CRIT:
      printk(KERN_CRIT "%s\n", buf);
      break;
    case DPA_OS_LOG_ERR:
      printk(KERN_ERR "%s\n", buf);
      break;
    case DPA_OS_LOG_WARNING:
      printk(KERN_WARNING "%s\n", buf);
      break;
    case DPA_OS_LOG_NOTICE:
      printk(KERN_NOTICE "%s\n", buf);
      break;
    case DPA_OS_LOG_INFO:
      printk(KERN_INFO "%s\n", buf);
      break;
    case DPA_OS_LOG_DEBUG:
    default:
      printk(KERN_DEBUG "%s\n", buf);
      break;
  }
}


void* dpa_os_lock_create(void)
{
  spinlock_t* l = dpa_os_malloc(sizeof(spinlock_t));

  if (!l) {
    return NULL;
  }
  spin_lock_init(l);
  return l;
}


void dpa_os_lock_delete(void* id)
{
  dpa_os_free(id);
}


void dpa_os_unlock(void* id)
{
  spin_unlock(id);
}


void dpa_os_lock(void* id)
{
  spin_lock(id);
}

uint32_t dpa_os_virt_to_phys(uint8_t* virt_addr, uint32_t size)
{
  return pci_map_single(NULL, virt_addr, size, PCI_DMA_TODEVICE);
}

uint32_t dpa_os_phys_to_virt(uint8_t* virt_addr, uint32_t size)
{
  return pci_map_single(NULL, virt_addr, size, PCI_DMA_FROMDEVICE);
}


void* dpa_os_malloc(size_t size) {
  mem_hdr_t *hdr;

  OS_DBG("dpa_os_malloc: Trying to alloc %d bytes", size);

#ifdef __DPA_MEM_PAGE_ALLOC__
  hdr = (mem_hdr_t *) __get_free_pages(GFP_KERNEL, get_order(size + sizeof(mem_hdr_t)));
#else
  hdr = (mem_hdr_t *) kmalloc(size + sizeof(mem_hdr_t), GFP_KERNEL);
#endif /* __DPA_MEM_PAGE_ALLOC__ */

  if (hdr == NULL) {
      OS_DBG("hdr == NULL");
      return NULL;
  }

  hdr-&gt;size = size;
  hdr-&gt;mem = ((uint8_t*)hdr) + sizeof(mem_hdr_t);

  ++dpa_os_state.stats.malloc_cnt;

  OS_DBG("dpa_os_malloc: hdr=0x%x, mem=0x%x, %d bytes",
         (uint32_t) hdr, (uint32_t) hdr-&gt;mem, size);

  return hdr-&gt;mem;
}


void dpa_os_free(void *ptr) {
  mem_hdr_t *hdr = (mem_hdr_t *) ((uint8_t*)ptr - sizeof(mem_hdr_t));

  OS_DBG("dpa_os_free: hdr=0x%x, mem=0x%x, %d bytes", (uint32_t) hdr, (uint32_t) hdr-&gt;mem, hdr-&gt;size);

  ++dpa_os_state.stats.free_cnt;

#ifdef __DPA_MEM_PAGE_ALLOC__
  free_pages((unsigned long)hdr, get_order(hdr-&gt;size + sizeof(mem_hdr_t)));
#else
  kfree((void*) hdr);
#endif /* __DPA_MEM_PAGE_ALLOC__ */
}


void* dpa_os_realloc(void* ptr, size_t size) {
  mem_hdr_t *hdr = (mem_hdr_t *) ((uint8_t*)ptr - sizeof(mem_hdr_t));
  void      *new_ptr;
  uint32_t   old_size = hdr-&gt;size;
  
  new_ptr = dpa_os_malloc(size);
  
  dpa_memcpy(new_ptr, ptr, old_size);

  dpa_os_free(ptr);
  
  OS_DBG("dpa_os_realloc: hdr=0x%x, mem=0x%x, old %d bytes, new %d bytes", (uint32_t) hdr, (uint32_t) hdr-&gt;mem, old_size, size);

  return new_ptr;
}



/* TODO Implement generically and move to string.c */
int dpa_vsnprintf(char *buf, size_t size, const char *fmt, va_list args) {
  return vsnprintf(buf,size,fmt,args);
}


int32_t dpa_os_irq_alloc(uint32_t irq, dpa_irq_handler_t handler, const char *name, void *dev) {
  int32_t err;
  if (request_irq(irq, (irq_handler_t) handler, (IRQF_DISABLED|IRQF_SAMPLE_RANDOM), name, dev)) {
      OS_ERROR("Cannot request irq %d \n", irq);
      err = DPA_IRQ_ALLOC_FAIL;
  } else {
      err = DPA_OK;
      OS_DBG("Allocated irq %d \n", irq);
  }
  
  return err;
}


int32_t dpa_os_irq_free(uint32_t irq, void *dev) {
  free_irq(irq, dev);

  return DPA_OK;
}


</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2013/06/03" Time="11:35:2000">
<Copy StartSeek="0" EndSeek="3919"/>
<Insert>void* dpa_os_malloc(size_t size) {
</Insert>
<Copy StartSeek="3959" EndSeek="3978"/>
<Insert>  OS_DBG("dpa_os_malloc: Trying to alloc %d bytes", size);

</Insert>
<Copy StartSeek="4081" EndSeek="6123"/>
</Delta>
<Delta Version="1" Comment="" NL="\10" Encoding="text" Date="2013/06/19" Time="11:55:25000">
<Copy StartSeek="0" EndSeek="4081"/>
<Insert>#ifdef __DPA_MEM_PAGE_ALLOC__
</Insert>
<Copy StartSeek="4081" EndSeek="4170"/>
<Insert>#else
  hdr = (mem_hdr_t *) kmalloc(size + sizeof(mem_hdr_t), GFP_KERNEL);
#endif /* __DPA_MEM_PAGE_ALLOC__ */

</Insert>
<Copy StartSeek="4170" EndSeek="5981"/>
</Delta>
<Delta Version="2" Comment="" NL="\10" Encoding="text" Date="2013/06/19" Time="11:55:44000">
<Copy StartSeek="0" EndSeek="4351"/>
<Insert>  OS_DBG("dpa_os_malloc: hdr=0x%x, mem=0x%x, %d bytes",
</Insert>
<Copy StartSeek="4412" EndSeek="5986"/>
</Delta>
<Delta Version="3" Comment="" NL="\10" Encoding="text" Date="2013/06/19" Time="11:56:25000">
<Copy StartSeek="0" EndSeek="3918"/>
<Insert>
</Insert>
<Copy StartSeek="4576" EndSeek="6643"/>
</Delta>
<Delta Version="4" Comment="" NL="\10" Encoding="text" Date="2013/06/19" Time="11:56:58000">
<Copy StartSeek="0" EndSeek="3918"/>
<Insert>void* dpa_os_malloc(size_t size) {
</Insert>
<Copy StartSeek="3955" EndSeek="4034"/>
<Insert>#ifdef __DPA_MEM_PAGE_ALLOC__
  hdr = (mem_hdr_t *) __get_free_pages(GFP_KERNEL, get_order(size + sizeof(mem_hdr_t)));
#else
</Insert>
<Copy StartSeek="4034" EndSeek="4103"/>
<Insert>#endif /* __DPA_MEM_PAGE_ALLOC__ */

</Insert>
<Copy StartSeek="4103" EndSeek="6483"/>
</Delta>
<Delta Version="5" Comment="" NL="\10" Encoding="text" Date="2013/06/19" Time="11:57:11000">
<Copy StartSeek="0" EndSeek="3918"/>
<Insert>void* __dpa_os_malloc(size_t size) {
</Insert>
<Copy StartSeek="3953" EndSeek="6481"/>
</Delta>
<Delta Version="6" Comment="" NL="\10" Encoding="text" Date="2013/06/19" Time="11:57:39000">
<Copy StartSeek="0" EndSeek="3918"/>
<Insert>void* dpa_os_malloc(size_t size) {
</Insert>
<Copy StartSeek="3955" EndSeek="6483"/>
</Delta>
<Delta Version="7" Comment="" NL="\10" Encoding="text" Date="2013/06/19" Time="11:59:4000">
<Copy StartSeek="0" EndSeek="3918"/>
<Insert>void* __dpa_os_malloc(size_t size) {
</Insert>
<Copy StartSeek="3954" EndSeek="4033"/>
<Copy StartSeek="4158" EndSeek="4227"/>
<Copy StartSeek="4264" EndSeek="4577"/>
<Insert>void* dpa_os_alloc_pages(size_t size) {
  mem_hdr_t *hdr;

  OS_DBG("dpa_os_alloc_pages: Trying to alloc of order %d ", 
	 get_order(size + sizeof(mem_hdr_t)));

  hdr = (mem_hdr_t *) __get_free_pages(GFP_KERNEL, get_order(size + sizeof(mem_hdr_t)));
  if (hdr == NULL) {
      OS_DBG("hdr == NULL");
      return NULL;
  }

  hdr-&gt;size = size;
  hdr-&gt;mem = ((uint8_t*)hdr) + sizeof(mem_hdr_t);

  ++dpa_os_state.stats.malloc_cnt;

  OS_DBG("dpa_os_alloc_pages: hdr=0x%x, mem=0x%x, %d bytes",
         (uint32_t) hdr, (uint32_t) hdr-&gt;mem, size);

  return hdr-&gt;mem;
}


</Insert>
<Copy StartSeek="4578" EndSeek="6075"/>
</Delta>
</DeltaFile>
