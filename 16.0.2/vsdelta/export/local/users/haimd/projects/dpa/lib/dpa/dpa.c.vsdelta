<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="22" Comment="" Date="2013/06/24" Time="18:32:37000" NL="\10" Encoding="text">
<Insert>/************************************************************************
* Copyright (C) 2012, Marvell Technology Group Ltd.
* All Rights Reserved.
*
* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
* the contents of this file may not be disclosed to third parties, copied
* or duplicated in any form, in whole or in part, without the prior
* written permission of Marvell Technology Group.
*
* dpa_api.c
*
* Description:
*       Marvell Data Path Acceleration Engine API
*
*/

#include &lt;dpa.h&gt;
#include &lt;dpa/dpa.h&gt;
#include &lt;dpa_types.h&gt;
#include &lt;dpa_os.h&gt;
#include &lt;eth/eth.h&gt;
#include &lt;log/log.h&gt;
#include &lt;spa/spa.h&gt;
#include &lt;util/string.h&gt;
#include &lt;util/queue.h&gt;
#include &lt;util/mem.h&gt;
#include &lt;util/timer.h&gt;
#include &lt;util/cache_ops.h&gt;

#include "version.h"
#include "dpa_frwd.h"
#include "dpa_policer.h"

#include &lt;perf_cnt.h&gt;

#include &lt;eth/eth_regs.h&gt;

#define DPA_IS_INITIALIZED_OR_RETURN_ERROR \
  do { if (!dpa_is_init()) { \
      return DPA_NOT_INIT; } \
  } while (0)

#ifdef __DPA_CHECK_MARVELL_CPU__
#define DPA_ERROR_IF_NOT_MARVELL_CPU() \
do { \
  uint32_t reg_val = 0;                                           \
   __asm volatile ("mrc p15, 0, %0, c0, c0, 0" : "=r" (reg_val)); \
   reg_val &gt;&gt;= 24; \
   if (reg_val != 0x56 &amp;&amp; reg_val != 0x41) {\
       return -1; \
   }\
} while (0)
#else
#define DPA_ERROR_IF_NOT_MARVELL_CPU()
#endif

/* Time interval, microseconds, of HW timer */
#define DPA_TIMER_DURATION_USEC (100)

/* HW timer number */
#define DPA_TIMER_ID            (2)

/* Prototypes */
void dpa_pkt_rx(eth_pkt_t* pkt);
void dpa_rx_done(uint8_t port);
void dpa_tx_done(uint8_t port, uint32_t sent);
static inline eth_pkt_t *dpa_get_pkt_tx(uint32_t priority);
int printk(const char * fmt, ...);

/* Platform-specific routines */
extern eth_pkt_t *__dpa_pkt_alloc(uint32_t size);
extern eth_pkt_t *__dpa_pkt_wrap(void *data, uint32_t size, void *os_handle);
extern void __dpa_pkt_free(eth_pkt_t* pkt);

/* DPA API state */

typedef enum {
  DPA_STATUS_SHUTDOWN,
  DPA_STATUS_INIT_IN_PROGRESS,
  DPA_STATUS_INIT,
  DPA_STATUS_SHUTDOWN_IN_PROGRESS
} dpa_status_t;


typedef struct
{
  dpa_os_config_t os;
  eth_config_t    eth[DPA_ETH_MAX_PORT_NUM];
}
dpa_config_t;


typedef struct {
  dpa_status_t     status; /* Initialization state */
  dpa_config_t     config; /* Platform configuration */
  queue_t         *spa_txq[DPA_PKT_PRI_NUM]; /* Outgoing queues */
  queue_t         *spa_txq_done; /* Temp Tx Q for slow path packets */
  eth_ops_t        eth_ops; /* Ethernet operations */
  dpa_pkt_stats_t  pkt_stats; /* Packet buffer stats */

#ifdef __DPA_MEM_LOG__
  dpa_pkt_alloc_stats_t pkt_alloc_stats; /* Memory stats */
#endif /* __DPA_MEM_LOG__ */
} dpa_state_t;

static dpa_state_t dpa_state =
  {.status = DPA_STATUS_SHUTDOWN,
   .spa_txq = {NULL},
   .spa_txq_done = NULL,
   .eth_ops = {.pkt_alloc = dpa_pkt_alloc,
               .pkt_free = dpa_pkt_free,
               .pkt_rx = dpa_pkt_rx,
               .rx_done = dpa_rx_done,
               .tx_done = dpa_tx_done}};



/******************************************************
 *   DPA utility routines
 */

/* Terminate Ethernet layer */
int32_t dpa_eth_shutdown(void) {
  uint32_t i, err;
  eth_config_t *cfg;

  err = DPA_OK;

  for (i = 0; i &lt; DPA_ETH_MAX_PORT_NUM; i++) {
       cfg = &amp;dpa_state.config.eth[i];
       if (cfg-&gt;status) {
           eth_shutdown(cfg-&gt;port);
       }
  }

  return err;
}


/* Transmit slow path packets. Handle highest priority packets first */
void dpa_slow_path_tx(void) {
  eth_pkt_t* pkt;
  int32_t pri;

  for (pri = DPA_PKT_PRI_MAX; pri &gt;= DPA_PKT_PRI_MIN; pri--) {
       while ((pkt = dpa_get_pkt_tx(pri)) != NULL) {

          pkt-&gt;queue = 0; /* TODO dpa_qos2queue(pkt); */
          pkt-&gt;hw_cmd = NETA_TX_FLZ_DESC_MASK | NETA_TX_L4_CSUM_NOT;
          eth_pkt_tx(pkt);
          queue_put(dpa_state.spa_txq_done, pkt);

          dpa_state.pkt_stats.lcl_tx_pkts++;
       }
  }
}


/* Init slow path interface */
int32_t dpa_slow_path_init(void) {
  uint32_t i;
  int32_t err;

  /* Temp queue for transmited packets from slow path */
  dpa_state.spa_txq_done = queue_create(SPA_TX_QUEUE_SIZE);
  if (dpa_state.spa_txq_done == NULL) {
      DPA_ERROR("Can't alloc temp Tx done queue of size (%d)", SPA_TX_QUEUE_SIZE);
      err = DPA_OUT_OF_MEMORY;
      goto fail;
  }

  /* Slow path Tx queues */
  for (i = 0; i &lt; DPA_PKT_PRI_NUM; i++) {
       dpa_state.spa_txq[i] = queue_create(SPA_TX_QUEUE_SIZE);
       if (dpa_state.spa_txq[i] == NULL) {
           DPA_ERROR("Can't alloc Tx queue (%d) of size (%d)", i, SPA_TX_QUEUE_SIZE);
           err = DPA_OUT_OF_MEMORY;
           goto fail;
       }
  }

  /* Slow path adapter */
  if ((err = spa_init())) {
      goto fail;
  }

  return DPA_OK;

fail:
  return err;
}

/* Terminate slow path interface */
void dpa_slow_path_shutdown() {
  eth_pkt_t *pkt;
  uint32_t   i;

  /* Slow path adapter */
  spa_shutdown();

  /* Tx queues */
  for (i = 0; i &lt; DPA_PKT_PRI_NUM; i++) {
       if (dpa_state.spa_txq[i] != NULL) {
           while ((pkt = queue_get(dpa_state.spa_txq[i])) != NULL) {
              dpa_pkt_free(pkt);
           }
           queue_destroy(dpa_state.spa_txq[i]);
           dpa_state.spa_txq[i] = NULL;
       }
  }

  /* Tx done queue */
  if (dpa_state.spa_txq_done != NULL) {
      while ((pkt = queue_get(dpa_state.spa_txq_done)) != NULL) {
              dpa_pkt_free(pkt);
      }
      queue_destroy(dpa_state.spa_txq_done);
      dpa_state.spa_txq_done = NULL;
  }
}


eth_pkt_t *dpa_pkt_alloc(uint32_t size) {
  eth_pkt_t *pkt = __dpa_pkt_alloc(size);

#ifdef __DPA_MEM_LOG__
  if (pkt != NULL) {
      dpa_state.pkt_alloc_stats.alloc_pkts++;
      dpa_state.pkt_alloc_stats.fast_path_alloc_pkts++;
  }
#endif /* __DPA_MEM_LOG__ */
  return pkt;
}


eth_pkt_t *dpa_pkt_wrap(void *data, uint32_t size, void *os_handle) {
  eth_pkt_t *pkt = __dpa_pkt_wrap(data, size, os_handle);

#ifdef __DPA_MEM_LOG__
  if (pkt != NULL) {
      dpa_state.pkt_alloc_stats.alloc_pkts++;
      dpa_state.pkt_alloc_stats.slow_path_alloc_pkts++;
  }
#endif /* __DPA_MEM_LOG__ */

  return pkt;
}


void dpa_pkt_free(eth_pkt_t* pkt) {
#ifdef __DPA_MEM_LOG__
  dpa_state.pkt_alloc_stats.free_pkts++;
  if (ETH_IS_PKT_FAST_PATH(pkt)) {
      dpa_state.pkt_alloc_stats.fast_path_free_pkts++;
  } else {
      dpa_state.pkt_alloc_stats.slow_path_free_pkts++;
  }
#endif /* __DPA_MEM_LOG__ */

  __dpa_pkt_free(pkt);
}


#ifdef __DPA_MEM_LOG__
void dpa_print_pkt_alloc_stats(void) {
  DPA_INFO("Packet buffer memory statistics (total/fast path/slow path):"
           " allocated  (%d/%d/%d), freed (%d/%d/%d)",
           dpa_state.pkt_alloc_stats.alloc_pkts,
           dpa_state.pkt_alloc_stats.fast_path_alloc_pkts,
           dpa_state.pkt_alloc_stats.slow_path_alloc_pkts,
           dpa_state.pkt_alloc_stats.free_pkts,
           dpa_state.pkt_alloc_stats.fast_path_free_pkts,
           dpa_state.pkt_alloc_stats.slow_path_free_pkts);
}
#endif /* __DPA_MEM_LOG__ */



/******************************************************
 *   DPA processing routines
 */

/* End of Rx batch */
void dpa_rx_done(uint8_t port) {

  /* Forward pkts to slow path */
  spa_rx_done(port);

  /* Transmit pkts from slow path */
  dpa_slow_path_tx();
}

/* Called by Ethernet driver when xmit done */
void dpa_tx_done(uint8_t port, uint32_t sent) {
  register eth_pkt_t* pkt;

  /* Return packet to slow path for freeing */
  while ((pkt = queue_get(dpa_state.spa_txq_done)) != NULL) {
    /* FIXME Not handling the case when SPA xmit done Q is full!
       And we can't free it in data path context. Should add an extra temp Q for this */
    spa_pkt_tx_done(pkt);
  }
}

/* Get next packet to transmit from slow path */
static inline eth_pkt_t *dpa_get_pkt_tx(uint32_t priority) {
  return (eth_pkt_t *) queue_get(dpa_state.spa_txq[priority]);
}



#if defined (__DPA_MODE_DPA__)

/* Full DPA flow */
void dpa_pkt_rx(eth_pkt_t* pkt) {
  /* Classify and modify */
  switch (dpa_frwd_rx(pkt)) {
        case DPF_FWD:
          pkt-&gt;hw_cmd |= NETA_TX_FLZ_DESC_MASK;
          pkt-&gt;status = ETH_PKT_STATUS_FWD;
          dpa_state.pkt_stats.fwd_pkts++;
          break;

        case DPF_LCL:
          if (!spa_rx_queue_is_full(pkt-&gt;prio)) {
              pkt-&gt;status = ETH_PKT_STATUS_LCL;
              dpa_state.pkt_stats.lcl_rx_pkts++;
              spa_pkt_rx(pkt, pkt-&gt;prio);
              break;
          }

        default: /* Drop */
          pkt-&gt;status = ETH_PKT_STATUS_DROP;
          dpa_state.pkt_stats.dropped_pkts++;
  }
}


#elif defined (__DPA_MODE_SLOW_PATH__)

/* All goes to slow path */
void dpa_pkt_rx(eth_pkt_t* pkt) {
  if (spa_rx_queue_is_full(DPA_PKT_PRI_MIN)) {
      pkt-&gt;status = ETH_PKT_STATUS_DROP;
      dpa_state.pkt_stats.dropped_pkts++;
  } else {
      pkt-&gt;status = ETH_PKT_STATUS_LCL;
      dpa_state.pkt_stats.lcl_rx_pkts++;
      spa_pkt_rx(pkt, DPA_PKT_PRI_MIN);
  }
}

#elif defined (__DPA_MODE_FWD__)

/* All packets sent to alternate port unmodified */
void dpa_pkt_rx(eth_pkt_t* pkt) {
  /* Base performance test: Just flip the ports */
  pkt-&gt;port ^= 0x1;
  pkt-&gt;queue = 0;
  pkt-&gt;hw_cmd = NETA_TX_FLZ_DESC_MASK | NETA_TX_L4_CSUM_NOT;
  pkt-&gt;status = ETH_PKT_STATUS_FWD;
  dpa_state.pkt_stats.fwd_pkts++;
}

#else
  #error "Please define DPA mode"
#endif


/******************************************************
 *   DPA Internal API implementation
 */

/* Append slow path packet to transmit queue. Caller must also wake-up
   the fast path thread via dpa_tx_start */
int32_t dpa_pkt_tx(eth_pkt_t *pkt, uint32_t priority) {
  if (!dpa_tx_queue_ready(priority)) {
      return DPA_QUEUE_IS_FULL;
  }

  queue_put(dpa_state.spa_txq[priority], (void*) pkt);

  return DPA_OK;
}

/* Fire-up fast path context timer if pending pkts */
int32_t dpa_tx_start(void) {
  /* FIXME Make sure packets get to DPA transmit ! */

  return DPA_OK;
}

bool dpa_tx_queue_ready(uint32_t priority) {
  return (dpa_is_init() &amp;&amp; !queue_is_full(dpa_state.spa_txq[priority]));
}


/* Redeem packet buffer to ethernet pool */
int32_t dpa_pkt_reclaim(eth_pkt_t *pkt) {
  eth_pkt_t *new_pkt;

  if (!dpa_is_init() /* TODO May remove this check since checking in eth_pkt_pool_is_full */
      || eth_pkt_pool_is_full(pkt-&gt;pool_id)) {
      return DPA_OK;
  }

  /* Original pkt preserved since it will be handled in slow path */
  new_pkt = dpa_pkt_alloc(pkt-&gt;alloc_size);
  if (new_pkt == NULL) {
      DPA_ERROR("Can't alloc pkt for eth port (%d)", pkt-&gt;pool_id);
      return DPA_OUT_OF_MEMORY;
  }

  new_pkt-&gt;pool_id = pkt-&gt;pool_id;
  eth_pkt_put(new_pkt);

  return DPA_OK;
}


/******************************************************
 *   DPA Public API implementation
 */

const char* dpa_get_version(void)
{
  static char buf[256] = {0};
#ifdef __DPA_RUNTIME_DEBUG__
  const char* debug="DEBUG";
#else
  const char* debug="";
#endif

  dpa_snprintf(buf,sizeof(buf), "Version: %u.%02u.%02u Date: %s %s %s",
               dpa_version_major,
               dpa_version_minor,
               dpa_version_revision,
               dpa_version_build_date,
               dpa_version_build_time,
               debug);
  return buf;
}


int32_t dpa_port_stat(uint8_t port) {
	eth_config_t *cfg;
	int32_t err;

	DPA_IS_INITIALIZED_OR_RETURN_ERROR;

	if (!ETH_PORT_VALID(port)) {
		DPA_ERROR("Add port failed, invalid port (%d).", port);
		err = DPA_INVALID_PARAM;
		goto fail;
	}

	cfg = &amp;dpa_state.config.eth[port];
	return cfg-&gt;status;

	fail:
		return err;
}


int32_t dpa_port_add(uint8_t port) {
  eth_config_t *cfg;
  int32_t err;

  DPA_IS_INITIALIZED_OR_RETURN_ERROR;

  if (!ETH_PORT_VALID(port)) {
      DPA_ERROR("Add port failed, invalid port (%d).", port);
      err = DPA_INVALID_PARAM;
      goto fail;
  }

  cfg = &amp;dpa_state.config.eth[port];
  if (cfg-&gt;status) {
      DPA_ERROR("Add port failed, port (%d) already active.", port);
      return DPA_PORT_ACTIVE;
  }

  cfg-&gt;port = port;
  cfg-&gt;rxq_num = 8; /* FIXME Take from .config */
  cfg-&gt;txq_num = 8; /* FIXME Take from .config */
  cfg-&gt;mtu = ETH_DEF_MTU; /* FIXME Take from .config */
  cfg-&gt;rx_desc_num = 128;
  cfg-&gt;tx_desc_num = 2 * cfg-&gt;rx_desc_num;
  cfg-&gt;pkt_pool_size = cfg-&gt;rxq_num * (100 /* spare */ +  cfg-&gt;rx_desc_num);
  cfg-&gt;status = true;
  cfg-&gt;ops = dpa_state.eth_ops;

  /* Hijack slow path netdev */
  err = spa_port_install(cfg-&gt;port);
  if (err != DPA_OK) {
        DPA_ERROR("Can't hijack slow path port (%d)", cfg-&gt;port);
        goto fail;
  }

  /* Init bare metal eth driver */
  err = eth_init(cfg);
  if (err != DPA_OK) {
        DPA_ERROR("Can't init bare metal driver for port (%d)", cfg-&gt;port);
        goto fail;
  }

  /* Unmask ethernet interrupts */
  eth_irq_enable(cfg-&gt;port);

  return DPA_OK;

fail:
  return err;
}


int32_t dpa_port_del(uint8_t port) {
  eth_config_t *cfg;

  DPA_IS_INITIALIZED_OR_RETURN_ERROR;

  if (!ETH_PORT_VALID(port)) {
      DPA_ERROR("Removing port failed, invalid port %d", port);
      return DPA_INVALID_PARAM;
  }

  cfg = &amp;dpa_state.config.eth[port];
  if (!cfg-&gt;status) {
      DPA_ERROR("Removing port failed, port inactive %d", port);
      return DPA_PORT_INACTIVE;
  }

  /* Mask ethernet interrupts */
  eth_irq_disable(port);

  /* Uninit bare metal driver */
  eth_shutdown(port);

  /* Restore slow path netdev */
  spa_port_uninstall(port);

  cfg-&gt;status = false;

  return DPA_OK;
}



int32_t dpa_config_init(dpa_config_t *config) {

  return DPA_OK;
}

int dpa_timer_init(void)
{
        int err;
        timer_params_t timer = {
                .handler = dpa_policer_timer_cb,
                .period_ns = 1000000000 / DPA_CLK_PER_SEC,
        };

        err = timer_create(&amp;timer);
        if (err != DPA_OK) {
                return err;
        }
        timer_start();

        return DPA_OK;
}

int dpa_timer_shutdown()
{
        timer_stop();
        return timer_destroy();
}

int32_t dpa_init(void) {
  int32_t err;

  DPA_ERROR_IF_NOT_MARVELL_CPU();

  DPA_INFO("DPA initialization started");

  /* Already initialized */
  if (dpa_is_init()) {
      DPA_INFO("DPA already initialized.");
      return DPA_OK;
  }

  dpa_state.status = DPA_STATUS_INIT_IN_PROGRESS;

  /* Configuration */
  if ((err = dpa_config_init(&amp;dpa_state.config))) {
      goto fail;
  }

  /* OS primitives */
  if ((err = dpa_os_init(&amp;dpa_state.config.os))) {
      goto fail;
  }

  /* Slow path interface */
  if ((err = dpa_slow_path_init())) {
      goto fail;
  }

  /* Classifier */
  if ((err = dpa_frwd_init())) {
      goto fail;
  }

  if ((err = dpa_timer_init())) {
      goto fail;
  }
  /* Statistics */
  dpa_stats_reset();

  dpa_state.status = DPA_STATUS_INIT;

  DPA_INFO("DPA initialized successfully");

  return DPA_OK;

fail:
  DPA_ERROR("DPA initialized failed");

  dpa_shutdown();

  return err;
}


bool dpa_is_init(void) {
  return (dpa_state.status == DPA_STATUS_INIT);
}


int32_t dpa_shutdown(void) {

  /* Mask ethernet interrupts */
  eth_irq_disable_all();

  dpa_timer_shutdown();
  dpa_state.status = DPA_STATUS_SHUTDOWN_IN_PROGRESS;

  /* Classifier */
  dpa_frwd_exit();

  /* Ethernet driver */
  dpa_eth_shutdown();

  /* Slow path interface */
  dpa_slow_path_shutdown();

  /* OS primitives */
  dpa_os_shutdown();

  dpa_state.status = DPA_STATUS_SHUTDOWN;

#ifdef __DPA_MEM_LOG__
  dpa_print_pkt_alloc_stats();
  dpa_mem_print_stats();
#endif /* __DPA_MEM_LOG__ */

  return DPA_OK;
}


int32_t dpa_stats_get(dpa_stats_t *stats) {
  uint32_t i;
  DPA_IS_INITIALIZED_OR_RETURN_ERROR;

  if (stats == NULL) {
      return DPA_INVALID_PARAM;
  }

  dpa_memset(stats, 0, sizeof(*stats));
  dpa_memcpy(&amp;stats-&gt;pkt, &amp;dpa_state.pkt_stats, sizeof(stats-&gt;pkt));
#ifdef __DPA_MEM_LOG__
  dpa_memcpy(&amp;stats-&gt;pkt_alloc, &amp;dpa_state.pkt_alloc_stats, sizeof(stats-&gt;pkt_alloc));
#endif
  for (i = 0; i &lt; DPA_ETH_MAX_PORT_NUM; i++) {
       eth_config_t *cfg = &amp;dpa_state.config.eth[i];
       if (cfg-&gt;status) {
           eth_stats_get(cfg-&gt;port, &amp;stats-&gt;eth[cfg-&gt;port]);
       }
  }

  return DPA_OK;
}


int32_t dpa_stats_reset(void) {
  int port;

  dpa_memset(&amp;dpa_state.pkt_stats, 0, sizeof(dpa_state.pkt_stats));
#ifdef __DPA_MEM_LOG__
  dpa_memset(&amp;dpa_state.pkt_alloc_stats, 0, sizeof(dpa_state.pkt_alloc_stats));
#endif /* __DPA_MEM_LOG__ */
  for (port = 0; port &lt; DPA_ETH_MAX_PORT_NUM; port++) {
       eth_stats_reset(port);
  }

  PERF_COUNTER_RESET(0);
  PERF_COUNTER_START(0, C0_RETIRED_INSTRUCTION /*C0_ICACHE_READ_LATENCY*/ /*PERF_COUNTER_TYPE_CYCLE_COUNT*/);

  return DPA_OK;
}



int32_t dpa_table_flush(void) {
  DPA_IS_INITIALIZED_OR_RETURN_ERROR;

  dpa_frwd_clean_all();

  return DPA_OK;
}



</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="17:55:32000">
<Copy StartSeek="0" EndSeek="13426"/>
<Insert>
</Insert>
<Copy StartSeek="13598" EndSeek="14242"/>
<Copy StartSeek="14400" EndSeek="16424"/>
</Delta>
<Delta Version="1" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:16:44000">
<Copy StartSeek="0" EndSeek="13531"/>
<Insert>                .period_ns = DPA_CLK_PER_SEC

                ;
}

</Insert>
<Copy StartSeek="13602" EndSeek="16428"/>
</Delta>
<Delta Version="2" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:17:43000">
<Copy StartSeek="0" EndSeek="13531"/>
<Insert>                .period_ns = 1000000000/DPA_CLK_PER_SEC;
</Insert>
<Copy StartSeek="13590" EndSeek="16430"/>
</Delta>
<Delta Version="3" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:17:46000">
<Copy StartSeek="0" EndSeek="13601"/>
<Insert>}

</Insert>
<Copy StartSeek="13635" EndSeek="16461"/>
</Delta>
<Delta Version="4" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:19:36000">
<Copy StartSeek="0" EndSeek="13426"/>
<Insert>dpa_timer_init(void)
</Insert>
<Copy StartSeek="13451" EndSeek="13453"/>
<Copy StartSeek="13470" EndSeek="13623"/>
<Insert>        timer_create(&amp;timer);
}

</Insert>
<Copy StartSeek="13758" EndSeek="16584"/>
</Delta>
<Delta Version="5" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:21:8000">
<Copy StartSeek="0" EndSeek="13726"/>
<Insert>        timer_start(&amp;timer);
</Insert>
<Copy StartSeek="13749" EndSeek="16578"/>
</Delta>
<Delta Version="6" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:21:26000">
<Copy StartSeek="0" EndSeek="13749"/>
<Insert>}

</Insert>
<Copy StartSeek="13775" EndSeek="16601"/>
</Delta>
<Delta Version="7" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:22:20000">
<Copy StartSeek="0" EndSeek="13749"/>
<Copy StartSeek="13750" EndSeek="16602"/>
</Delta>
<Delta Version="8" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:22:22000">
<Copy StartSeek="0" EndSeek="14970"/>
<Copy StartSeek="14994" EndSeek="16626"/>
</Delta>
<Delta Version="9" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:23:9000">
<Copy StartSeek="0" EndSeek="13775"/>
<Insert>
</Insert>
<Copy StartSeek="13830" EndSeek="16680"/>
</Delta>
<Delta Version="10" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:23:58000">
<Copy StartSeek="0" EndSeek="13803"/>
<Insert>        timer_destroy();
}
</Insert>
<Copy StartSeek="13859" EndSeek="16709"/>
</Delta>
<Delta Version="11" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:24:22000">
<Copy StartSeek="0" EndSeek="13775"/>
<Insert>void dpa_timer_shutdown()
</Insert>
<Copy StartSeek="13800" EndSeek="13858"/>
<Copy StartSeek="13859" EndSeek="16709"/>
</Delta>
<Delta Version="12" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:24:28000">
<Copy StartSeek="0" EndSeek="13775"/>
<Copy StartSeek="13776" EndSeek="16710"/>
</Delta>
<Delta Version="13" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:24:30000">
<Copy StartSeek="0" EndSeek="586"/>
<Copy StartSeek="615" EndSeek="16739"/>
</Delta>
<Delta Version="14" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:27:3000">
<Copy StartSeek="0" EndSeek="586"/>
<Insert>#include &lt;dpa/dpa_policer.h&gt;
</Insert>
<Copy StartSeek="586" EndSeek="816"/>
<Insert>
</Insert>
<Copy StartSeek="842" EndSeek="16735"/>
</Delta>
<Delta Version="15" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:30:32000">
<Copy StartSeek="0" EndSeek="13528"/>
<Insert>                .handler = dpa_policer_timer_cb;
</Insert>
<Copy StartSeek="13577" EndSeek="16735"/>
</Delta>
<Delta Version="16" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:30:48000">
<Copy StartSeek="0" EndSeek="13577"/>
<Insert>                .period_ns = 1000000000 / DPA_CLK_PER_SEC;
</Insert>
<Copy StartSeek="13636" EndSeek="16735"/>
</Delta>
<Delta Version="17" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:30:51000">
<Copy StartSeek="0" EndSeek="14529"/>
<Insert>  int32_t timer_create(timer_params_t *params);
int32_t timer_destroy(void);
void timer_start(void);
void timer_stop(void);
</Insert>
<Copy StartSeek="14529" EndSeek="14559"/>
<Insert>  }
</Insert>
<Copy StartSeek="14584" EndSeek="16632"/>
</Delta>
<Delta Version="18" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:31:15000">
<Copy StartSeek="0" EndSeek="14559"/>
<Insert>          goto fail;
</Insert>
<Copy StartSeek="14576" EndSeek="16628"/>
</Delta>
<Delta Version="19" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:31:21000">
<Copy StartSeek="0" EndSeek="14529"/>
<Insert>  if (err = timer_create()) {
</Insert>
<Copy StartSeek="14563" EndSeek="16632"/>
</Delta>
<Delta Version="20" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:32:3000">
<Copy StartSeek="0" EndSeek="14529"/>
<Insert>  if (err = dpa_timer_create()) {
</Insert>
<Copy StartSeek="14561" EndSeek="16630"/>
</Delta>
<Delta Version="21" Comment="" NL="\10" Encoding="text" Date="2013/06/24" Time="18:32:6000">
<Copy StartSeek="0" EndSeek="14529"/>
<Insert>  if (err = dpa_timer_init()) {
</Insert>
<Copy StartSeek="14563" EndSeek="16632"/>
</Delta>
</DeltaFile>
