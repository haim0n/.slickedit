<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="9" Comment="" Date="2013/07/17" Time="17:56:2000" NL="\10" Encoding="text">
<Insert>/************************************************************************
* Copyright (C) 2012, Marvell Technology Group Ltd.
* All Rights Reserved.
*
* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
* the contents of this file may not be disclosed to third parties, copied
* or duplicated in any form, in whole or in part, without the prior
* written permission of Marvell Technology Group.
*
* zte_api_fast.c
*
* DESCRIPTION:
*   ZTE API Fast implementation.
*
*******************************************************************************/

#include &lt;adp.h&gt;
#include &lt;adp_log.h&gt;
#include &lt;eth/eth.h&gt;
#include &lt;util/string.h&gt;
#include &lt;util/byte_order.h&gt;
#include &lt;util/timer.h&gt;
#include &lt;zte/zte_api_fast.h&gt;

#include "frwd.h"
#include "mdf.h"
#include "policer.h"


#define ZTE_API_FAST_DEBUG

#define ZTE_API_FAST_ERROR(format, args...) ADP_ERROR(format, ##args)

#ifdef ZTE_API_FAST_DEBUG
  #define ZTE_API_FAST_DBG(format, args...)  ADP_ERROR(format"\n", ##args)
#else
  #define ZTE_API_FAST_DBG(format, args...)
#endif


#define ZTE_API_LOCK_OR_RETURN     \
do {                               \
  if (zte_api_lock == NULL)        \
        return ZTE_INTERNAL_ERROR; \
  adp_os_lock(zte_api_lock);       \
} while (0)

#define ZTE_API_UNLOCK         \
do {                           \
  adp_os_unlock(zte_api_lock); \
} while (0)

/*******************************************************************************
 * Globals
 */

/* API protection spinlock */
static void *zte_api_lock;

/* QoS queue configuration */
static ZTE_L3_HARDFAST_QOS_QUEUE_CFG zte_qos_queue_cfg[ZTE_QOS_QUEUE_NUM];

/* QoS queue priority configuration */
static ZTE_L3_HARDFAST_QOS_QUEUE_PRIORITY_CFG zte_qos_queue_pri_cfg[ZTE_QOS_QUEUE_NUM];

/* Egress policer configuration */
static ZTE_L3_HARDFAST_EGRESS_POLICER_CFG zte_egress_policer_cfg;

/* Ingress rate limit configuration */
static ZTE_L3_HARDFAST_RCQUEUE_CFG zte_flow_policers[ZTE_INGRESS_FLOW_POLICER_NUM];

/* Ingress policer configuration */
static ZTE_L3_HARDFAST_INGRESS_POLICER_CFG zte_port_policers[ZTE_LAN_PORT_NUM];

/* Snapshot of session  tables */
static ZTE_L3_HARDFAST_SESSION *adp_flow_tbl_snapshot;
static int adp_flow_tbl_snapshot_size = 0;

/*******************************************************************************
* Internal utility routines
*/

static inline void pri_key_init(ZTE_L3_HARDFAST_TUPLE *zte_tuple,
    struct adp_pri_key *key)
{
  key-&gt;sip = zte_tuple-&gt;sip.ip;
  key-&gt;dip = zte_tuple-&gt;dip.ip;
  key-&gt;protocol = zte_tuple-&gt;protocol;
  key-&gt;sport = zte_tuple-&gt;sport;
  key-&gt;dport = zte_tuple-&gt;dport;
}


static inline int zte_api_fast_l3_addr_cmp(ZTE_NETFF_IP *addr1, ZTE_NETFF_IP *addr2)
{
  /* FIXME Support IPv4 &amp; IPv6 generically */
  return (addr1-&gt;ip - addr2-&gt;ip);
}


static inline int zte_api_fast_l3_session_validate(ZTE_L3_HARDFAST_SESSION *session)
{
  return 0;
}

/*******************************************************************************
* Public ZTE Fast API
*/

const char* zte_api_fast_l3_get_version(void)
{
  return adp_get_version();
}


int __zte_api_fast_l3_init_lib(void) {
  if (zte_api_lock != NULL) {
      ZTE_API_FAST_ERROR("API lock already intitialized");
      return ZTE_INTERNAL_ERROR;
  }

  zte_api_lock = adp_os_lock_create();
  if (zte_api_lock == NULL) {
      ZTE_API_FAST_ERROR("Can't create API lock");
      return ZTE_OUT_OF_MEMORY;
  }

  return ZTE_OK;
}

int __zte_api_fast_l3_shutdown_lib(void) {
  if (zte_api_lock == NULL) {
      ZTE_API_FAST_ERROR("Can't destroy NULL API lock");
      return ZTE_INTERNAL_ERROR;
  }

  adp_os_lock_delete(zte_api_lock);
  zte_api_lock = NULL;

  return ZTE_OK;
}


void zte_api_fast_l3_init_policers(void)
{
        int i;
        for (i = 0; i &lt; ZTE_INGRESS_FLOW_POLICER_NUM; i++) {
                zte_flow_policers[i].rate_limit = 0;
                zte_flow_policers[i].rcqueue = 0xFE;
        }

        for (i = 0; i &lt; ZTE_LAN_PORT_NUM; i++) {
                zte_port_policers[i].id = 0xFFFF;
                zte_port_policers[i].port = 0xFF;
        }
}

int zte_api_fast_l3_init(ZTE_L3_HARDFAST_INIT_CFG *cfg)
{
  int err, i;

  ZTE_API_LOCK_OR_RETURN;

  /* Core engine */
  err = adp_init();

  /* Setting the defaults, however, not enabling until explicit app request
     to do so. */
  if (err == ZTE_OK) {
       /* Qos queue */
       for (i = 0; i &lt; ZTE_QOS_QUEUE_NUM; i++) {
            /* Basic */
            zte_qos_queue_cfg[i].qos_queue = ETH_MAX_RXQ_NUM;
            zte_qos_queue_cfg[i].length = ZTE_QOS_QUEUE_LEN_DEF;
            zte_qos_queue_cfg[i].queue = ZTE_QOS_QUEUE_HW_QUEUE_DEF;

            /* Priority mode */
            zte_qos_queue_pri_cfg[i].qos_queue = i;
            zte_qos_queue_pri_cfg[i].mode = ZTE_PRIORITY_MODE_DEF;
            zte_qos_queue_pri_cfg[i].weight = ZTE_PRIORITY_WEIGHT_DEF;
       }

       /* Egress policer configuration */
       err = zte_api_fast_l3_set_egress_policer_cfg(&amp;zte_egress_policer_cfg);
  }

  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_port_stat(ZTE_L3_HARDFAST_PORT_CFG *cfg)
{
  bool status;

  ZTE_API_LOCK_OR_RETURN;
  adp_port_get_status(cfg-&gt;port, &amp;status);
  ZTE_API_UNLOCK;

  return (int) status;
}


int zte_api_fast_l3_port_add(ZTE_L3_HARDFAST_PORT_CFG *cfg)
{
  int err;

  ZTE_API_LOCK_OR_RETURN;
  err = adp_port_add(cfg-&gt;port);
  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_port_del(unsigned char port)
{
  int err;

  ZTE_API_LOCK_OR_RETURN;
  err = ZTE_NOT_IMPL; /* FIXME Disabled until fix adp_port_del(port); */
  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_shutdown(void)
{
  int err;

  ZTE_API_LOCK_OR_RETURN;
  err = adp_shutdown();
  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_session_add(ZTE_L3_HARDFAST_SESSION *session)
{
  struct adp_flow *dpf = NULL;
  struct adp_pri_key key;
  int err = ZTE_FAIL;

  ZTE_API_LOCK_OR_RETURN;

  if (!adp_is_init()) {
      err = ZTE_NOT_INIT;
      goto error;
  }

  pri_key_init(&amp;session-&gt;tuple, &amp;key);

  if (adp_frwd_flow_find(&amp;key)) {
        err = ZTE_FLOW_EXISTS;
        goto error;
  }

  if (zte_api_fast_l3_session_validate(session)) {
        err = ZTE_INVALID_PARAM;
        goto error;
  }

  dpf = adp_frwd_flow_alloc();
  if (!dpf) {
        err = ZTE_OUT_OF_MEMORY;
        goto error;
  }

  /* Construct ADP flow from ZTE session spec */
  dpf-&gt;key = key;
  dpf-&gt;mod.ops = 0;

  dpf-&gt;group_id = session-&gt;rcqueue;

  /* Drop */
  if (session-&gt;rcqueue == ZTE_ACTION_DROP) {
      dpf-&gt;state = DPF_DROP;
      goto success;
  }

  /* DSCP update */
  if (session-&gt;dscpremark) {
        dpf-&gt;mod.ops |= ADP_MDF_IP_V4_DSCP_CNG_BIT;
        ZTE_API_FAST_DBG("dscp update 0x%x: NOT IMPLEMENTED", session-&gt;dscpvalue);
        err = ZTE_NOT_IMPL;
        goto error;
  }

  /* Routing */
  if (session-&gt;l3num != 2) {
        /* MACs */
        adp_memcpy(dpf-&gt;mod.l2.dmac, session-&gt;gwmac, sizeof(dpf-&gt;mod.l2.dmac));
        adp_memcpy(dpf-&gt;mod.l2.smac, session-&gt;smac, sizeof(dpf-&gt;mod.l2.smac));
        dpf-&gt;mod.l2.eth_type = adp_ntohs(ADP_ETH_P_IP); /* FIXME Now assuming it's IPv4 pkt */
        dpf-&gt;mod.ops |= ADP_MDF_ETH_CHG;
        ZTE_API_FAST_DBG("smac, dmac update");

        /* NAT */
        if (zte_api_fast_l3_addr_cmp(&amp;session-&gt;tuple.sip, &amp;session-&gt;natip)) {
            /* S-NAT */
            if (session-&gt;direction == ZTE_DIR_UPLINK) {
                  dpf-&gt;mod.mod_tuple.sip = session-&gt;natip.ip;
                  dpf-&gt;mod.mod_tuple.sport = session-&gt;natport;
                  dpf-&gt;mod.mod_tuple.dip = session-&gt;tuple.dip.ip; /* FIXME */
                  dpf-&gt;mod.mod_tuple.dport = session-&gt;tuple.dport; /* FIXME */
                  dpf-&gt;mod.ops |= ADP_MDF_IP_V4_CHG | ADP_MDF_L4_CHG;
                  ZTE_API_FAST_DBG("snat: sip "ADP_NIPQUAD_FMT", sport %u",
                        ADP_NIPQUAD(dpf-&gt;mod.mod_tuple.sip), adp_ntohs(dpf-&gt;mod.mod_tuple.sport));
            } else /* D-NAT */ {
                  dpf-&gt;mod.mod_tuple.dip = session-&gt;natip.ip;
                  dpf-&gt;mod.mod_tuple.dport = session-&gt;natport;
                  dpf-&gt;mod.mod_tuple.sip = session-&gt;tuple.sip.ip; /* FIXME */
                  dpf-&gt;mod.mod_tuple.sport = session-&gt;tuple.sport; /* FIXME */
                  dpf-&gt;mod.ops |= ADP_MDF_IP_V4_CHG | ADP_MDF_L4_CHG;
                  ZTE_API_FAST_DBG("dnat: dip "ADP_NIPQUAD_FMT", dport %u",
                        ADP_NIPQUAD(dpf-&gt;mod.mod_tuple.dip), adp_ntohs(dpf-&gt;mod.mod_tuple.dport));
            }
        } else {
                /* only TTL dec. NAT ops include ttl dec */
                dpf-&gt;mod.ops |= ADP_MDF_IP_V4_TTL;
                ZTE_API_FAST_DBG("ttl--");
        }
  }

  /* VLAN handling. FIXME Implement double VLAN + PPPoE */
  switch (session-&gt;l2length) {
    case 14: /* No VLAN */
      /* Add PPPoE */
      if (session-&gt;isppp &amp;&amp; session-&gt;direction == ZTE_DIR_UPLINK &amp;&amp;
          session-&gt;sessionid != ZTE_NO_PARAM) {
                  ZTE_API_FAST_DBG("pppoe add sesionid %#x", adp_ntohs(session-&gt;sessionid));
                  dpf-&gt;mod.l2.eth_type = adp_ntohs(ADP_ETH_P_PPP_SES);
                  dpf-&gt;mod.l2.pppoe_sid = session-&gt;sessionid;
                  dpf-&gt;mod.ops |= ADP_MDF_PPPOE_ADD;
      }
      /* Add VLAN */
      if (session-&gt;outervlan != ZTE_NO_PARAM) {
            dpf-&gt;mod.l2.eth_type = adp_ntohs(ADP_ETH_P_8021Q);
            dpf-&gt;mod.l2.vlan_id = session-&gt;outervlan;
            dpf-&gt;mod.ops |= ADP_MDF_VLAN_ADD;
            ZTE_API_FAST_DBG("vlan add: %u", adp_ntohs(dpf-&gt;mod.l2.vlan_id));
      }
      break;
    case 18: /* Single VLAN tag */
      /* Delete VLAN */
      if (session-&gt;outervlan == ZTE_NO_PARAM) {
            dpf-&gt;mod.l2.eth_type = adp_ntohs(ADP_ETH_P_IP);
            dpf-&gt;mod.ops |= ADP_MDF_VLAN_DEL;
            ZTE_API_FAST_DBG("vlan del");
      } else  { /* Change VLAN */
            dpf-&gt;mod.l2.vlan_id = session-&gt;outervlan;
            dpf-&gt;mod.ops |= ADP_MDF_VLAN_CHG;
            dpf-&gt;mod.l2.eth_type = adp_ntohs(ADP_ETH_P_8021Q);
            ZTE_API_FAST_DBG("vlan chg: to %u", adp_ntohs(session-&gt;outervlan));
      }
      break;

    case 22: /* Double VLAN or PPPoE header */
      if (!session-&gt;isppp || session-&gt;direction == ZTE_DIR_UPLINK) {
          ZTE_API_FAST_DBG("isppp: %u dir %u,double vlan: NOT IMPLEMENTED",session-&gt;isppp, session-&gt;direction);
          err = ZTE_NOT_IMPL;
          goto error;
      } else {
          if (session-&gt;sessionid == ZTE_NO_PARAM &amp;&amp; session-&gt;direction == ZTE_DIR_DOWNLINK) {
                  ZTE_API_FAST_DBG("pppoe del");
                  dpf-&gt;mod.ops |= ADP_MDF_PPPOE_DEL;
          } else {
                  ZTE_API_FAST_DBG("Invalid pppoe params: l2len %u, sid %#x, dir %u",
                                   session-&gt;l2length, session-&gt;sessionid, session-&gt;direction);
                  err = ZTE_INVALID_PARAM;
                  goto error;
          }
      }
      break;

    case 26: /* VLAN + PPPoE header */
      if (session-&gt;sessionid != ZTE_NO_PARAM &amp;&amp;
          session-&gt;outervlan != ZTE_NO_PARAM) {
              ZTE_API_FAST_DBG("Invalid params: l2len %u, sid %#x, outervlan %#x",
                                   session-&gt;l2length, session-&gt;sessionid, session-&gt;outervlan);
                  err = ZTE_INVALID_PARAM;
                  goto error;
      }
      if (session-&gt;outervlan == ZTE_NO_PARAM &amp;&amp;
          session-&gt;sessionid == ZTE_NO_PARAM &amp;&amp;
          session-&gt;isppp) {
              ZTE_API_FAST_DBG("vlan del, pppoe del");
              /* HAIM FIXME : assuming IPV4 */
              dpf-&gt;mod.l2.eth_type = adp_ntohs(ADP_ETH_P_IP);
              dpf-&gt;mod.ops |= ADP_MDF_VLAN_DEL;
              dpf-&gt;mod.ops |= ADP_MDF_PPPOE_DEL;
      }
      else if (session-&gt;sessionid == ZTE_NO_PARAM &amp;&amp; session-&gt;isppp) {
              ZTE_API_FAST_DBG("pppoe del");
              dpf-&gt;mod.l2.eth_type = adp_ntohs(ADP_ETH_P_8021Q);
              dpf-&gt;mod.ops |= ADP_MDF_PPPOE_DEL;
      } else if (session-&gt;outervlan == ZTE_NO_PARAM) {
              ZTE_API_FAST_DBG("vlan del");
              dpf-&gt;mod.l2.eth_type = adp_ntohs(ADP_ETH_P_PPP_SES);
              dpf-&gt;mod.ops |= ADP_MDF_VLAN_DEL;
      }
      break;

    default:
      ZTE_API_FAST_ERROR("Invalid l2length %u:", session-&gt;l2length);
      err = ZTE_INVALID_PARAM;
      goto error;
  }

  dpf-&gt;state = DPF_FWD;

success:
  if (ZTE_DIR_UPLINK == session-&gt;direction) {
      dpf-&gt;mod.tx_port = ETH_PORT_PON;
      dpf-&gt;mod.tx_channel = session-&gt;channel;
      dpf-&gt;mod.txp = session-&gt;tcont;
  } else {
      dpf-&gt;mod.tx_port = session-&gt;channel;
  }
  dpf-&gt;mod.tx_queue = zte_qos_queue_cfg[session-&gt;queue].queue;

  /* save original session data */
  {
    ZTE_L3_HARDFAST_SESSION *data = adp_os_malloc(sizeof(ZTE_L3_HARDFAST_SESSION));
    adp_memcpy(data, session, sizeof(ZTE_L3_HARDFAST_SESSION));
    dpf-&gt;attr = data;
  }

  /* Add to offload table, effective immediately */
  adp_frwd_flow_add(dpf);

  ZTE_API_UNLOCK;

  return ZTE_OK;

error:
  if (dpf) {
        adp_frwd_flow_free(dpf);
  }

  ZTE_API_UNLOCK;

  return err;
}



int zte_api_fast_l3_mc_session_set(ZTE_L3_HARDFAST_MC_SESSION *session)
{
  int err;

  ZTE_API_LOCK_OR_RETURN;
  err = ZTE_NOT_IMPL;
  ZTE_API_UNLOCK;

  return err;
}



int zte_api_fast_l3_session_del(ZTE_L3_HARDFAST_TUPLE *tuple)
{
  struct adp_pri_key key;
  int err;

  ZTE_API_LOCK_OR_RETURN;

  if (!adp_is_init()) {
      err = ZTE_NOT_INIT;
      goto error;
  }

  pri_key_init(tuple, &amp;key);
  err = adp_frwd_flow_remove(&amp;key);

error:
  ZTE_API_UNLOCK;

  return err;
}

int zte_api_fast_l3_session_use(ZTE_L3_HARDFAST_TUPLE *tuple, unsigned char *status)
{
  struct adp_pri_key key;
  int err;

  ZTE_API_LOCK_OR_RETURN;

  if (!adp_is_init()) {
      err = ZTE_NOT_INIT;
      goto error;
  }

  pri_key_init(tuple, &amp;key);
  err = adp_frwd_flow_is_alive(&amp;key);

  ZTE_API_UNLOCK;

error:
  return err;
}



int zte_api_fast_l3_mc_session_use(ZTE_L3_HARDFAST_MC_TUPLE *tuple, unsigned char *status)
{
  int err;

  ZTE_API_LOCK_OR_RETURN;
  err = ZTE_NOT_IMPL;
  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_session_clr(void) {
  int err = ZTE_OK;

  ZTE_API_LOCK_OR_RETURN;

  if (!adp_is_init()) {
      err = ZTE_NOT_INIT;
      goto error;
  }

  adp_frwd_clean_all();
  ZTE_API_UNLOCK;

error:
  return err;
}


int zte_api_fast_l3_mc_session_clr(void)
{
  int err;

  ZTE_API_LOCK_OR_RETURN;
  err = ZTE_NOT_IMPL;
  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_session_stat(ZTE_L3_HARDFAST_TUPLE *tuple, ZTE_L3_HARDFAST_STAT *stat)
{
  struct adp_pri_key key;
  adp_flow_stats_t stats;
  int err;

  ZTE_API_LOCK_OR_RETURN;

  if (!adp_is_init()) {
      err = ZTE_NOT_INIT;
      goto error;
  }

  pri_key_init(tuple, &amp;key);

  /* FIXME 1) Make 64 bit stats 2) Make thread-safe */
  err = adp_frwd_flow_get_stats(&amp;key, &amp;stats);
  if (err == ADP_OK) {
        stat-&gt;rxpkt = uint64split_to_uint64(stats.rx_pkts);
        stat-&gt;txpkt = uint64split_to_uint64(stats.tx_pkts);
        stat-&gt;rxbyte = uint64split_to_uint64(stats.rx_bytes);
        stat-&gt;txbyte = uint64split_to_uint64(stats.tx_bytes);
        stat-&gt;rxerror = stats.rx_errors;
        stat-&gt;txerror = stats.tx_errors;
  }

  ZTE_API_UNLOCK;

error:
  return err;
}

int zte_api_fast_l3_mc_session_stat(ZTE_L3_HARDFAST_MC_TUPLE *tuple, ZTE_L3_HARDFAST_STAT *stat)
{
  int err;

  ZTE_API_LOCK_OR_RETURN;
  err = ZTE_NOT_IMPL;
  ZTE_API_UNLOCK;

  return err;
}




int zte_api_fast_l3_set_rx_queue_cfg(ZTE_L3_HARDFAST_RX_QUEUE_CFG *cfg)
{
  int err;

  ZTE_API_LOCK_OR_RETURN;
  err = ZTE_NOT_IMPL;
  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_get_rx_queue_cfg(ZTE_L3_HARDFAST_RX_QUEUE_CFG *cfg)
{
  int err;

  ZTE_API_LOCK_OR_RETURN;
  err = ZTE_NOT_IMPL;
  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_set_ingress_policer_cfg(ZTE_L3_HARDFAST_INGRESS_POLICER_CFG *cfg)
{
  int err = ZTE_OK;
  void *policer;

  ZTE_API_LOCK_OR_RETURN;

  if (cfg-&gt;rate_limit == 0) {
          adp_policer_port_del(cfg-&gt;port);
          goto out;
  }

  policer = adp_policer_port_get(cfg-&gt;port);
  if (!policer) {
          policer = adp_policer_alloc();
          if (!policer) {
                  err = ZTE_OUT_OF_RESOURCE;
                  goto out;
          }
          err = adp_policer_port_add(policer, cfg-&gt;port);
          if (err != ADP_OK)
                  goto out;
  }
  err = adp_policer_cfg(policer, cfg-&gt;rate_limit, 0, ADP_CLK_PER_SEC);
  
  if (err == ADP_OK) {
          zte_port_policers[cfg-&gt;port] = *cfg;
  }
out:
  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_get_ingress_policer_cfg(ZTE_L3_HARDFAST_INGRESS_POLICER_CFG *cfg)
{
  int err = ZTE_OK;
  unsigned char  port = cfg-&gt;port;


  ZTE_API_LOCK_OR_RETURN;
  if (port &gt;= ZTE_LAN_PORT_NUM) {
          err = ZTE_INVALID_PARAM;
  } else {
          *cfg = zte_port_policers[port];
  }
  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_set_rcqueue_cfg(ZTE_L3_HARDFAST_RCQUEUE_CFG *cfg)
{
  int err = ZTE_OK;
  void *policer;

  ZTE_API_LOCK_OR_RETURN;

  if (cfg-&gt;rate_limit == 0) {
          adp_policer_flow_del(cfg-&gt;rcqueue);
          goto out;
  }

  policer = adp_policer_flow_get(cfg-&gt;rcqueue);
  if (!policer) {
          policer = adp_policer_alloc();
          if (!policer) {
                  err = ZTE_OUT_OF_RESOURCE;
                  goto out;
          }
          err = adp_policer_flow_add(policer, cfg-&gt;rcqueue);
          if (err != ADP_OK)
                  goto out;
  } 
  err = adp_policer_cfg(policer, cfg-&gt;rate_limit, 0, ADP_CLK_PER_SEC);

  if (err == ADP_OK) {
          zte_flow_policers[cfg-&gt;rcqueue] = *cfg;
  }

out:
  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_get_rcqueue_cfg(ZTE_L3_HARDFAST_RCQUEUE_CFG *cfg)
{
  int err = ZTE_OK;
  unsigned char q = cfg-&gt;rcqueue;

  ZTE_API_LOCK_OR_RETURN;

  if (q &gt;= ZTE_INGRESS_FLOW_POLICER_NUM)
          err = ZTE_INVALID_PARAM;
  else
          cfg-&gt;rate_limit = zte_flow_policers[q].rate_limit;

  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_set_qos_queue_cfg(ZTE_L3_HARDFAST_QOS_QUEUE_CFG *cfg)
{
  int err = ZTE_OK;

  ZTE_API_LOCK_OR_RETURN;

  if (!adp_is_init()) {
      ZTE_API_FAST_ERROR("Can't set Qos queue cfg, not initialized.");
      err = ZTE_NOT_INIT;
  } else  if (cfg-&gt;qos_queue &gt; ZTE_QOS_QUEUE_NUM - 1 ||
              cfg-&gt;queue &gt; ETH_MAX_RXQ_NUM - 1 ) {
      ZTE_API_FAST_ERROR("Can't set Qos queue cfg, params invalid.");
      err = ZTE_INVALID_PARAM;
  } else {
      zte_qos_queue_cfg[cfg-&gt;qos_queue] = *cfg;
  }

  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_get_qos_queue_cfg(ZTE_L3_HARDFAST_QOS_QUEUE_CFG *cfg)
{
  int err = ZTE_OK;

  ZTE_API_LOCK_OR_RETURN;

  if (!adp_is_init()) {
      ZTE_API_FAST_ERROR("Can't set Qos queue cfg, not initialized.");
      err = ZTE_NOT_INIT;
  } else  if (cfg-&gt;qos_queue &gt; ZTE_QOS_QUEUE_NUM -1) {
      ZTE_API_FAST_ERROR("Can't set Qos queue cfg, params invalid.");
      err = ZTE_INVALID_PARAM;
  } else {
      *cfg = zte_qos_queue_cfg[cfg-&gt;qos_queue];
  }
  ZTE_API_UNLOCK;

  return err;
}



int zte_api_fast_l3_set_qos_queue_priority_cfg(ZTE_L3_HARDFAST_QOS_QUEUE_PRIORITY_CFG *cfg)
{
  int err = ZTE_OK;
  uint8_t queue;

  ZTE_API_LOCK_OR_RETURN;

  if (!adp_is_init()) {
      ZTE_API_FAST_ERROR("Can't set Qos queue scheduler cfg, not initialized.");
      err = ZTE_NOT_INIT;
  } else  if (cfg-&gt;qos_queue &gt; ZTE_QOS_QUEUE_NUM - 1) {
      ZTE_API_FAST_ERROR("Can't set Qos queue priority, invalid queue (%d).",
                         cfg-&gt;qos_queue);
      err = ZTE_INVALID_PARAM;
  } else {
      /* HW queue */
      queue = zte_qos_queue_cfg[cfg-&gt;qos_queue].queue;

      if (cfg-&gt;mode == ZTE_PRIORITY_MODE_SP) {
          err = eth_txq_strict_pri_set(ETH_PORT_PON, 0 /* txp */, queue);
      } else {
          err = eth_txq_wrr_pri_set(ETH_PORT_PON, 0 /* txp */, queue, cfg-&gt;weight);
      }

      /* Update only if succeeded */
      if (err == ADP_OK) {
          zte_qos_queue_pri_cfg[cfg-&gt;qos_queue] = *cfg;
      }
  }

  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_get_qos_queue_priority_cfg(ZTE_L3_HARDFAST_QOS_QUEUE_PRIORITY_CFG *cfg)
{
  int err = ZTE_OK;

  ZTE_API_LOCK_OR_RETURN;

  if (!adp_is_init()) {
      ZTE_API_FAST_ERROR("Can't get Qos queue priority, not initialized.");
      err = ZTE_NOT_INIT;
  } else  if (cfg-&gt;qos_queue &gt; ZTE_QOS_QUEUE_NUM -1) {
      ZTE_API_FAST_ERROR("Can't get Qos queue priority, invalid queue (%d).",
                         cfg-&gt;qos_queue);
      err = ZTE_INVALID_PARAM;
  } else {
      *cfg = zte_qos_queue_pri_cfg[cfg-&gt;qos_queue];
  }

  ZTE_API_UNLOCK;

  return err;
}



/* FIXME How to program no-rate limit */
int zte_api_fast_l3_set_egress_policer_cfg(ZTE_L3_HARDFAST_EGRESS_POLICER_CFG *cfg)
{
  int err = ZTE_OK;

  ZTE_API_LOCK_OR_RETURN;

  if (!adp_is_init()) {
      ZTE_API_FAST_ERROR("Can't set egress policer cfg, not initialized.");
      err = ZTE_NOT_INIT;
  } else if (cfg-&gt;rate_limit) { /* 0 - no rate limit */
      err = eth_egress_rate_set(cfg-&gt;port, 0 /* txp */, cfg-&gt;rate_limit);
      if (err == ADP_OK) {
          err = eth_egress_burst_size_set(cfg-&gt;port, 0 /* txp */, cfg-&gt;burst_size);
      }
  }

  if (err == ADP_OK) {
      zte_egress_policer_cfg = *cfg;
  }

  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_get_egress_policer_cfg(ZTE_L3_HARDFAST_EGRESS_POLICER_CFG *cfg)
{
  int err = ZTE_OK;

  ZTE_API_LOCK_OR_RETURN;

  if (!adp_is_init()) {
      ZTE_API_FAST_ERROR("Can't get egress policer cfg, not initialized.");
      err = ZTE_NOT_INIT;
  } else {
     *cfg = zte_egress_policer_cfg;
  }

  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_set_except_path_cfg(ZTE_L3_HARDFAST_EXCEPT_PATH_CFG *cfg)
{
  int err;

  ZTE_API_LOCK_OR_RETURN;
  err = ZTE_NOT_IMPL;
  ZTE_API_UNLOCK;

  return err;
}


int zte_api_fast_l3_get_except_path_cfg(ZTE_L3_HARDFAST_EXCEPT_PATH_CFG *cfg)
{
  int err;

  ZTE_API_LOCK_OR_RETURN;
  err = ZTE_NOT_IMPL;
  ZTE_API_UNLOCK;

  return err;
}


/* Snapshots of session  tables */
#define ADP_SNAPSHOT_MAX_SZ 4096

void zte_api_fast_l3_sessions_snapshot_cb(void *attr)
{
 	if (adp_flow_tbl_snapshot_size &lt; ADP_SNAPSHOT_MAX_SZ)
		adp_memcpy(&amp;adp_flow_tbl_snapshot[adp_flow_tbl_snapshot_size++], attr, sizeof(ZTE_L3_HARDFAST_SESSION));
}

void zte_api_fast_l3_mc_sessions_snapshot_cb(void *attr)
{

}

int printk(const char * fmt, ...);
/* FIXME How to free the tbl? */
int zte_api_fast_l3_sessions_snapshot(ZTE_L3_HARDFAST_SESSION **tbl)
{
  int rc;

  ZTE_API_LOCK_OR_RETURN;

	adp_flow_tbl_snapshot_size = 0;
	if (!adp_flow_tbl_snapshot) {
                int mm_sz = ADP_SNAPSHOT_MAX_SZ * sizeof(ZTE_L3_HARDFAST_SESSION);
                printk("%s:asking for %u bytes", __func__, mm_sz);
		adp_flow_tbl_snapshot = adp_os_alloc_pages(mm_sz);
        }

	if (!adp_flow_tbl_snapshot) {
		ZTE_API_FAST_ERROR("Sessions table snapshot allocation failed");
		*tbl = NULL;
		rc = ZTE_OUT_OF_MEMORY;
    goto fail;
	}

	adp_frwd_traverse(zte_api_fast_l3_sessions_snapshot_cb);
	*tbl = adp_flow_tbl_snapshot;
  ZTE_API_UNLOCK;
 
	return adp_flow_tbl_snapshot_size;

fail:
  ZTE_API_UNLOCK;

  return rc;
}


int zte_api_fast_l3_mc_sessions_snapshot(ZTE_L3_HARDFAST_MC_SESSION **tbl)
{
	return ZTE_NOT_IMPL;
}


</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2013/06/30" Time="18:27:14000">
<Copy StartSeek="0" EndSeek="797"/>
<Insert>#define ZTE_API_FAST_DEBUG
</Insert>
<Copy StartSeek="830" EndSeek="22836"/>
</Delta>
<Delta Version="1" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="11:28:30000">
<Copy StartSeek="0" EndSeek="797"/>
<Insert>/* #define ZTE_API_FAST_DEBUG */
</Insert>
<Copy StartSeek="824" EndSeek="22830"/>
</Delta>
<Delta Version="2" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="11:29:2000">
<Copy StartSeek="0" EndSeek="797"/>
<Insert>#define ZTE_API_FAST_DEBUG
</Insert>
<Copy StartSeek="826" EndSeek="22832"/>
</Delta>
<Delta Version="3" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="16:02:13000">
<Copy StartSeek="0" EndSeek="797"/>
<Insert>//#define ZTE_API_FAST_DEBUG
</Insert>
<Copy StartSeek="824" EndSeek="12290"/>
<Insert>  dpf-&gt;mod.tx_port = session-&gt;channel;
</Insert>
<Copy StartSeek="12516" EndSeek="22437"/>
<Insert>	if (!adp_flow_tbl_snapshot)
		adp_flow_tbl_snapshot = adp_os_alloc_pages(ADP_SNAPSHOT_MAX_SZ * sizeof(ZTE_L3_HARDFAST_SESSION));

</Insert>
<Copy StartSeek="22615" EndSeek="23064"/>
</Delta>
<Delta Version="4" Comment="" NL="\10" Encoding="text" Date="2013/07/17" Time="17:51:41000">
<Copy StartSeek="0" EndSeek="22551"/>
<Copy StartSeek="22619" EndSeek="23132"/>
</Delta>
<Delta Version="5" Comment="" NL="\10" Encoding="text" Date="2013/07/17" Time="17:52:10000">
<Copy StartSeek="0" EndSeek="22551"/>
<Insert>                printk("%s:asking for %u bytes\n", __func__, mm_sz)
</Insert>
<Copy StartSeek="22620" EndSeek="23133"/>
</Delta>
<Delta Version="6" Comment="" NL="\10" Encoding="text" Date="2013/07/17" Time="17:52:29000">
<Copy StartSeek="0" EndSeek="22262"/>
<Copy StartSeek="22263" EndSeek="22552"/>
<Insert>                printk("%s:asking for %u bytes\n", __func__, mm_sz);
</Insert>
<Copy StartSeek="22631" EndSeek="23144"/>
</Delta>
<Delta Version="7" Comment="" NL="\10" Encoding="text" Date="2013/07/17" Time="17:53:18000">
<Copy StartSeek="0" EndSeek="22552"/>
<Insert>                ZTE_API_FAST_ERROR("%s:asking for %u bytes", __func__, mm_sz);
</Insert>
<Copy StartSeek="22619" EndSeek="23132"/>
</Delta>
<Delta Version="8" Comment="" NL="\10" Encoding="text" Date="2013/07/17" Time="17:55:50000">
<Copy StartSeek="0" EndSeek="22262"/>
<Insert>
</Insert>
<Copy StartSeek="22297" EndSeek="23166"/>
</Delta>
</DeltaFile>
