<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="35" Comment="" Date="2013/07/04" Time="16:31:48000" NL="\10" Encoding="text">
<Insert>#include &lt;adp_types.h&gt;
#include &lt;adp_log.h&gt;
/* TODO: dynamically select platform's eth driver */
#include &lt;eth/eth_regs.h&gt;
#include &lt;util/string.h&gt;
#include &lt;util/xxhash.h&gt;
#include &lt;util/byte_order.h&gt;
#include &lt;util/string.h&gt;

#include "frwd.h"
#include "frwd_mm.h"
#include "mdf.h"
#include "policer.h"

#include &lt;zte/zte_api_fast.h&gt;

#ifdef __ADP_DEBUG__
int printk(const char * fmt, ...);
#define ADP_FRWD_DBG(format, args...) printk(format"\n", ##args)
#else
#define ADP_FRWD_DBG(format, args...)
#endif

#define ADP_FRWD_ERR(format, args...) ADP_ERROR(format, ##args)

#define ADP_FRWD_TBL_SZ (1&lt;&lt;13)

char *adp_flow_state_names[]  = {
	"NEW",
	"LRN",
	"FWD",
	"LCL",
	"DROP"
};

/* HAIM FIXME : rw protection is needed ! */
static struct adp_flow *adp_flow_tbl[ADP_FRWD_TBL_SZ];

static uint32_t adp_frwd_cmd;

void adp_dump_pkt(uint8_t *data, int len) {
#ifdef __ADP_DEBUG__
  int i;
  
  printk("&lt;0&gt;******************* LEN %d\n", len);
  for (i = 0; i &lt; len; i++) {
    printk("%02x ", data[i]);
  }
  printk("&lt;0&gt;****************************\n");
#endif
}

static void adp_flow_dump(struct adp_flow *dpf)
{
#ifdef __ADP_DEBUG__
	struct adp_pri_key *tup = &amp;dpf-&gt;key;
	struct adp_pri_key *mod_tup = &amp;dpf-&gt;mod.mod_tuple;
	struct adp_frwd_l2 *l2_mod = &amp;dpf-&gt;mod.l2;

  ADP_FRWD_DBG("--------------------------------------\n");

	ADP_FRWD_DBG("orig tup ipv4:proto %u "ADP_NIPQUAD_FMT":%d-&gt;"ADP_NIPQUAD_FMT":%d\n",
		 tup-&gt;protocol,
		 ADP_NIPQUAD(tup-&gt;sip), adp_ntohs(tup-&gt;sport),
		 ADP_NIPQUAD(tup-&gt;dip), adp_ntohs(tup-&gt;dport));

	ADP_FRWD_DBG("mod dmac= "ADP_MAC_FMT" smac= "ADP_MAC_FMT " eth_type:%#x vlan:%u",
	  ADP_MAC_PFMT(l2_mod-&gt;dmac), ADP_MAC_PFMT(l2_mod-&gt;smac), adp_ntohs(l2_mod-&gt;eth_type),
		    adp_ntohs(l2_mod-&gt;vlan_id));

	ADP_FRWD_DBG("mod tup ipv4:proto %u "ADP_NIPQUAD_FMT":%d-&gt;"ADP_NIPQUAD_FMT":%d\n",
	  mod_tup-&gt;protocol,
	  ADP_NIPQUAD(mod_tup-&gt;sip), adp_ntohs(mod_tup-&gt;sport),
	  ADP_NIPQUAD(mod_tup-&gt;dip), adp_ntohs(mod_tup-&gt;dport));

	ADP_FRWD_DBG("state:%s rx:%u fwd:%u mod_ops:%#x\n", 
		 adp_flow_state_names[dpf-&gt;state],
		 dpf-&gt;stats.rx_pkts, dpf-&gt;stats.tx_pkts, 
		 dpf-&gt;mod.ops);
#endif
}

static void adp_dump_rx_desc(eth_rx_desc_t *rx_desc)
{
#ifdef __ADP_DEBUG__
	uint32_t rx_status = rx_desc-&gt;status;

	ADP_FRWD_DBG("(%s:%d)status:%#x, ipv4:%#x tcp:%#x, udp:%x uc:%lu l4_csum:%u l3_off:%u\n",
		 __func__, __LINE__,
		rx_status,
	       NETA_RX_L3_IS_IP4(rx_status), 
	       NETA_RX_L4_IS_TCP(rx_status),
	       NETA_RX_L4_IS_UDP(rx_status),
	      NETA_PNC_RX_IS_DA_UC(rx_desc),
		 (rx_status &amp; NETA_RX_L4_CSUM_OK_MASK) != 0,
		 NETA_RX_GET_IPHDR_OFFSET(rx_desc));
#endif
}

static inline void adp_frwd_memcpy_14b_16a(void *a, const void *b)
{
	register uint16_t *a16 ,*b16;
	a16 = (uint16_t *)a;
	b16 = (uint16_t *)b;

	*a16++ = *b16++;
	*a16++ = *b16++;
	*a16++ = *b16++;
	*a16++ = *b16++;
	*a16++ = *b16++;
	*a16++ = *b16++;
	*a16 = *b16;
}

static inline uint32_t
is_pri_key_match(struct adp_pri_key *a, struct adp_pri_key *b)
{
	register uint32_t *a32, *b32;
	a32 = (uint32_t *)a;
	b32 = (uint32_t *)b;

	return (*a32++ == *b32++) &amp;&amp;
		(*a32++ == *b32++) &amp;&amp;
		(*a32++ == *b32++) &amp;&amp;
		(*a32 == *b32);

//      return (a-&gt;dip == b-&gt;dip) &amp;&amp;
//      	(a-&gt;sip == b-&gt;sip) &amp;&amp;
//      	(a-&gt;protocol == b-&gt;protocol) &amp;&amp;
//      	(a-&gt;sport == b-&gt;sport) &amp;&amp;
//      	(a-&gt;dport == b-&gt;dport);
}

struct adp_flow *adp_frwd_flow_alloc(void)
{
	struct adp_flow *tmp;

  tmp = dcm_alloc();
  if (!tmp) {
      ADP_FRWD_DBG("Failed to alloc dpf entry\n");
      return NULL;
  }

  tmp-&gt;state = DPF_NEW;
  uint64split_reset(tmp-&gt;stats.rx_pkts);
  uint64split_reset(tmp-&gt;stats.tx_pkts);
  uint64split_reset(tmp-&gt;stats.rx_bytes);
  uint64split_reset(tmp-&gt;stats.tx_bytes);
  tmp-&gt;stats.rx_errors = 0;
  tmp-&gt;stats.tx_errors = 0;
  tmp-&gt;mod.ops = 0;
  tmp-&gt;mod.tx_port = ~0;
  tmp-&gt;next = NULL;
  tmp-&gt;attr = NULL;
 	
  return tmp;
}


void adp_frwd_flow_free(struct adp_flow *dpf)
{
	if (dpf-&gt;attr)
		adp_os_free(dpf-&gt;attr);
  dcm_free(dpf);
}

#define SEED 	0
#define LEN	12
#define PRIME1   2654435761UL
#define PRIME2   2246822519UL
#define PRIME3   3266489917UL
#define PRIME4   668265263UL
#define PRIME5   0x165667b1
#define _rotl(x,r) (((x) &lt;&lt; (r)) | ((x) &gt;&gt; (32 - (r))))

static inline unsigned int adp_frwd_XXH_small32_12b(const void* key)
{
	register const unsigned char* p = (unsigned char*)key;
	register int idx = SEED + PRIME1;
	register unsigned int crc  = PRIME5;


	crc += ((*(unsigned int*)p) + idx++);
	p+=4;
	crc += _rotl(crc, 17) * PRIME4;
	crc *= PRIME1;
	crc += ((*(unsigned int*)p) + idx++);
	p+=4;
	crc += _rotl(crc, 17) * PRIME4;
	crc *= PRIME1;

	crc += ((*p) + idx++);
	crc *= PRIME1;
	p++;
	crc += ((*p) + idx++);
	crc *= PRIME1;
	p++;
	crc += ((*p) + idx++);
	crc *= PRIME1;
	p++;
	crc += ((*p) + idx++);
	crc *= PRIME1;

	crc += LEN;

	crc ^= crc &gt;&gt; 15;
	crc *= PRIME2;
	crc ^= crc &gt;&gt; 13;
	crc *= PRIME3;
	crc ^= crc &gt;&gt; 16;

	return crc;
}

static inline uint32_t adp_key_hash(struct adp_pri_key *key)
{
	register uint32_t idx = 0;
//	idx = adp_key_XXH_small32_12b(key);
#if 1
	idx = key-&gt;sip ^ (_rotl(key-&gt;dip,7));
	idx += key-&gt;sport;
	idx *= PRIME1;
	idx += key-&gt;dport;
#else
	idx = key-&gt;dport;
#endif 
	idx &amp;= (ADP_FRWD_TBL_SZ - 1);
  
  return idx;
}

struct adp_flow *adp_frwd_flow_find(struct adp_pri_key *key)
{
	struct adp_flow **dpe_list, *dpf;

	dpe_list = &amp;adp_flow_tbl[adp_key_hash(key)]; /* head of the chain */
	dpf = *dpe_list;

	if (!dpf)
		return dpf;

	do {
		if (is_pri_key_match(&amp;dpf-&gt;key, key)) {
			ADP_FRWD_DBG("matching flow found");
			return dpf;
		}
		dpf = dpf-&gt;next;
	} while (dpf);

	return dpf;
}

static inline void adp_pri_key_init(adp_ip_hdr_t *iph, adp_l4_hdr_t *l4,
		struct adp_pri_key *tup)
{
	tup-&gt;sip = iph-&gt;saddr;
	tup-&gt;dip = iph-&gt;daddr;
	tup-&gt;protocol = iph-&gt;protocol;
	tup-&gt;sport = l4-&gt;source;
	tup-&gt;dport = l4-&gt;dest;
}



void adp_frwd_flow_add(struct adp_flow *dpf)
{
  struct adp_flow **dpe_list, *tmp;

  dpe_list = &amp;adp_flow_tbl[adp_key_hash(&amp;dpf-&gt;key)]; /* head of the chain */
  tmp = *dpe_list;

  if (!tmp) {
       *dpe_list = dpf;
       adp_flow_dump(dpf);
       return;
  }
  
  dpf-&gt;next = tmp;
  *dpe_list = dpf;
  
  adp_flow_dump(dpf);
}


/* FIXME Non-SMP safe */
int32_t adp_frwd_flow_remove(struct adp_pri_key *key)
{
  struct adp_flow **dpe_list, *dpf, *prev;

  dpe_list = &amp;adp_flow_tbl[adp_key_hash(key)]; /* head of the chain */
  dpf = *dpe_list;

  if (!dpf)
        return -1;

  prev = dpf;
  do {
    if (is_pri_key_match(&amp;dpf-&gt;key, key)) {
        ADP_FRWD_DBG("match dpf found for remove");

        /* First entry in list */
        if (prev == dpf) {
            /* Single element in list */
            if (!dpf-&gt;next) {
                *dpe_list = NULL;
            } else {
                *dpe_list = dpf-&gt;next;
            }
        } else {
            prev-&gt;next = dpf-&gt;next;
        }

        adp_flow_dump(dpf);
        dpf-&gt;next = NULL;
        dcm_free(dpf);
        return 0;
    }
    prev = dpf;
    dpf = dpf-&gt;next;
  } while (dpf);
  
  return -1;
}


bool adp_frwd_flow_is_alive(struct adp_pri_key *key) {
  struct adp_flow *dpf;
  bool is_alive;
  
  dpf = adp_frwd_flow_find(key);
  if (!dpf) {
        return false;
  }

  is_alive = dpf-&gt;is_alive;
  if (is_alive) {
        dpf-&gt;is_alive = false;
  }

  return is_alive;
}


int32_t adp_frwd_flow_get_stats(struct adp_pri_key *key, adp_flow_stats_t *stats) 
{
  struct adp_flow *dpf = adp_frwd_flow_find(key);

  if (!dpf) {
        return ADP_FLOW_UNKNOWN;
  }

  *stats = dpf-&gt;stats;
  
  return ADP_OK;
}


void adp_frwd_clean_all(void)
{
	unsigned int idx;
	struct adp_flow *e, *next;

  adp_frwd_cmd = 1; /* FIXME Make proper in-context implementation */
  
	for (idx = 0; idx &lt; ADP_FRWD_TBL_SZ; idx++) {
		e = adp_flow_tbl[idx];
		while (e) {
			next = e-&gt;next;
			e-&gt;next = NULL;
			/* adp_memset(e, 0, sizeof(struct adp_flow)); */
			dcm_free(e);
			e = next;
		}
		adp_flow_tbl[idx] = NULL;
	}
  
  adp_frwd_cmd = 0;
}



/* adp forwarder traverse session tables */

void adp_frwd_traverse(adp_frwd_traverse_cb cb)
{
	unsigned int idx;
	struct adp_flow *e;


	adp_frwd_cmd = 1; /* FIXME Make proper in-context implementation */

	for (idx = 0; idx &lt; ADP_FRWD_TBL_SZ; idx++) {
		e = adp_flow_tbl[idx];
		while (e) {
			cb(e-&gt;attr);
			e = e-&gt;next;
		}
	}

	adp_frwd_cmd = 0;
}

/* rate limiting of the ingress traffic. Ingress port policing is done only on
   upstream (non-pon interface) */
static inline int adp_frwd_ratelimit(struct adp_flow *dpf, eth_pkt_t *pkt)
{
	uint32_t pkt_sz = pkt-&gt;size + 4; /* compensate CRC len */

	if (adp_policer_flow_do(dpf-&gt;group_id, pkt_sz) == ADP_POLICE_OK) {
		if (ETH_PORT_HAS_MH(dpf-&gt;mod.tx_port) &amp;&amp;
		    adp_policer_port_do(pkt-&gt;port, pkt_sz) == ADP_POLICE_DROP) {
			ADP_FRWD_DBG("dropping port");
			return DPF_DROP;
		}
	} else {
		ADP_FRWD_DBG("dropping flow");
		return DPF_DROP;
	}
	ADP_FRWD_DBG("frwd pkt ok");
	return DPF_FWD;
}

void adp_frwd_mc_traverse(adp_frwd_traverse_cb cb)
{
}

/* adp forwarder entry point */
adp_flow_states adp_frwd_rx(eth_pkt_t *pkt)
{
	adp_ip_hdr_t *iph;
	adp_l4_hdr_t *l4;
	struct adp_pri_key tup;
	struct adp_flow *dpf;
	adp_eth_hdr_t *eth = pkt-&gt;eth_hdr;
	eth_rx_desc_t *rx_desc = pkt-&gt;rx_desc;
	uint32_t rx_status = rx_desc-&gt;status;
	uint8_t mh;

	if (adp_frwd_cmd) /* FIXME Make proper in-context implementation */
		return DPF_LCL;
 	adp_dump_rx_desc(rx_desc);

	if (!NETA_RX_L3_IS_IP4(rx_status)) {
		if (eth-&gt;h_proto == adp_ntohs(ADP_ETH_P_ARP)) {
			pkt-&gt;prio = ADP_PKT_PRI_MAX;
		}
		return DPF_LCL;
	}
	pkt-&gt;prio = ADP_PKT_PRI_MIN;

	if (!(NETA_RX_L4_IS_TCP(rx_status) || NETA_RX_L4_IS_UDP(rx_status)) ||
	    NETA_RX_IP_IS_FRAG(rx_status) ||
	    !(rx_status &amp; NETA_RX_L4_CSUM_OK_MASK) ||
	    !NETA_PNC_RX_IS_DA_UC(rx_desc)) {
		return DPF_LCL;
	}
	iph = pkt-&gt;ip_hdr;
	l4 = (adp_l4_hdr_t*)((uint8_t* )iph + (iph-&gt;ihl &lt;&lt; 2));
	pkt-&gt;l4_hdr = l4;

	adp_pri_key_init(iph, l4, &amp;tup); 
	dpf = adp_frwd_flow_find(&amp;tup);
	if (!dpf) {
		ADP_FRWD_DBG("flow not found");
		return DPF_LCL;
	}
	dpf-&gt;is_alive = true; 
	pkt-&gt;adp_handle = (void *)dpf; /* mark the packet as ours */

	uint64split_sum(dpf-&gt;stats.rx_pkts, 1);
	uint64split_sum(dpf-&gt;stats.rx_bytes, pkt-&gt;size + ETH_CRC_SIZE);

	if (iph-&gt;ttl &lt;= 1)
		return DPF_DROP;

	if (dpf-&gt;state == DPF_FWD) {
		if (adp_frwd_ratelimit(dpf, pkt) == DPF_DROP)
			return DPF_DROP;

		adp_modify_pkt(pkt);

		/* Eth egress port */
		pkt-&gt;port = dpf-&gt;mod.tx_port;

		/* Eth Tx queue */
		pkt-&gt;queue = 0;	/* FIXME qos2queue(pkt) */

		/* Eth Tx cmd */
		mh = ETH_PORT_HAS_MH(pkt-&gt;port) ? 2 : 0; /* FIXME Make calc more generic */
		pkt-&gt;size += mh;
		if (dpf-&gt;mod.ops) {
			uint8_t ip_off =(uint8_t *)pkt-&gt;ip_hdr - (uint8_t *)pkt-&gt;eth_hdr;
			pkt-&gt;hw_cmd = NETA_TX_L3_IP4 | NETA_TX_IP_CSUM_MASK |
				      ((ip_off+mh) &lt;&lt; NETA_TX_L3_OFFSET_OFFS) |
				      ((mh^0x02) &lt;&lt; NETA_TX_PKT_OFFSET_OFFS) |
				      (iph-&gt;ihl &lt;&lt; NETA_TX_IP_HLEN_OFFS);

			if (dpf-&gt;key.protocol == ADP_IP_PROTO_UDP)
				pkt-&gt;hw_cmd |= NETA_TX_L4_UDP;
			else
				pkt-&gt;hw_cmd &amp;= ~NETA_TX_L4_UDP;

			pkt-&gt;hw_cmd |= NETA_TX_L4_CSUM_FULL;
			uint64split_sum(dpf-&gt;stats.tx_pkts, 1);
			uint64split_sum(dpf-&gt;stats.tx_bytes, pkt-&gt;size - mh + ETH_CRC_SIZE);

		} else {
			/* No modification, so just indicate pkt start. If no mh, skip it since
			it's always present from Rx */
			pkt-&gt;hw_cmd = ((mh^0x02) &lt;&lt; NETA_TX_PKT_OFFSET_OFFS);
		}

		ADP_FRWD_DBG("################ pkt forwarded to port %d, %d bytes, pkt-&gt;cmd 0x%x", pkt-&gt;port, pkt-&gt;size, pkt-&gt;hw_cmd);
	}

	ADP_FRWD_DBG("state %s\n",adp_flow_state_names[dpf-&gt;state]);
	return dpf-&gt;state;
}


int32_t adp_frwd_init(void)
{
	void *pool = dcm_init(ADP_FRWD_TBL_SZ, 
			      sizeof(struct adp_flow));
	if (!pool)
		return ADP_OUT_OF_MEMORY;
	
	if (adp_mdf_init())
		return ADP_CONFIG_ERROR;

	ADP_FRWD_DBG("ADP forwarder init OK.");

	return ADP_OK;
}

void adp_frwd_exit(void)
{
	adp_frwd_clean_all();
}
</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2013/06/30" Time="18:27:14000">
<Copy StartSeek="0" EndSeek="337"/>
<Insert>#ifdef __ADP_DEBUG__
</Insert>
<Copy StartSeek="366" EndSeek="11833"/>
</Delta>
<Delta Version="1" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="11:36:3000">
<Copy StartSeek="0" EndSeek="337"/>
<Insert>//#ifdef __ADP_DEBUG__
#if 1
</Insert>
<Copy StartSeek="380" EndSeek="9346"/>
<Insert>
</Insert>
<Copy StartSeek="9375" EndSeek="9768"/>
<Insert>	adp_dump_rx_desc(rx_desc);
</Insert>
<Copy StartSeek="9768" EndSeek="11847"/>
</Delta>
<Delta Version="2" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="11:37:43000">
<Copy StartSeek="0" EndSeek="2265"/>
<Insert>
</Insert>
<Copy StartSeek="2270" EndSeek="11851"/>
</Delta>
<Delta Version="3" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="12:24:3000">
<Copy StartSeek="0" EndSeek="2265"/>
<Insert>asdf
</Insert>
<Copy StartSeek="2266" EndSeek="11847"/>
</Delta>
<Delta Version="4" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="12:24:12000">
<Copy StartSeek="0" EndSeek="9946"/>
<Copy StartSeek="9979" EndSeek="11880"/>
</Delta>
<Delta Version="5" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="14:37:30000">
<Copy StartSeek="0" EndSeek="9946"/>
<Insert>		ADP_FRWD_DBG("dpf not found");
</Insert>
<Copy StartSeek="9980" EndSeek="11881"/>
</Delta>
<Delta Version="6" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="14:37:36000">
<Copy StartSeek="0" EndSeek="5494"/>
<Insert>			ADP_FRWD_DBG("match dpf found");
</Insert>
<Copy StartSeek="5534" EndSeek="11885"/>
</Delta>
<Delta Version="7" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="14:37:47000">
<Copy StartSeek="0" EndSeek="337"/>
<Insert>#define __ADP_DEBUG__
</Insert>
<Copy StartSeek="338" EndSeek="11864"/>
</Delta>
<Delta Version="8" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="14:52:53000">
<Copy StartSeek="0" EndSeek="337"/>
<Insert>
</Insert>
<Copy StartSeek="337" EndSeek="11863"/>
</Delta>
<Delta Version="9" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="14:53:5000">
<Copy StartSeek="0" EndSeek="4958"/>
<Insert>	register uint32_t idx = 0;
</Insert>
<Copy StartSeek="4982" EndSeek="11859"/>
</Delta>
<Delta Version="10" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:14:21000">
<Copy StartSeek="0" EndSeek="5021"/>
<Insert>#if 0
</Insert>
<Copy StartSeek="5027" EndSeek="11859"/>
</Delta>
<Delta Version="11" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:15:8000">
<Copy StartSeek="0" EndSeek="5527"/>
<Copy StartSeek="5548" EndSeek="11880"/>
</Delta>
<Delta Version="12" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:15:55000">
<Copy StartSeek="0" EndSeek="5527"/>
<Insert>		hash_collisions++;
</Insert>
<Copy StartSeek="5527" EndSeek="5546"/>
<Copy StartSeek="5567" EndSeek="11880"/>
</Delta>
<Delta Version="13" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:25:29000">
<Copy StartSeek="0" EndSeek="817"/>
<Insert>
</Insert>
<Copy StartSeek="850" EndSeek="11912"/>
</Delta>
<Delta Version="14" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:26:29000">
<Copy StartSeek="0" EndSeek="850"/>
<Copy StartSeek="851" EndSeek="11913"/>
</Delta>
<Delta Version="15" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:26:29000">
<Copy StartSeek="0" EndSeek="7956"/>
<Insert>  
</Insert>
<Copy StartSeek="7979" EndSeek="11933"/>
</Delta>
<Delta Version="16" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:28:13000">
<Copy StartSeek="0" EndSeek="7643"/>
<Insert>  adp_frwd_cmd = 1; /* FIXME Make proper in-context implementation */
</Insert>
<Copy StartSeek="7712" EndSeek="11932"/>
</Delta>
<Delta Version="17" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:31:52000">
<Copy StartSeek="0" EndSeek="7955"/>
<Insert>  hash_collisions = 0;
  adp_frwd_cmd = 0;
</Insert>
<Copy StartSeek="7996" EndSeek="11930"/>
</Delta>
<Delta Version="18" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:31:55000">
<Copy StartSeek="0" EndSeek="7999"/>
<Insert>

</Insert>
<Copy StartSeek="8089" EndSeek="12018"/>
</Delta>
<Delta Version="19" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:42:14000">
<Copy StartSeek="0" EndSeek="7999"/>
<Insert>uint32_t adp_frwd_get_hash_stats()
</Insert>
<Copy StartSeek="8038" EndSeek="12022"/>
</Delta>
<Delta Version="20" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:42:20000">
<Copy StartSeek="0" EndSeek="7999"/>
<Insert>uint32_t adp_frwd_get_hash_stats(void)
</Insert>
<Copy StartSeek="8033" EndSeek="12017"/>
</Delta>
<Delta Version="21" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:44:52000">
<Copy StartSeek="0" EndSeek="8035"/>
<Insert>	printk("hash_collisions: %u\n",hash_collisions);
</Insert>
<Copy StartSeek="8088" EndSeek="12020"/>
</Delta>
<Delta Version="22" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:45:39000">
<Copy StartSeek="0" EndSeek="8035"/>
<Insert>	ADP_ERROR("hash_collisions: %u\n",hash_collisions);
</Insert>
<Copy StartSeek="8089" EndSeek="12021"/>
</Delta>
<Delta Version="23" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:45:42000">
<Copy StartSeek="0" EndSeek="7999"/>
<Insert>uint32_t adp_frwd_get_stats(void)
</Insert>
<Copy StartSeek="8029" EndSeek="12017"/>
</Delta>
<Delta Version="24" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:46:16000">
<Copy StartSeek="0" EndSeek="5054"/>
<Insert>#if 1
</Insert>
<Copy StartSeek="5060" EndSeek="12017"/>
</Delta>
<Delta Version="25" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:48:9000">
<Copy StartSeek="0" EndSeek="5015"/>
<Insert>//	idx = adp_key_XXH_small32_12b(key);
</Insert>
<Copy StartSeek="5052" EndSeek="12015"/>
</Delta>
<Delta Version="26" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:48:13000">
<Copy StartSeek="0" EndSeek="5015"/>
<Insert>	idx = adp_key_XXH_small32_12b(key);
</Insert>
<Copy StartSeek="5053" EndSeek="12016"/>
</Delta>
<Delta Version="27" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:48:38000">
<Copy StartSeek="0" EndSeek="817"/>
<Insert>static uint32_t hash_collisions;
</Insert>
<Copy StartSeek="857" EndSeek="5585"/>
<Insert>		hash_collisions++;
</Insert>
<Copy StartSeek="5613" EndSeek="7968"/>
<Insert>	hash_collisions = 0;
</Insert>
<Copy StartSeek="7997" EndSeek="8051"/>
<Insert>	ADP_ERROR("hash_collisions: %u\n", hash_collisions);
</Insert>
<Copy StartSeek="8119" EndSeek="12051"/>
</Delta>
<Delta Version="28" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="15:59:5000">
<Copy StartSeek="0" EndSeek="5022"/>
<Insert>	idx = adp_frwd_XXH_small32_12b(key);
#if 0
</Insert>
<Copy StartSeek="5073" EndSeek="12058"/>
</Delta>
<Delta Version="29" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="16:11:12000">
<Copy StartSeek="0" EndSeek="4934"/>
<Insert>
</Insert>
<Copy StartSeek="4937" EndSeek="12060"/>
</Delta>
<Delta Version="30" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="16:11:34000">
<Copy StartSeek="0" EndSeek="4934"/>
<Insert>ad
</Insert>
<Copy StartSeek="4935" EndSeek="12058"/>
</Delta>
<Delta Version="31" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="16:11:44000">
<Copy StartSeek="0" EndSeek="4043"/>
<Insert>#define PRIME1   2654435761U
#define PRIME2   2246822519U
#define PRIME3   3266489917U
#define PRIME4   668265263U
</Insert>
<Copy StartSeek="4162" EndSeek="12062"/>
</Delta>
<Delta Version="32" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="16:12:14000">
<Copy StartSeek="0" EndSeek="817"/>
<Insert>static uint32_t flow_search_iterations;

</Insert>
<Copy StartSeek="818" EndSeek="4962"/>
<Insert>	register uint32_t idx;
//      idx = adp_frwd_XXH_small32_12b(key);
</Insert>
<Copy StartSeek="5029" EndSeek="7937"/>
<Insert>	flow_search_iterations = 0;
</Insert>
<Copy StartSeek="7940" EndSeek="7962"/>
<Insert>void adp_frwd_get_stats(void)
{
	ADP_ERROR("flow_search_iterations: %u\n", flow_search_iterations);
}

</Insert>
<Copy StartSeek="7964" EndSeek="9358"/>
<Insert>	adp_dump_rx_desc(rx_desc);
</Insert>
<Copy StartSeek="9387" EndSeek="11894"/>
</Delta>
<Delta Version="33" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="16:25:55000">
<Copy StartSeek="0" EndSeek="7625"/>
<Insert>	adp_frwd_cmd = 1; /* FIXME Make proper in-context implementation */
</Insert>
<Copy StartSeek="7695" EndSeek="7941"/>
<Insert>	adp_frwd_cmd = 0;
</Insert>
<Copy StartSeek="7961" EndSeek="11896"/>
</Delta>
<Delta Version="34" Comment="" NL="\10" Encoding="text" Date="2013/07/04" Time="16:26:22000">
<Copy StartSeek="0" EndSeek="5554"/>
<Insert>		flow_search_iterations++;
</Insert>
<Copy StartSeek="5554" EndSeek="11868"/>
</Delta>
</DeltaFile>
