<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="15" Comment="" Date="2012/05/01" Time="08:51:59000" NL="\10" Encoding="text">
<Insert>/*
 *	Marvell Kernel Learning Agent
 * 
 *      Authors:
 *	Haim Daniel
 *
 *	This program is free software; you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License
 *	as published by the Free Software Foundation; either version
 *	2 of the License, or (at your option) any later version.
 */

#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/netdevice.h&gt;
#include &lt;linux/notifier.h&gt;
#include &lt;asm/cacheflush.h&gt;
#include &lt;net/netevent.h&gt;
#include &lt;net/neighbour.h&gt;
#include &lt;net/sock.h&gt;
#include &lt;vlan.h&gt;
#include &lt;br_private.h&gt;
#include &lt;linux/if_arp.h&gt;
#include &lt;net/netfilter/nf_conntrack.h&gt;
#include &lt;net/netfilter/nf_conntrack_ecache.h&gt;
#include &lt;net/netfilter/nf_conntrack_l3proto.h&gt;
#include &lt;net/netfilter/nf_conntrack_l4proto.h&gt;
#include &lt;linux/version.h&gt;

#include "include/klna_pppoe_sock.h"

#undef pr_fmt
#define pr_fmt(fmt) "klna_nc: " fmt

static int no_ct = 0;
module_param(no_ct, int, 0644);
MODULE_PARM_DESC(no_ct, "avoid reporting conntrack events");

DEFINE_SPINLOCK(klna_lock);
struct sock *(*org_sk_alloc)(int family, gfp_t priority,
		      struct proto *prot, int zero_it);
#ifdef CONFIG_NF_CONNTRACK_EVENTS

#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,26)
static inline u_int16_t nf_ct_l3num(const struct nf_conn *ct)
{
	return ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.l3num;
}
static inline u_int8_t nf_ct_protonum(const struct nf_conn *ct)
{
	return ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum;
}
#endif /* KERNEL_VERSION 2.6.26 */

#ifndef NIPQUAD
	#define NIPQUAD(addr) \
	((unsigned char *)&amp;addr)[0], \
	((unsigned char *)&amp;addr)[1], \
	((unsigned char *)&amp;addr)[2], \
	((unsigned char *)&amp;addr)[3]
	#define NIPQUAD_FMT "%u.%u.%u.%u"
#endif

static void klna_print_conntrack_tuple(struct nf_conn *ct)
{
	const struct nf_conntrack_l3proto *l3proto;
	const struct nf_conntrack_l4proto *l4proto;

	struct nf_conntrack_tuple *tuple = 
		&amp;ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple;

	l3proto = __nf_ct_l3proto_find(nf_ct_l3num(ct));
	NF_CT_ASSERT(l3proto);
	l4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
	NF_CT_ASSERT(l4proto);

	pr_info("[%s]" NIPQUAD_FMT ":%u -&gt; " NIPQUAD_FMT ":%u\n",
		l4proto-&gt;name,
		NIPQUAD(tuple-&gt;src.u3.ip), ntohs(tuple-&gt;src.u.all),
		NIPQUAD(tuple-&gt;dst.u3.ip), ntohs(tuple-&gt;dst.u.all));
}

#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,31)
static int klna_nc_ct_event(struct notifier_block *this,
				     unsigned long events, void *item)
{
	struct nf_conn *ct = (struct nf_conn *)item;

	/* ignore fake conntrack entry */
	if (ct == &amp;nf_conntrack_untracked)
		return 0;

	if (events &amp; IPCT_DESTROY) {
		pr_info("destroyed ct \n");
		klna_print_conntrack_tuple(ct);
	} else  if (events &amp; IPCT_NEW) {
		pr_info("new ct\n");
		klna_print_conntrack_tuple(ct);
	} else if (events &amp; IPCT_RELATED) {
		pr_info("related ct\n");
		klna_print_conntrack_tuple(ct);
	}

	return 0;

}
static struct notifier_block klna_ct_notifier = {
	.notifier_call	= klna_nc_ct_event,
};

#else
static int klna_nc_ct_event(unsigned int events, struct nf_ct_event *item)
{
	struct nf_conn *ct = item-&gt;ct;

	/* ignore fake conntrack entry */
	if (ct == &amp;nf_conntrack_untracked)
		return 0;

	if (events &amp; IPCT_DESTROY) {
		pr_info("destroyed ct \n");
		klna_print_conntrack_tuple(ct);
	} else  if (events &amp; IPCT_NEW) {
		pr_info("new ct\n");
		klna_print_conntrack_tuple(ct);
	} else if (events &amp; IPCT_RELATED) {
		pr_info("related ct\n");
		klna_print_conntrack_tuple(ct);
	}

	return 0;
}

static struct nf_ct_event_notifier klna_ct_notifier = {
	.fcn = klna_nc_ct_event
};
#endif /* KERNEL_VERSION 2.6.31 */

#endif /* CONFIG_NF_CONNTRACK_EVENTS */

static int klna_nc_br_if_event(struct notifier_block *unused, unsigned long event, 
			      void *ptr)
{
	struct net_device *dev = ptr;
	struct net_bridge *br = dev-&gt;br_port-&gt;br;

	switch (event) {

	case NETDEV_REGISTER:
		pr_info("if %s up at br [%s]\n", dev-&gt;name, br-&gt;dev-&gt;name);
		break;

	case NETDEV_UNREGISTER:
		pr_info("if %s down at br [%s]\n", dev-&gt;name, br-&gt;dev-&gt;name);
		break;
	}
	return NOTIFY_DONE;
}

static int klna_nc_br_dev_event(struct notifier_block *unused, unsigned long event, 
			      void *ptr)
{
	struct net_device *dev = ptr;
	struct net_bridge *br;

	br = netdev_priv(dev);

	switch (event) {

	case NETDEV_REGISTER:
		pr_info("br up [%s]\n", dev-&gt;name);
		break;

	case NETDEV_UNREGISTER:
		pr_info("br unreg [%s]\n", dev-&gt;name);
		break;
	}

	return NOTIFY_DONE;
}

static int 
klna_nc_eth_dev_event(struct notifier_block *unused, unsigned long event,
			     void *ptr)
{
	struct net_device *dev = ptr;

	printk(KERN_ERR "(%s:%d) eth dev %s event %lu\n", __func__, __LINE__,
	       dev-&gt;name, event);
	switch (event) {
	case NETDEV_REGISTER:
		pr_info("eth dev register %s\n", dev-&gt;name);
		break;
	case NETDEV_UNREGISTER:
		pr_info("eth dev unregister %s\n", dev-&gt;name);
		break;
	case NETDEV_UP:
		pr_info("eth dev %s up\n", dev-&gt;name);
	case NETDEV_DOWN:
		pr_info("eth dev %s down\n", dev-&gt;name);
	case NETDEV_CHANGE:
		pr_info("eth dev %s change\n",dev-&gt;name);

	}

	return NOTIFY_DONE;
}

static int 
klna_nc_pppox_dev_event(struct notifier_block *unused, unsigned long event,
			     void *ptr)
{
	struct net_device *dev = ptr;

	printk(KERN_ERR "(%s:%d) pppox dev %s event %lu\n", __func__, __LINE__,
	       dev-&gt;name, event);

	switch (event) {
	case NETDEV_REGISTER:
		pr_info("dev register %s\n", dev-&gt;name);
		break;
	case NETDEV_UNREGISTER:
		pr_info("dev unregister %s\n", dev-&gt;name);
		break;
	case NETDEV_UP:
		pr_info("dev %s up\n", dev-&gt;name);
		find_dev_pppoe_socks(dev);
		break;
	case NETDEV_DOWN:
		pr_info("dev %s down\n", dev-&gt;name);
		find_dev_pppoe_socks(dev);
		break;
	case NETDEV_GOING_DOWN:
		pr_info("dev %s going down\n", dev-&gt;name);
		find_dev_pppoe_socks(dev);
		break;
	}

	return NOTIFY_DONE;
}

static int 
klna_nc_vlan_dev_event(struct notifier_block *unused, unsigned long event,
			     void *ptr)
{
	struct net_device *dev = ptr;
	struct vlan_dev_info *dev_info = (struct vlan_dev_info *)netdev_priv(dev);

	switch (event) {
	case NETDEV_REGISTER:
		pr_info("vlan register %s vid %u\n", dev-&gt;name, dev_info-&gt;vlan_id);
		break;
	case NETDEV_UNREGISTER:
		pr_info("vlan unreg %s vid %u\n", dev-&gt;name, dev_info-&gt;vlan_id);
		break;
	case NETDEV_UP:
		pr_info("vlan %s up vid %u\n", dev-&gt;name, dev_info-&gt;vlan_id);
		break;
	case NETDEV_DOWN:
		pr_info("vlan %s down vid %u\n", dev-&gt;name, dev_info-&gt;vlan_id);
		break;
	}

	return NOTIFY_DONE;
}

/* main dispatcher for netdev events */
static int klna_nc_netdev_event(struct notifier_block *unused, unsigned long event,
			   void *ptr)
{
	struct net_device *dev = ptr;
	
//      pr_info("dpa_netdev_dev %s event %lu, dev_type: %#x, flags #%x\n",dev-&gt;name, event,
//      	dev-&gt;type, dev-&gt;priv_flags);

	if (dev-&gt;priv_flags &amp; IFF_802_1Q_VLAN) {
		return klna_nc_vlan_dev_event(unused, event, ptr);
	} 
	if (dev-&gt;priv_flags &amp; IFF_EBRIDGE) {
		return klna_nc_br_dev_event(unused,event,ptr);
	} else if (dev-&gt;br_port) {
		return klna_nc_br_if_event(unused,event,ptr);
	}
	if (dev-&gt;type == ARPHRD_ETHER) {
		return klna_nc_eth_dev_event(unused,event,ptr);
	}
	if (dev-&gt;type == ARPHRD_PPP) {
		return klna_nc_pppox_dev_event(unused,event,ptr);
	}

	return NOTIFY_DONE;
}

static struct notifier_block klna_netdev_notifier __read_mostly = {
	.notifier_call = klna_nc_netdev_event,
};

int klna_nc_init(void)
{
	int err = 0;

	pr_info("init\n");
	err = register_netdevice_notifier(&amp;klna_netdev_notifier);
	if (err) {
		unregister_netdevice_notifier(&amp;klna_netdev_notifier);
	}
#ifdef CONFIG_NF_CONNTRACK_EVENTS
	if (!no_ct) {
		pr_info("reg nf_conntrack\n");
		err = nf_conntrack_register_notifier(&amp;klna_ct_notifier);
		if (err) {
			nf_conntrack_unregister_notifier(&amp;klna_ct_notifier);
		}
	}
#else
	#warning "CONFIG_NF_CONNTRACK_EVENTS undefined!"
#endif
	return err;
}

void klna_nc_exit(void)
{
	pr_info("exit\n");
	unregister_netdevice_notifier(&amp;klna_netdev_notifier);
#ifdef CONFIG_NF_CONNTRACK_EVENTS
	if (!no_ct) {
		pr_info("unreg nf_ct\n");
		nf_conntrack_unregister_notifier(&amp;klna_ct_notifier);
	}
#endif
}
</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="16:27:21000">
<Copy StartSeek="0" EndSeek="5089"/>
<Insert>//#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,26)
//static void klna_nc_pppox_get_sk(struct net_device *dev)
//{
//        int hash;
//
//        read_lock_bh(&amp;pppoe_hash_lock);
//        for (hash = 0; hash &lt; PPPOE_HASH_SIZE; hash++) {
//                struct pppox_sock *po = item_hash_table[hash];
//
//                while (po != NULL) {
//                        if (po-&gt;pppoe_dev == dev) {
//                                struct sock *sk = sk_pppox(po);
//
//                                sock_hold(sk);
//                                read_unlock_bh(&amp;pppoe_hash_lock);
//                                lock_sock(sk);
//
//                                if (sk-&gt;sk_state &amp;
//                                    (PPPOX_CONNECTED | PPPOX_BOUND)) {
//                                        pr_info("connected ch %d", ppp_channel_index(po-&gt;chan);
//                                }
//
//                                release_sock(sk);
//
//                                sock_put(sk);
//
//                                read_lock_bh(&amp;pppoe_hash_lock);
//
//                                /* Now restart from the beginning of this
//                                 * hash chain.  We always NULL out pppoe_dev
//                                 * so we are guaranteed to make forward
//                                 * progress.
//                                 */
//                                po = item_hash_table[hash];
//                                continue;
//                        }
//                        po = po-&gt;next;
//                }
//        }
//        read_unlock_bh(&amp;pppoe_hash_lock);
//}
//#else
//static void klna_nc_pppox_get_sk(struct net_device *dev)
//{
//        struct pppoe_net *pn;
//        int i;
//
//        pn = net_generic(dev_net(dev), pppoe_net_id);
//        if (!pn)
//                return;
//
//        write_lock_bh(&amp;pn-&gt;hash_lock);
//        for (i = 0; i &lt; PPPOE_HASH_SIZE; i++) {
//                struct pppox_sock *po = pn-&gt;hash_table[i];
//                struct sock *sk;
//
//                while (po) {
//                        while (po &amp;&amp; po-&gt;pppoe_dev != dev) {
//                                po = po-&gt;next;
//                        }
//
//                        if (!po)
//                                break;
//
//                        sk = sk_pppox(po);
//                        sock_hold(sk);
//                        lock_sock(sk);
//
//                        if (po-&gt;pppoe_dev == dev) {
//                                /* HAIM: matche, get the info !!! */
//                        }
//
//                        release_sock(sk);
//                        sock_put(sk);
//                }
//        }
//        write_unlock_bh(&amp;pn-&gt;hash_lock);
//
//}
//#endif /* KERNEL_VERSION 2.6.26 */
</Insert>
<Copy StartSeek="5089" EndSeek="8869"/>
</Delta>
<Delta Version="1" Comment="" NL="\10" Encoding="text" Date="2012/04/29" Time="17:15:35000">
<Copy StartSeek="0" EndSeek="7080"/>
<Insert>struct sock *klna_sk_alloc(int family, gfp_t priority,
		      struct proto *prot, int zero_it)
{
	struct sock *sk;
	if (family == PF_PPPOX) {
		printk(KERN_ERR "(%s:%d) request for pppox sock \n", __func__, __LINE__);
	}
	sk = org_sk_alloc(family, priority, prot,zero_it);
	return sk;
}

static void klna_restore_sk_alloc(void)
{
	spin_lock_irq(&amp;klna_lock);
	if (org_sk_alloc) {
		sk_alloc = org_sk_alloc;
	}
//      flush_icache_range((unsigned long)&amp;sk_alloc,
//      		   (unsigned long)&amp;sk_alloc + sizeof(*org_sk_alloc));
	spin_unlock_irq(&amp;klna_lock);
}

static int klna_steal_sk_alloc(void)
{
	spin_lock_irq(&amp;klna_lock);
	org_sk_alloc = &amp;sk_alloc;
	printk(KERN_ERR "(%s:%d) org_sk_alloc %p\n", __func__, __LINE__, org_sk_alloc);
	sk_alloc = klna_sk_alloc;
	spin_unlock_irq(&amp;klna_lock);
	return org_sk_alloc ? 0 : -ENOENT;
}

</Insert>
<Copy StartSeek="7080" EndSeek="8038"/>
</Delta>
<Delta Version="2" Comment="" NL="\10" Encoding="text" Date="2012/04/29" Time="17:16:3000">
<Copy StartSeek="0" EndSeek="7252"/>
<Insert>	err = klna_steal_sk_alloc();
	if (err) {
		printk(KERN_ERR "couldn't register pppox monitor\n");
		return err;
	}
</Insert>
<Copy StartSeek="7252" EndSeek="7923"/>
</Delta>
<Delta Version="3" Comment="" NL="\10" Encoding="text" Date="2012/04/29" Time="17:20:35000">
<Copy StartSeek="0" EndSeek="469"/>
<Insert>//#include &lt;linux/spinlock.h&gt;
</Insert>
<Copy StartSeek="469" EndSeek="7893"/>
</Delta>
<Delta Version="4" Comment="" NL="\10" Encoding="text" Date="2012/04/29" Time="17:31:33000">
<Copy StartSeek="0" EndSeek="5300"/>
<Copy StartSeek="5310" EndSeek="7903"/>
</Delta>
<Delta Version="5" Comment="" NL="\10" Encoding="text" Date="2012/04/29" Time="17:34:23000">
<Copy StartSeek="0" EndSeek="5301"/>
<Insert>	scan_ta
</Insert>
<Copy StartSeek="5322" EndSeek="7915"/>
</Delta>
<Delta Version="6" Comment="" NL="\10" Encoding="text" Date="2012/04/29" Time="17:34:53000">
<Copy StartSeek="0" EndSeek="823"/>
<Copy StartSeek="861" EndSeek="7953"/>
</Delta>
<Delta Version="7" Comment="" NL="\10" Encoding="text" Date="2012/04/29" Time="17:35:28000">
<Copy StartSeek="0" EndSeek="5339"/>
<Insert>	find_pppoe_socks();
</Insert>
<Copy StartSeek="5363" EndSeek="7956"/>
</Delta>
<Delta Version="8" Comment="" NL="\10" Encoding="text" Date="2012/04/29" Time="17:49:0000">
<Copy StartSeek="0" EndSeek="5339"/>
<Insert>	find_pppoe_socks(dev);
</Insert>
<Copy StartSeek="5367" EndSeek="7960"/>
</Delta>
<Delta Version="9" Comment="" NL="\10" Encoding="text" Date="2012/04/29" Time="17:50:10000">
<Copy StartSeek="0" EndSeek="875"/>
<Insert>#define pr_fmt(fmt)	"klna_nc: " fmt
</Insert>
<Copy StartSeek="911" EndSeek="7960"/>
</Delta>
<Delta Version="10" Comment="" NL="\10" Encoding="text" Date="2012/04/29" Time="18:20:37000">
<Copy StartSeek="0" EndSeek="5339"/>
<Insert>	find_dev_pppoe_socks(dev);
</Insert>
<Copy StartSeek="5339" EndSeek="5565"/>
<Copy StartSeek="5594" EndSeek="5661"/>
<Copy StartSeek="5690" EndSeek="7990"/>
</Delta>
<Delta Version="11" Comment="" NL="\10" Encoding="text" Date="2012/04/30" Time="18:53:40000">
<Copy StartSeek="0" EndSeek="5699"/>
<Copy StartSeek="5807" EndSeek="8098"/>
</Delta>
<Delta Version="12" Comment="" NL="\10" Encoding="text" Date="2012/05/01" Time="08:46:13000">
<Copy StartSeek="0" EndSeek="5724"/>
<Insert>		pr_info("dev %s goind down\n", dev-&gt;name);
</Insert>
<Copy StartSeek="5769" EndSeek="8098"/>
</Delta>
<Delta Version="13" Comment="" NL="\10" Encoding="text" Date="2012/05/01" Time="08:46:15000">
<Copy StartSeek="0" EndSeek="5338"/>
<Insert>
</Insert>
<Copy StartSeek="5366" EndSeek="8125"/>
</Delta>
<Delta Version="14" Comment="" NL="\10" Encoding="text" Date="2012/05/01" Time="08:48:34000">
<Copy StartSeek="0" EndSeek="5338"/>
<Insert>	find_dev_pppoe_socks(dev);
</Insert>
<Copy StartSeek="5339" EndSeek="8098"/>
</Delta>
</DeltaFile>
