<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="10" Comment="" Date="2012/08/13" Time="13:21:53000" NL="\10" Encoding="text">
<Insert>/*
 *  linux/arch/arm/mm/alignment.c
 *
 *  Copyright (C) 1995  Linus Torvalds
 *  Modifications for ARM processor (c) 1995-2001 Russell King
 *  Thumb alignment fault fixups (c) 2004 MontaVista Software, Inc.
 *  - Adapted from gdb/sim/arm/thumbemu.c -- Thumb instruction emulation.
 *    Copyright (C) 1996, Cygnus Software Technologies Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#include &lt;linux/compiler.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/uaccess.h&gt;

#include &lt;asm/unaligned.h&gt;

#include "fault.h"

/*
 * 32-bit misaligned trap handler (c) 1998 San Mehat (CCC) -July 1998
 * /proc/sys/debug/alignment, modified and integrated into
 * Linux 2.1 by Russell King
 *
 * Speed optimisations and better fault handling by Russell King.
 *
 * *** NOTE ***
 * This code is not portable to processors with late data abort handling.
 */
#define CODING_BITS(i)	(i &amp; 0x0e000000)

#define LDST_I_BIT(i)	(i &amp; (1 &lt;&lt; 26))		/* Immediate constant	*/
#define LDST_P_BIT(i)	(i &amp; (1 &lt;&lt; 24))		/* Preindex		*/
#define LDST_U_BIT(i)	(i &amp; (1 &lt;&lt; 23))		/* Add offset		*/
#define LDST_W_BIT(i)	(i &amp; (1 &lt;&lt; 21))		/* Writeback		*/
#define LDST_L_BIT(i)	(i &amp; (1 &lt;&lt; 20))		/* Load			*/

#define LDST_P_EQ_U(i)	((((i) ^ ((i) &gt;&gt; 1)) &amp; (1 &lt;&lt; 23)) == 0)

#define LDSTHD_I_BIT(i)	(i &amp; (1 &lt;&lt; 22))		/* double/half-word immed */
#define LDM_S_BIT(i)	(i &amp; (1 &lt;&lt; 22))		/* write CPSR from SPSR	*/

#define RN_BITS(i)	((i &gt;&gt; 16) &amp; 15)	/* Rn			*/
#define RD_BITS(i)	((i &gt;&gt; 12) &amp; 15)	/* Rd			*/
#define RM_BITS(i)	(i &amp; 15)		/* Rm			*/

#define REGMASK_BITS(i)	(i &amp; 0xffff)
#define OFFSET_BITS(i)	(i &amp; 0x0fff)

#define IS_SHIFT(i)	(i &amp; 0x0ff0)
#define SHIFT_BITS(i)	((i &gt;&gt; 7) &amp; 0x1f)
#define SHIFT_TYPE(i)	(i &amp; 0x60)
#define SHIFT_LSL	0x00
#define SHIFT_LSR	0x20
#define SHIFT_ASR	0x40
#define SHIFT_RORRRX	0x60

#define BAD_INSTR 	0xdeadc0de

/* Thumb-2 32 bit format per ARMv7 DDI0406A A6.3, either f800h,e800h,f800h */
#define IS_T32(hi16) \
	(((hi16) &amp; 0xe000) == 0xe000 &amp;&amp; ((hi16) &amp; 0x1800))

static unsigned long ai_user;
static unsigned long ai_sys;
static unsigned long ai_skipped;
static unsigned long ai_half;
static unsigned long ai_word;
static unsigned long ai_dword;
static unsigned long ai_multi;
static int ai_usermode = 2;

#define UM_WARN		(1 &lt;&lt; 0)
#define UM_FIXUP	(1 &lt;&lt; 1)
#define UM_SIGNAL	(1 &lt;&lt; 2)

#ifdef CONFIG_PROC_FS
static const char *usermode_action[] = {
	"ignored",
	"warn",
	"fixup",
	"fixup+warn",
	"signal",
	"signal+warn"
};

static int
proc_alignment_read(char *page, char **start, off_t off, int count, int *eof,
		    void *data)
{
	char *p = page;
	int len;

	p += sprintf(p, "User:\t\t%lu\n", ai_user);
	p += sprintf(p, "System:\t\t%lu\n", ai_sys);
	p += sprintf(p, "Skipped:\t%lu\n", ai_skipped);
	p += sprintf(p, "Half:\t\t%lu\n", ai_half);
	p += sprintf(p, "Word:\t\t%lu\n", ai_word);
	if (cpu_architecture() &gt;= CPU_ARCH_ARMv5TE)
		p += sprintf(p, "DWord:\t\t%lu\n", ai_dword);
	p += sprintf(p, "Multi:\t\t%lu\n", ai_multi);
	p += sprintf(p, "User faults:\t%i (%s)\n", ai_usermode,
			usermode_action[ai_usermode]);

	len = (p - page) - off;
	if (len &lt; 0)
		len = 0;

	*eof = (len &lt;= count) ? 1 : 0;
	*start = page + off;

	return len;
}

static int proc_alignment_write(struct file *file, const char __user *buffer,
				unsigned long count, void *data)
{
	char mode;

	if (count &gt; 0) {
		if (get_user(mode, buffer))
			return -EFAULT;
		if (mode &gt;= '0' &amp;&amp; mode &lt;= '5')
			ai_usermode = mode - '0';
	}
	return count;
}

#endif /* CONFIG_PROC_FS */

union offset_union {
	unsigned long un;
	  signed long sn;
};

#define TYPE_ERROR	0
#define TYPE_FAULT	1
#define TYPE_LDST	2
#define TYPE_DONE	3

#ifdef __ARMEB__
#define BE		1
#define FIRST_BYTE_16	"mov	%1, %1, ror #8\n"
#define FIRST_BYTE_32	"mov	%1, %1, ror #24\n"
#define NEXT_BYTE	"ror #24"
#else
#define BE		0
#define FIRST_BYTE_16
#define FIRST_BYTE_32
#define NEXT_BYTE	"lsr #8"
#endif

#define __get8_unaligned_check(ins,val,addr,err)	\
	__asm__(					\
 ARM(	"1:	"ins"	%1, [%2], #1\n"	)		\
 THUMB(	"1:	"ins"	%1, [%2]\n"	)		\
 THUMB(	"	add	%2, %2, #1\n"	)		\
	"2:\n"						\
	"	.section .fixup,\"ax\"\n"		\
	"	.align	2\n"				\
	"3:	mov	%0, #1\n"			\
	"	b	2b\n"				\
	"	.previous\n"				\
	"	.section __ex_table,\"a\"\n"		\
	"	.align	3\n"				\
	"	.long	1b, 3b\n"			\
	"	.previous\n"				\
	: "=r" (err), "=&amp;r" (val), "=r" (addr)		\
	: "0" (err), "2" (addr))

#define __get16_unaligned_check(ins,val,addr)			\
	do {							\
		unsigned int err = 0, v, a = addr;		\
		__get8_unaligned_check(ins,v,a,err);		\
		val =  v &lt;&lt; ((BE) ? 8 : 0);			\
		__get8_unaligned_check(ins,v,a,err);		\
		val |= v &lt;&lt; ((BE) ? 0 : 8);			\
		if (err)					\
			goto fault;				\
	} while (0)

#define get16_unaligned_check(val,addr) \
	__get16_unaligned_check("ldrb",val,addr)

#define get16t_unaligned_check(val,addr) \
	__get16_unaligned_check("ldrbt",val,addr)

#define __get32_unaligned_check(ins,val,addr)			\
	do {							\
		unsigned int err = 0, v, a = addr;		\
		__get8_unaligned_check(ins,v,a,err);		\
		val =  v &lt;&lt; ((BE) ? 24 :  0);			\
		__get8_unaligned_check(ins,v,a,err);		\
		val |= v &lt;&lt; ((BE) ? 16 :  8);			\
		__get8_unaligned_check(ins,v,a,err);		\
		val |= v &lt;&lt; ((BE) ?  8 : 16);			\
		__get8_unaligned_check(ins,v,a,err);		\
		val |= v &lt;&lt; ((BE) ?  0 : 24);			\
		if (err)					\
			goto fault;				\
	} while (0)

#define get32_unaligned_check(val,addr) \
	__get32_unaligned_check("ldrb",val,addr)

#define get32t_unaligned_check(val,addr) \
	__get32_unaligned_check("ldrbt",val,addr)

#define __put16_unaligned_check(ins,val,addr)			\
	do {							\
		unsigned int err = 0, v = val, a = addr;	\
		__asm__( FIRST_BYTE_16				\
	 ARM(	"1:	"ins"	%1, [%2], #1\n"	)		\
	 THUMB(	"1:	"ins"	%1, [%2]\n"	)		\
	 THUMB(	"	add	%2, %2, #1\n"	)		\
		"	mov	%1, %1, "NEXT_BYTE"\n"		\
		"2:	"ins"	%1, [%2]\n"			\
		"3:\n"						\
		"	.section .fixup,\"ax\"\n"		\
		"	.align	2\n"				\
		"4:	mov	%0, #1\n"			\
		"	b	3b\n"				\
		"	.previous\n"				\
		"	.section __ex_table,\"a\"\n"		\
		"	.align	3\n"				\
		"	.long	1b, 4b\n"			\
		"	.long	2b, 4b\n"			\
		"	.previous\n"				\
		: "=r" (err), "=&amp;r" (v), "=&amp;r" (a)		\
		: "0" (err), "1" (v), "2" (a));			\
		if (err)					\
			goto fault;				\
	} while (0)

#define put16_unaligned_check(val,addr)  \
	__put16_unaligned_check("strb",val,addr)

#define put16t_unaligned_check(val,addr) \
	__put16_unaligned_check("strbt",val,addr)

#define __put32_unaligned_check(ins,val,addr)			\
	do {							\
		unsigned int err = 0, v = val, a = addr;	\
		__asm__( FIRST_BYTE_32				\
	 ARM(	"1:	"ins"	%1, [%2], #1\n"	)		\
	 THUMB(	"1:	"ins"	%1, [%2]\n"	)		\
	 THUMB(	"	add	%2, %2, #1\n"	)		\
		"	mov	%1, %1, "NEXT_BYTE"\n"		\
	 ARM(	"2:	"ins"	%1, [%2], #1\n"	)		\
	 THUMB(	"2:	"ins"	%1, [%2]\n"	)		\
	 THUMB(	"	add	%2, %2, #1\n"	)		\
		"	mov	%1, %1, "NEXT_BYTE"\n"		\
	 ARM(	"3:	"ins"	%1, [%2], #1\n"	)		\
	 THUMB(	"3:	"ins"	%1, [%2]\n"	)		\
	 THUMB(	"	add	%2, %2, #1\n"	)		\
		"	mov	%1, %1, "NEXT_BYTE"\n"		\
		"4:	"ins"	%1, [%2]\n"			\
		"5:\n"						\
		"	.section .fixup,\"ax\"\n"		\
		"	.align	2\n"				\
		"6:	mov	%0, #1\n"			\
		"	b	5b\n"				\
		"	.previous\n"				\
		"	.section __ex_table,\"a\"\n"		\
		"	.align	3\n"				\
		"	.long	1b, 6b\n"			\
		"	.long	2b, 6b\n"			\
		"	.long	3b, 6b\n"			\
		"	.long	4b, 6b\n"			\
		"	.previous\n"				\
		: "=r" (err), "=&amp;r" (v), "=&amp;r" (a)		\
		: "0" (err), "1" (v), "2" (a));			\
		if (err)					\
			goto fault;				\
	} while (0)

#define put32_unaligned_check(val,addr) \
	__put32_unaligned_check("strb", val, addr)

#define put32t_unaligned_check(val,addr) \
	__put32_unaligned_check("strbt", val, addr)

static void
do_alignment_finish_ldst(unsigned long addr, unsigned long instr, struct pt_regs *regs, union offset_union offset)
{
	if (!LDST_U_BIT(instr))
		offset.un = -offset.un;

	if (!LDST_P_BIT(instr))
		addr += offset.un;

	if (!LDST_P_BIT(instr) || LDST_W_BIT(instr))
		regs-&gt;uregs[RN_BITS(instr)] = addr;
}

static int
do_alignment_ldrhstrh(unsigned long addr, unsigned long instr, struct pt_regs *regs)
{
	unsigned int rd = RD_BITS(instr);

	ai_half += 1;

	if (user_mode(regs))
		goto user;

	if (LDST_L_BIT(instr)) {
		unsigned long val;
		get16_unaligned_check(val, addr);

		/* signed half-word? */
		if (instr &amp; 0x40)
			val = (signed long)((signed short) val);

		regs-&gt;uregs[rd] = val;
	} else
		put16_unaligned_check(regs-&gt;uregs[rd], addr);

	return TYPE_LDST;

 user:
	if (LDST_L_BIT(instr)) {
		unsigned long val;
		get16t_unaligned_check(val, addr);

		/* signed half-word? */
		if (instr &amp; 0x40)
			val = (signed long)((signed short) val);

		regs-&gt;uregs[rd] = val;
	} else
		put16t_unaligned_check(regs-&gt;uregs[rd], addr);

	return TYPE_LDST;

 fault:
	return TYPE_FAULT;
}

static int
do_alignment_ldrdstrd(unsigned long addr, unsigned long instr,
		      struct pt_regs *regs)
{
	unsigned int rd = RD_BITS(instr);
	unsigned int rd2;
	int load;

	if ((instr &amp; 0xfe000000) == 0xe8000000) {
		/* ARMv7 Thumb-2 32-bit LDRD/STRD */
		rd2 = (instr &gt;&gt; 8) &amp; 0xf;
		load = !!(LDST_L_BIT(instr));
	} else if (((rd &amp; 1) == 1) || (rd == 14))
		goto bad;
	else {
		load = ((instr &amp; 0xf0) == 0xd0);
		rd2 = rd + 1;
	}

	ai_dword += 1;

	if (user_mode(regs))
		goto user;

	if (load) {
		unsigned long val;
		get32_unaligned_check(val, addr);
		regs-&gt;uregs[rd] = val;
		get32_unaligned_check(val, addr + 4);
		regs-&gt;uregs[rd2] = val;
	} else {
		put32_unaligned_check(regs-&gt;uregs[rd], addr);
		put32_unaligned_check(regs-&gt;uregs[rd2], addr + 4);
	}

	return TYPE_LDST;

 user:
	if (load) {
		unsigned long val;
		get32t_unaligned_check(val, addr);
		regs-&gt;uregs[rd] = val;
		get32t_unaligned_check(val, addr + 4);
		regs-&gt;uregs[rd2] = val;
	} else {
		put32t_unaligned_check(regs-&gt;uregs[rd], addr);
		put32t_unaligned_check(regs-&gt;uregs[rd2], addr + 4);
	}

	return TYPE_LDST;
 bad:
	return TYPE_ERROR;
 fault:
	return TYPE_FAULT;
}

static int
do_alignment_ldrstr(unsigned long addr, unsigned long instr, struct pt_regs *regs)
{
	unsigned int rd = RD_BITS(instr);

	ai_word += 1;

	if ((!LDST_P_BIT(instr) &amp;&amp; LDST_W_BIT(instr)) || user_mode(regs))
		goto trans;

	if (LDST_L_BIT(instr)) {
		unsigned int val;
		get32_unaligned_check(val, addr);
		regs-&gt;uregs[rd] = val;
	} else
		put32_unaligned_check(regs-&gt;uregs[rd], addr);
	return TYPE_LDST;

 trans:
	if (LDST_L_BIT(instr)) {
		unsigned int val;
		get32t_unaligned_check(val, addr);
		regs-&gt;uregs[rd] = val;
	} else
		put32t_unaligned_check(regs-&gt;uregs[rd], addr);
	return TYPE_LDST;

 fault:
	return TYPE_FAULT;
}

/*
 * LDM/STM alignment handler.
 *
 * There are 4 variants of this instruction:
 *
 * B = rn pointer before instruction, A = rn pointer after instruction
 *              ------ increasing address -----&gt;
 *	        |    | r0 | r1 | ... | rx |    |
 * PU = 01             B                    A
 * PU = 11        B                    A
 * PU = 00        A                    B
 * PU = 10             A                    B
 */
static int
do_alignment_ldmstm(unsigned long addr, unsigned long instr, struct pt_regs *regs)
{
	unsigned int rd, rn, correction, nr_regs, regbits;
	unsigned long eaddr, newaddr;

	if (LDM_S_BIT(instr))
		goto bad;

	correction = 4; /* processor implementation defined */
	regs-&gt;ARM_pc += correction;

	ai_multi += 1;

	/* count the number of registers in the mask to be transferred */
	nr_regs = hweight16(REGMASK_BITS(instr)) * 4;

	rn = RN_BITS(instr);
	newaddr = eaddr = regs-&gt;uregs[rn];

	if (!LDST_U_BIT(instr))
		nr_regs = -nr_regs;
	newaddr += nr_regs;
	if (!LDST_U_BIT(instr))
		eaddr = newaddr;

	if (LDST_P_EQ_U(instr))	/* U = P */
		eaddr += 4;

	/*
	 * For alignment faults on the ARM922T/ARM920T the MMU  makes
	 * the FSR (and hence addr) equal to the updated base address
	 * of the multiple access rather than the restored value.
	 * Switch this message off if we've got a ARM92[02], otherwise
	 * [ls]dm alignment faults are noisy!
	 */
#if !(defined CONFIG_CPU_ARM922T)  &amp;&amp; !(defined CONFIG_CPU_ARM920T)
	/*
	 * This is a "hint" - we already have eaddr worked out by the
	 * processor for us.
	 */
	if (addr != eaddr) {
		printk(KERN_ERR "LDMSTM: PC = %08lx, instr = %08lx, "
			"addr = %08lx, eaddr = %08lx\n",
			 instruction_pointer(regs), instr, addr, eaddr);
		show_regs(regs);
	}
#endif

	if (user_mode(regs)) {
		for (regbits = REGMASK_BITS(instr), rd = 0; regbits;
		     regbits &gt;&gt;= 1, rd += 1)
			if (regbits &amp; 1) {
				if (LDST_L_BIT(instr)) {
					unsigned int val;
					get32t_unaligned_check(val, eaddr);
					regs-&gt;uregs[rd] = val;
				} else
					put32t_unaligned_check(regs-&gt;uregs[rd], eaddr);
				eaddr += 4;
			}
	} else {
		for (regbits = REGMASK_BITS(instr), rd = 0; regbits;
		     regbits &gt;&gt;= 1, rd += 1)
			if (regbits &amp; 1) {
				if (LDST_L_BIT(instr)) {
					unsigned int val;
					get32_unaligned_check(val, eaddr);
					regs-&gt;uregs[rd] = val;
				} else
					put32_unaligned_check(regs-&gt;uregs[rd], eaddr);
				eaddr += 4;
			}
	}

	if (LDST_W_BIT(instr))
		regs-&gt;uregs[rn] = newaddr;
	if (!LDST_L_BIT(instr) || !(REGMASK_BITS(instr) &amp; (1 &lt;&lt; 15)))
		regs-&gt;ARM_pc -= correction;
	return TYPE_DONE;

fault:
	regs-&gt;ARM_pc -= correction;
	return TYPE_FAULT;

bad:
	printk(KERN_ERR "Alignment trap: not handling ldm with s-bit set\n");
	return TYPE_ERROR;
}

/*
 * Convert Thumb ld/st instruction forms to equivalent ARM instructions so
 * we can reuse ARM userland alignment fault fixups for Thumb.
 *
 * This implementation was initially based on the algorithm found in
 * gdb/sim/arm/thumbemu.c. It is basically just a code reduction of same
 * to convert only Thumb ld/st instruction forms to equivalent ARM forms.
 *
 * NOTES:
 * 1. Comments below refer to ARM ARM DDI0100E Thumb Instruction sections.
 * 2. If for some reason we're passed an non-ld/st Thumb instruction to
 *    decode, we return 0xdeadc0de. This should never happen under normal
 *    circumstances but if it does, we've got other problems to deal with
 *    elsewhere and we obviously can't fix those problems here.
 */

static unsigned long
thumb2arm(u16 tinstr)
{
	u32 L = (tinstr &amp; (1&lt;&lt;11)) &gt;&gt; 11;

	switch ((tinstr &amp; 0xf800) &gt;&gt; 11) {
	/* 6.5.1 Format 1: */
	case 0x6000 &gt;&gt; 11:				/* 7.1.52 STR(1) */
	case 0x6800 &gt;&gt; 11:				/* 7.1.26 LDR(1) */
	case 0x7000 &gt;&gt; 11:				/* 7.1.55 STRB(1) */
	case 0x7800 &gt;&gt; 11:				/* 7.1.30 LDRB(1) */
		return 0xe5800000 |
			((tinstr &amp; (1&lt;&lt;12)) &lt;&lt; (22-12)) |	/* fixup */
			(L&lt;&lt;20) |				/* L==1? */
			((tinstr &amp; (7&lt;&lt;0)) &lt;&lt; (12-0)) |		/* Rd */
			((tinstr &amp; (7&lt;&lt;3)) &lt;&lt; (16-3)) |		/* Rn */
			((tinstr &amp; (31&lt;&lt;6)) &gt;&gt;			/* immed_5 */
				(6 - ((tinstr &amp; (1&lt;&lt;12)) ? 0 : 2)));
	case 0x8000 &gt;&gt; 11:				/* 7.1.57 STRH(1) */
	case 0x8800 &gt;&gt; 11:				/* 7.1.32 LDRH(1) */
		return 0xe1c000b0 |
			(L&lt;&lt;20) |				/* L==1? */
			((tinstr &amp; (7&lt;&lt;0)) &lt;&lt; (12-0)) |		/* Rd */
			((tinstr &amp; (7&lt;&lt;3)) &lt;&lt; (16-3)) |		/* Rn */
			((tinstr &amp; (7&lt;&lt;6)) &gt;&gt; (6-1)) |	 /* immed_5[2:0] */
			((tinstr &amp; (3&lt;&lt;9)) &gt;&gt; (9-8));	 /* immed_5[4:3] */

	/* 6.5.1 Format 2: */
	case 0x5000 &gt;&gt; 11:
	case 0x5800 &gt;&gt; 11:
		{
			static const u32 subset[8] = {
				0xe7800000,		/* 7.1.53 STR(2) */
				0xe18000b0,		/* 7.1.58 STRH(2) */
				0xe7c00000,		/* 7.1.56 STRB(2) */
				0xe19000d0,		/* 7.1.34 LDRSB */
				0xe7900000,		/* 7.1.27 LDR(2) */
				0xe19000b0,		/* 7.1.33 LDRH(2) */
				0xe7d00000,		/* 7.1.31 LDRB(2) */
				0xe19000f0		/* 7.1.35 LDRSH */
			};
			return subset[(tinstr &amp; (7&lt;&lt;9)) &gt;&gt; 9] |
			    ((tinstr &amp; (7&lt;&lt;0)) &lt;&lt; (12-0)) |	/* Rd */
			    ((tinstr &amp; (7&lt;&lt;3)) &lt;&lt; (16-3)) |	/* Rn */
			    ((tinstr &amp; (7&lt;&lt;6)) &gt;&gt; (6-0));	/* Rm */
		}

	/* 6.5.1 Format 3: */
	case 0x4800 &gt;&gt; 11:				/* 7.1.28 LDR(3) */
		/* NOTE: This case is not technically possible. We're
		 *	 loading 32-bit memory data via PC relative
		 *	 addressing mode. So we can and should eliminate
		 *	 this case. But I'll leave it here for now.
		 */
		return 0xe59f0000 |
		    ((tinstr &amp; (7&lt;&lt;8)) &lt;&lt; (12-8)) |		/* Rd */
		    ((tinstr &amp; 255) &lt;&lt; (2-0));			/* immed_8 */

	/* 6.5.1 Format 4: */
	case 0x9000 &gt;&gt; 11:				/* 7.1.54 STR(3) */
	case 0x9800 &gt;&gt; 11:				/* 7.1.29 LDR(4) */
		return 0xe58d0000 |
			(L&lt;&lt;20) |				/* L==1? */
			((tinstr &amp; (7&lt;&lt;8)) &lt;&lt; (12-8)) |		/* Rd */
			((tinstr &amp; 255) &lt;&lt; 2);			/* immed_8 */

	/* 6.6.1 Format 1: */
	case 0xc000 &gt;&gt; 11:				/* 7.1.51 STMIA */
	case 0xc800 &gt;&gt; 11:				/* 7.1.25 LDMIA */
		{
			u32 Rn = (tinstr &amp; (7&lt;&lt;8)) &gt;&gt; 8;
			u32 W = ((L&lt;&lt;Rn) &amp; (tinstr&amp;255)) ? 0 : 1&lt;&lt;21;

			return 0xe8800000 | W | (L&lt;&lt;20) | (Rn&lt;&lt;16) |
				(tinstr&amp;255);
		}

	/* 6.6.1 Format 2: */
	case 0xb000 &gt;&gt; 11:				/* 7.1.48 PUSH */
	case 0xb800 &gt;&gt; 11:				/* 7.1.47 POP */
		if ((tinstr &amp; (3 &lt;&lt; 9)) == 0x0400) {
			static const u32 subset[4] = {
				0xe92d0000,	/* STMDB sp!,{registers} */
				0xe92d4000,	/* STMDB sp!,{registers,lr} */
				0xe8bd0000,	/* LDMIA sp!,{registers} */
				0xe8bd8000	/* LDMIA sp!,{registers,pc} */
			};
			return subset[(L&lt;&lt;1) | ((tinstr &amp; (1&lt;&lt;8)) &gt;&gt; 8)] |
			    (tinstr &amp; 255);		/* register_list */
		}
		/* Else fall through for illegal instruction case */

	default:
		return BAD_INSTR;
	}
}

/*
 * Convert Thumb-2 32 bit LDM, STM, LDRD, STRD to equivalent instruction
 * handlable by ARM alignment handler, also find the corresponding handler,
 * so that we can reuse ARM userland alignment fault fixups for Thumb.
 *
 * @pinstr: original Thumb-2 instruction; returns new handlable instruction
 * @regs: register context.
 * @poffset: return offset from faulted addr for later writeback
 *
 * NOTES:
 * 1. Comments below refer to ARMv7 DDI0406A Thumb Instruction sections.
 * 2. Register name Rt from ARMv7 is same as Rd from ARMv6 (Rd is Rt)
 */
static void *
do_alignment_t32_to_handler(unsigned long *pinstr, struct pt_regs *regs,
			    union offset_union *poffset)
{
	unsigned long instr = *pinstr;
	u16 tinst1 = (instr &gt;&gt; 16) &amp; 0xffff;
	u16 tinst2 = instr &amp; 0xffff;
	poffset-&gt;un = 0;

	switch (tinst1 &amp; 0xffe0) {
	/* A6.3.5 Load/Store multiple */
	case 0xe880:		/* STM/STMIA/STMEA,LDM/LDMIA, PUSH/POP T2 */
	case 0xe8a0:		/* ...above writeback version */
	case 0xe900:		/* STMDB/STMFD, LDMDB/LDMEA */
	case 0xe920:		/* ...above writeback version */
		/* no need offset decision since handler calculates it */
		return do_alignment_ldmstm;

	case 0xf840:		/* POP/PUSH T3 (single register) */
		if (RN_BITS(instr) == 13 &amp;&amp; (tinst2 &amp; 0x09ff) == 0x0904) {
			u32 L = !!(LDST_L_BIT(instr));
			const u32 subset[2] = {
				0xe92d0000,	/* STMDB sp!,{registers} */
				0xe8bd0000,	/* LDMIA sp!,{registers} */
			};
			*pinstr = subset[L] | (1&lt;&lt;RD_BITS(instr));
			return do_alignment_ldmstm;
		}
		/* Else fall through for illegal instruction case */
		break;

	/* A6.3.6 Load/store double, STRD/LDRD(immed, lit, reg) */
	case 0xe860:
	case 0xe960:
	case 0xe8e0:
	case 0xe9e0:
		poffset-&gt;un = (tinst2 &amp; 0xff) &lt;&lt; 2;
	case 0xe940:
	case 0xe9c0:
		return do_alignment_ldrdstrd;

	/*
	 * No need to handle load/store instructions up to word size
	 * since ARMv6 and later CPUs can perform unaligned accesses.
	 */
	default:
		break;
	}
	return NULL;
}

static int
do_alignment(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
{
	union offset_union offset;
	unsigned long instr = 0, instrptr;
	int (*handler)(unsigned long addr, unsigned long instr, struct pt_regs *regs);
	unsigned int type;
	mm_segment_t fs;
	unsigned int fault;
	u16 tinstr = 0;
	int isize = 4;
	int thumb2_32b = 0;

	instrptr = instruction_pointer(regs);

	fs = get_fs();
	set_fs(KERNEL_DS);
	if (thumb_mode(regs)) {
		fault = __get_user(tinstr, (u16 *)(instrptr &amp; ~1));
		if (!fault) {
			if (cpu_architecture() &gt;= CPU_ARCH_ARMv7 &amp;&amp;
			    IS_T32(tinstr)) {
				/* Thumb-2 32-bit */
				u16 tinst2 = 0;
				fault = __get_user(tinst2, (u16 *)(instrptr+2));
				instr = (tinstr &lt;&lt; 16) | tinst2;
				thumb2_32b = 1;
			} else {
				isize = 2;
				instr = thumb2arm(tinstr);
			}
		}
	} else
		fault = __get_user(instr, (u32 *)instrptr);
	set_fs(fs);

	if (fault) {
		type = TYPE_FAULT;
		goto bad_or_fault;
	}

	if (user_mode(regs))
		goto user;

	ai_sys += 1;

 fixup:

	regs-&gt;ARM_pc += isize;

	switch (CODING_BITS(instr)) {
	case 0x00000000:	/* 3.13.4 load/store instruction extensions */
		if (LDSTHD_I_BIT(instr))
			offset.un = (instr &amp; 0xf00) &gt;&gt; 4 | (instr &amp; 15);
		else
			offset.un = regs-&gt;uregs[RM_BITS(instr)];

		if ((instr &amp; 0x000000f0) == 0x000000b0 || /* LDRH, STRH */
		    (instr &amp; 0x001000f0) == 0x001000f0)   /* LDRSH */
			handler = do_alignment_ldrhstrh;
		else if ((instr &amp; 0x001000f0) == 0x000000d0 || /* LDRD */
			 (instr &amp; 0x001000f0) == 0x000000f0)   /* STRD */
			handler = do_alignment_ldrdstrd;
		else if ((instr &amp; 0x01f00ff0) == 0x01000090) /* SWP */
			goto swp;
		else
			goto bad;
		break;

	case 0x04000000:	/* ldr or str immediate */
		offset.un = OFFSET_BITS(instr);
		handler = do_alignment_ldrstr;
		break;

	case 0x06000000:	/* ldr or str register */
		offset.un = regs-&gt;uregs[RM_BITS(instr)];

		if (IS_SHIFT(instr)) {
			unsigned int shiftval = SHIFT_BITS(instr);

			switch(SHIFT_TYPE(instr)) {
			case SHIFT_LSL:
				offset.un &lt;&lt;= shiftval;
				break;

			case SHIFT_LSR:
				offset.un &gt;&gt;= shiftval;
				break;

			case SHIFT_ASR:
				offset.sn &gt;&gt;= shiftval;
				break;

			case SHIFT_RORRRX:
				if (shiftval == 0) {
					offset.un &gt;&gt;= 1;
					if (regs-&gt;ARM_cpsr &amp; PSR_C_BIT)
						offset.un |= 1 &lt;&lt; 31;
				} else
					offset.un = offset.un &gt;&gt; shiftval |
							  offset.un &lt;&lt; (32 - shiftval);
				break;
			}
		}
		handler = do_alignment_ldrstr;
		break;

	case 0x08000000:	/* ldm or stm, or thumb-2 32bit instruction */
		if (thumb2_32b)
			handler = do_alignment_t32_to_handler(&amp;instr, regs, &amp;offset);
		else
			handler = do_alignment_ldmstm;
		break;

	default:
		goto bad;
	}

	if (!handler)
		goto bad;
	type = handler(addr, instr, regs);

	if (type == TYPE_ERROR || type == TYPE_FAULT) {
		regs-&gt;ARM_pc -= isize;
		goto bad_or_fault;
	}

	if (type == TYPE_LDST)
		do_alignment_finish_ldst(addr, instr, regs, offset);

	return 0;

 bad_or_fault:
	if (type == TYPE_ERROR)
		goto bad;
	/*
	 * We got a fault - fix it up, or die.
	 */
	do_bad_area(addr, fsr, regs);
	return 0;

 swp:
	printk(KERN_ERR "Alignment trap: not handling swp instruction\n");

 bad:
	/*
	 * Oops, we didn't handle the instruction.
	 */
	printk(KERN_ERR "Alignment trap: not handling instruction "
		"%0*lx at [&lt;%08lx&gt;]\n",
		isize &lt;&lt; 1,
		isize == 2 ? tinstr : instr, instrptr);
	ai_skipped += 1;
	return 1;

 user:
	ai_user += 1;

	if (ai_usermode &amp; UM_WARN)
		printk("Alignment trap: %s (%d) PC=0x%08lx Instr=0x%0*lx "
		       "Address=0x%08lx FSR 0x%03x\n", current-&gt;comm,
			task_pid_nr(current), instrptr,
			isize &lt;&lt; 1,
			isize == 2 ? tinstr : instr,
		        addr, fsr);

	if (ai_usermode &amp; UM_FIXUP)
		goto fixup;

	if (ai_usermode &amp; UM_SIGNAL)
		force_sig(SIGBUS, current);
	else
		set_cr(cr_no_alignment);

	return 0;
}

/*
 * This needs to be done after sysctl_init, otherwise sys/ will be
 * overwritten.  Actually, this shouldn't be in sys/ at all since
 * it isn't a sysctl, and it doesn't contain sysctl information.
 * We now locate it in /proc/cpu/alignment instead.
 */
static int __init alignment_init(void)
{
#ifdef CONFIG_PROC_FS
	struct proc_dir_entry *res;

	res = proc_mkdir("cpu", NULL);
	if (!res)
		return -ENOMEM;

	res = create_proc_entry("alignment", S_IWUSR | S_IRUGO, res);
	if (!res)
		return -ENOMEM;

	res-&gt;read_proc = proc_alignment_read;
	res-&gt;write_proc = proc_alignment_write;
#endif

	/*
	 * ARMv6 and later CPUs can perform unaligned accesses for
	 * most single load and store instructions up to word size.
	 * LDM, STM, LDRD and STRD still need to be handled.
	 *
	 * Ignoring the alignment fault is not an option on these
	 * CPUs since we spin re-faulting the instruction without
	 * making any progress.
	 */
	if (cpu_architecture() &gt;= CPU_ARCH_ARMv6 &amp;&amp; (cr_alignment &amp; CR_U)) {
		cr_alignment &amp;= ~CR_A;
		cr_no_alignment &amp;= ~CR_A;
		set_cr(cr_alignment);
		ai_usermode = UM_FIXUP;
	}

	hook_fault_code(1, do_alignment, SIGILL, "alignment exception");
	hook_fault_code(3, do_alignment, SIGILL, "alignment exception");

	return 0;
}

fs_initcall(alignment_init);

</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2012/08/13" Time="10:47:9000">
<Copy StartSeek="0" EndSeek="2398"/>
<Insert>unsigned long ai_word;
</Insert>
<Copy StartSeek="2423" EndSeek="24190"/>
</Delta>
<Delta Version="1" Comment="" NL="\10" Encoding="text" Date="2012/08/13" Time="11:01:48000">
<Copy StartSeek="0" EndSeek="2398"/>
<Insert>//unsigned long ai_word;
</Insert>
<Copy StartSeek="2421" EndSeek="24188"/>
</Delta>
<Delta Version="2" Comment="" NL="\10" Encoding="text" Date="2012/08/13" Time="11:03:7000">
<Copy StartSeek="0" EndSeek="24164"/>
<Insert>EXPORT_SYMBOL(ai_word);
</Insert>
</Delta>
<Delta Version="3" Comment="" NL="\10" Encoding="text" Date="2012/08/13" Time="11:03:12000">
<Copy StartSeek="0" EndSeek="24135"/>
<Copy StartSeek="24188" EndSeek="24245"/>
</Delta>
<Delta Version="4" Comment="" NL="\10" Encoding="text" Date="2012/08/13" Time="11:03:31000">
<Copy StartSeek="0" EndSeek="24188"/>
<Copy StartSeek="24189" EndSeek="24246"/>
</Delta>
<Delta Version="5" Comment="" NL="\10" Encoding="text" Date="2012/08/13" Time="11:03:32000">
<Copy StartSeek="0" EndSeek="24218"/>
<Insert>EXPORT_SYMBOL(get_ai_word);
</Insert>
</Delta>
<Delta Version="6" Comment="" NL="\10" Encoding="text" Date="2012/08/13" Time="11:10:33000">
<Copy StartSeek="0" EndSeek="24135"/>
<Insert>unsigned long get_ai_word(void)
{
	return ai_word;
}

</Insert>
<Copy StartSeek="24135" EndSeek="24164"/>
</Delta>
<Delta Version="7" Comment="" NL="\10" Encoding="text" Date="2012/08/13" Time="11:10:39000">
<Copy StartSeek="0" EndSeek="24164"/>
</Delta>
<Delta Version="8" Comment="" NL="\10" Encoding="text" Date="2012/08/13" Time="11:11:49000">
<Copy StartSeek="0" EndSeek="24164"/>
<Insert>EXPORT_SYMBOL(ai_word);
</Insert>
</Delta>
<Delta Version="9" Comment="" NL="\10" Encoding="text" Date="2012/08/13" Time="13:21:43000">
<Copy StartSeek="0" EndSeek="2366"/>
<Insert>//static unsigned long ai_word;
unsigned long ai_word;
</Insert>
<Copy StartSeek="2396" EndSeek="24140"/>
</Delta>
</DeltaFile>
