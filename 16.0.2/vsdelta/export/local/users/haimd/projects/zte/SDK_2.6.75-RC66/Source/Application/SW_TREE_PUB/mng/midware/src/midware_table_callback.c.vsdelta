<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="1" Comment="" Date="2013/06/10" Time="19:22:21000" NL="\10" Encoding="text">
<Insert>/*******************************************************************************
*               Copyright 2009, Marvell Technology Group Ltd.
*
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL. NO RIGHTS ARE GRANTED
* HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT OF MARVELL OR ANY THIRD
* PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE DISCRETION TO REQUEST THAT THIS
* CODE BE IMMEDIATELY RETURNED TO MARVELL. THIS CODE IS PROVIDED "AS IS".
* MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED OR OTHERWISE, REGARDING ITS
* ACCURACY, COMPLETENESS OR PERFORMANCE. MARVELL COMPRISES MARVELL TECHNOLOGY
* GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, MARVELL INTERNATIONAL LTD. (MIL),
* MARVELL TECHNOLOGY, INC. (MTI), MARVELL SEMICONDUCTOR, INC. (MSI), MARVELL
* ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K. (MJKK), GALILEO TECHNOLOGY LTD. (GTL)
* GALILEO TECHNOLOGY, INC. (GTI) AND RADLAN Computer Communications, LTD.
********************************************************************************
* tpm_mod.c
*
* DESCRIPTION:
*
* DEPENDENCIES:
*               None
*
* CREATED BY:   JingHua
*
* DATE CREATED:
*
* FILE REVISION NUMBER:
*               $Revision: 1.51 $
*
*
*******************************************************************************/
#include &lt;sys/socket.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;netinet/if_ether.h&gt;
#include &lt;net/if.h&gt;
#include &lt;linux/sockios.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;net/route.h&gt;

#include &lt;sys/time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;memory.h&gt;
#include &lt;malloc.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include "sqlite3.h"
#include "globals.h"

#include "midware_expo.h"
#include "midware_api.h"
#include "midware_sql_translate.h"
#include "midware_table_callback.h"
#include "midware_table_def.h"

#include "ponOnuMngIf.h"

#include "tpm_types.h"
#include "tpm_api.h"
#include "rstp_api.h"
#include "voip_api.h"
#include "igmp_api.h"
//#include "oam_stack_comm.h"
//#include "oam_stack_ossl.h"
#include "oam_stack_type_expo.h"
//#include "oam_stack_alarm.h"
//#include "oam_tl_alarm.h"
#include "oam_ret_val.h"

#include "FlashExports.h"
#include "I2cMain.h"
#include "apm_types.h"
#include "apm_alarm_api.h"
#include "apm_pm_api.h"
#include "apm_avc_api.h"
#include "OmciExtern.h"





typedef enum{
    MDW_MC_VLAN_UPDATE = 0,
    MDW_MC_VLAN_INSETT,
    MDW_MC_VLAN_REMOVE
} MIDWARE_MC_VLAN_OPERATION;


//typedef UINT32 STATUS;
UINT32 midware_onu_up_time = 0;
INT32 is_support_onu_xvr_I2c = 0;
const char* network_if_name[]=
{
    "pon0",
    "eth0"
};

static char *configuration_src    = "/etc/xml_params/sipapp.xml";
static char *configuration_dst    = "/etc/xml_params/sipapp.xml";
static char *sip_application      = "sipapp";
static char *sip_application_path = "/usr/bin/";

extern tpm_init_pon_type_t wanTech;

extern MIDWARE_TABLE_INFO *midware_get_table_info(MIDWARE_TABLE_ID_E table_id);
extern UINT32 midware_sqlite3_get_entry_size(MIDWARE_TABLE_INFO *table_info);
extern UINT32 midware_sqlite3_get_entry_count(MIDWARE_TABLE_ID_E table_id);
extern ONU_STATUS midware_sqlite3_get_insert_sql_prepared(MIDWARE_TABLE_INFO *table_info, void *entry);
extern ONU_STATUS midware_sqlite3_get_select_sql_prepared(MIDWARE_TABLE_INFO *table_info, void *entry);

extern void  midware_sqlite3_print_entry(MIDWARE_TABLE_ID_E table_id, void *entry);
static BOOL readImageVersion(char *version, int length);

extern bool omci_report_alarm(OMCI_REPORT_ALARM_MSG_S *alarmMsg);
extern bool omci_report_avc(OMCI_REPORT_AVC_MSG_S *avcMsg);
extern bool omci_report_pm(OMCI_REPORT_PM_MSG_S *pmMsg);

extern STATUS oam_tl_alarm_generate(UINT32 alarm_type, UINT32 param1, UINT32 param2, OAM_ALARM_REPORT_STATE_E state,UINT32 alarm_val);
extern STATUS oam_tl_avc_generate(UINT32 avc_type, UINT32 param1, UINT32 param2, UINT32 avc_val);


static void  midware_Synchronize_TCA();

#if 0
STATUS oam_alarm_generate(UINT32 alarm_type, UINT32 param1, UINT32 param2, OAM_ALARM_REPORT_STATE_E state,UINT32 alarm_val)
{
    return ONU_OK;
}

STATUS oam_avc_generate(UINT32 avc_type, UINT32 param1, UINT32 param2, UINT32 avc_val)
{
    MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"oam_avc_generate avc type 0x%x param1 0x%x param2 0x%x value %d\r\n", avc_type, param1, param2, avc_val);
    return ONU_OK;
}
#endif


/******************************************************************************
 *
 * Function   : midware_restart_mmp_app
 *
 * Description: This routine restarts the MMP application.
 *                1. It removes old result file
 *                2. It gets the PID of the MMP process via "ps" - it is placed
 *                   in the result file
 *                3. It takes the PID from the result file and kills process
 *                4. It restarts the MMP application
 *
 * Returns    : OMCIPROCSTATUS
 *
 ******************************************************************************/

static void midware_restart_mmp_app()
{
    char buf[120];

    sprintf(buf, "killall %s; usleep 500000; %s%s -f %s -d 1", sip_application, sip_application_path, sip_application, configuration_dst);
    MDW_DEBUG(MIDWARE_TRACE_LEVEL_INFO, "%s: 2 ***** %s ******\n\r", __FUNCTION__, buf);
    system(buf);
}

ONU_STATUS midware_table_restore(MIDWARE_TABLE_ID_E table_id)
{
    MIDWARE_TABLE_INFO *table_info;
    UINT32    entry_size;
    UINT32    entry_num;
    UINT8    *entry_p;
    UINT32    *bitmap_p;
    ONU_STATUS      rc;
    UINT8 col_num =0;
    UINT32 index_entry_num =0;
    UINT32  bitmap=0;

    /*
    restore all the entries in table
    1. get all the entries
    2. update all the entries
  */

    table_info = midware_get_table_info(table_id);

    entry_num = midware_sqlite3_get_entry_count(table_id);
    entry_size = midware_sqlite3_get_entry_size(table_info);

    entry_p = malloc(entry_num * entry_size);
    if(0 == entry_p)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't malloc mem for size: %ld\n", entry_num * entry_size);
        return ONU_FAIL;
    }

    bitmap_p = malloc(entry_num * sizeof(UINT32));
    if(0 == bitmap_p)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't malloc mem for size: %ld\n", entry_num * sizeof(UINT32));
        free(entry_p);
        return ONU_FAIL;
    }
    //memset(bitmap_p, 0xff, entry_num * sizeof(UINT32));


    for(col_num=0;col_num&lt;table_info-&gt;col_num;col_num++)
    {
        if(table_info-&gt;col_info[col_num].save_to_flash)
        {
            bitmap |= 1&lt;&lt;col_num;
        }
    }

    for(index_entry_num=0;index_entry_num&lt;entry_num;index_entry_num++)
    {
        *(bitmap_p+index_entry_num) = bitmap;
    }

    rc = midware_sqlite3_get_all_entry(table_id, &amp;entry_num, entry_p);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get all entries for table: %d\n", table_id);
        free(entry_p);
        free(bitmap_p);
        return ONU_FAIL;
    }

    rc = midware_sqlite3_update_group_entry(table_id, entry_num, bitmap_p, entry_p);

    free(entry_p);
    free(bitmap_p);

    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't update all entries for table: %d\n", table_id);
        return ONU_FAIL;
    }

    return ONU_OK;
}

///////////////////////////////////////////////
//MIDWARE_TABLE_ONU_INFO
///////////////////////////////////////////////

ONU_STATUS midware_table_onu_info_init(void)
{
    MIDWARE_TABLE_ONU_INFO_T OnuInfo;
    ONU_STATUS rc;
    MIDWARE_TABLE_INFO *table_info;
    char *vendor_id = MIDWARE_SFU_VENDOR_ID;
    char *module_id = MIDWARE_SFU_MODULE_ID;
    char *hardware_version = MIDWARE_SFU_HARDWARE_VERSION;
    char *software_version = MIDWARE_SFU_SOFTWARE_VERSION;
    UINT8 firmware_version[MIDWARE_FW_VERSION_LEN] = MIDWARE_SFU_FIRMWARE_VERSION;
    char *chip_id = MIDWARE_SFU_CHIP_ID;
    UINT8 chip_version[MIDWARE_CHIP_VER_LEN] = MIDWARE_SFU_CHIP_VERSION;
    char *sn = MIDWARE_SFU_SN;
    struct timeval tv1;

    //get all the attr from XML
    //for now, there is no XML
    memset(&amp;OnuInfo,0,sizeof(OnuInfo));
    memcpy(&amp;OnuInfo.vendor_id, vendor_id, sizeof(OnuInfo.vendor_id));
    memcpy(&amp;OnuInfo.onu_model, module_id, sizeof(OnuInfo.onu_model));
    memcpy(&amp;OnuInfo.hw_ver, hardware_version, sizeof(OnuInfo.hw_ver));
    readImageVersion(OnuInfo.sw_ver,sizeof(OnuInfo.sw_ver)-1);
    if(strlen(OnuInfo.sw_ver) == 0)
    {
    memcpy(&amp;OnuInfo.sw_ver, software_version, sizeof(OnuInfo.sw_ver));
    }
    memcpy(&amp;OnuInfo.fw_ver, firmware_version, sizeof(OnuInfo.fw_ver));
    memcpy(&amp;OnuInfo.chip_id, chip_id, sizeof(OnuInfo.chip_id));
    OnuInfo.chip_model = MIDWARE_SFU_CHIP_MODEL;
    OnuInfo.chip_rev = MIDWARE_SFU_CHIP_REV;
    memcpy(&amp;OnuInfo.chip_ver, chip_version, sizeof(OnuInfo.chip_ver));
    memcpy(&amp;OnuInfo.sn, sn, sizeof(OnuInfo.sn));

    OnuInfo.ge_port_num = MIDWARE_SFU_GE_PORT_NUM;
    OnuInfo.ge_port_bitmap = MIDWARE_SFU_GE_PORT_BITMAP;
    OnuInfo.fe_port_num = MIDWARE_SFU_FE_PORT_NUM;
    OnuInfo.fe_port_bitmap = MIDWARE_SFU_FE_PORT_BITMAP;
    OnuInfo.pots_port_num = MIDWARE_SFU_POTS_PORT_NUM;
    OnuInfo.e1_port_num = MIDWARE_SFU_E1_PORT_NUM;
    OnuInfo.wlan_port_num = MIDWARE_SFU_WLAN_PORT_NUM;
    OnuInfo.usb_port_num = MIDWARE_SFU_USB_PORT_NUM;
    OnuInfo.us_queue_num = MIDWARE_SFU_UPSTREAM_QUEUES_NUMBER;
    OnuInfo.us_queue_num_per_port = MIDWARE_SFU_UPSTREAM_QUEUES_PER_PORT;
    OnuInfo.ds_queue_num = MIDWARE_SFU_DOWNSTREAM_QUEUES_NUMBER;
    OnuInfo.ds_queue_num_per_port = MIDWARE_SFU_DOWNSTREAM_QUEUES_PER_PORT;
    OnuInfo.battery_backup = 0;
    OnuInfo.onu_type = 0;
    OnuInfo.llid_num = MIDWARE_SFU_LLID_NUM;
    OnuInfo.queue_num_per_llid = MIDWARE_SFU_QUEUE_NUM_PER_LLID;
    OnuInfo.ipv6_support = 0;
    OnuInfo.power_control = 0;

    gettimeofday(&amp;tv1,0);
    OnuInfo.onu_up_time = tv1.tv_sec;
    midware_onu_up_time = tv1.tv_sec;

    //insert the entry into SQLite
    table_info = midware_get_table_info(MIDWARE_TABLE_ONU_INFO);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;OnuInfo);
     if(ONU_FAIL == rc)
     {
         MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entry\n");
         return ONU_FAIL;
     }

     return ONU_OK;
}
MIDWARE_CALLBACK_RET midware_table_onu_info_get(UINT32 bitmap, void *entry)
{
    struct timeval tv1;
    MIDWARE_TABLE_ONU_INFO_T *OnuInfo;

    OnuInfo = (MIDWARE_TABLE_ONU_INFO_T*)entry;

    if(bitmap &amp; MIDWARE_ENTRY_ONU_UP_TIME)
    {
        gettimeofday(&amp;tv1,0);
        /*updated by ken*/
        OnuInfo-&gt;onu_up_time = tv1.tv_sec - midware_onu_up_time;
    }

    return MDW_CB_RET_SET_HW_NO_NEED;
}


///////////////////////////////////////////////
//MIDWARE_TABLE_ONU_CFG
///////////////////////////////////////////////
ONU_STATUS midware_table_onu_cfg_init(void)
{
    MIDWARE_TABLE_ONU_CFG_T OnuCfg;
    ONU_STATUS rc;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_ONU_CFG))
    {
        //already got entries in the table,
        return ONU_OK;
    }

    //TBD
    memset(&amp;OnuCfg, 0, sizeof(OnuCfg));
    OnuCfg.oam_stack_status = MIDWARE_SFU_CTC_STACK_ENABLE;
    OnuCfg.mtu_size         = MIDWARE_SFU_MTU_DEFAULT_SIZE;
    OnuCfg.pm_interval      = APM_DEFAULT_PM_INTERVAL_MS;
    OnuCfg.mac_age_time     = MIDWARE_SFU_AGE_TIME;
    //insert the entry into SQLite
    table_info = midware_get_table_info(MIDWARE_TABLE_ONU_CFG);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;OnuCfg);
     if(ONU_FAIL == rc)
     {
         MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entry\n");
         return ONU_FAIL;
     }

     return ONU_OK;
}

MIDWARE_CALLBACK_RET midware_table_onu_cfg_get(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_ONU_CFG_T         *OnuCfg;
    UINT32                                                        mac_aging_time;
    tpm_error_code_t                                        tpm_rc = ERR_GENERAL;
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;

    OnuCfg = (MIDWARE_TABLE_ONU_CFG_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_MAC_AGE_TIME)
    {
        tpm_rc = tpm_sw_get_mac_age_time(0, (uint32_t *)&amp;mac_aging_time);
        if (tpm_rc != TPM_RC_OK)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get MAC aging time\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        OnuCfg-&gt;mac_age_time = mac_aging_time;
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

     return callback_ret;
}


MIDWARE_CALLBACK_RET midware_table_onu_cfg_set(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_ONU_CFG_T         *OnuCfg;
    tpm_error_code_t                                        tpm_rc = ERR_GENERAL;

    OnuCfg = (MIDWARE_TABLE_ONU_CFG_T *)entry;

    if(      (bitmap &amp; MIDWARE_ENTRY_RESET_ONU)
        &amp;&amp;(1 == OnuCfg-&gt;reset_onu))
    {
        system("reboot");
    }
    if(bitmap &amp; MIDWARE_ENTRY_MAC_AGE_TIME)
    {
        tpm_rc = tpm_sw_set_mac_age_time(0, OnuCfg-&gt;mac_age_time);
        if (tpm_rc != TPM_RC_OK)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set MAC aging time\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
    }
    if(bitmap &amp; MIDWARE_ENTRY_MTU_SIZE)
    {
        tpm_rc = tpm_set_mtu_size(0, TPM_NETA_MTU_SWITCH, OnuCfg-&gt;mtu_size);
        /* Do not check the return value in case it will fali for MC*/
        /*
        if (tpm_rc != TPM_RC_OK)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set Switch MTU size\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }*/
        tpm_rc = tpm_set_mtu_size(0, TPM_NETA_MTU_GMAC0, OnuCfg-&gt;mtu_size);
        if (tpm_rc != TPM_RC_OK)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set GMAC0 MTU size\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        tpm_rc = tpm_set_mtu_size(0, TPM_NETA_MTU_PONMAC, OnuCfg-&gt;mtu_size);
        if (tpm_rc != TPM_RC_OK)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set PON MAC MTU size\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
    }

    if(bitmap &amp; MIDWARE_ENTRY_SYNCHRONIZE_TIME)
    {
        /*ken need to be update*/
        if(apm_pm_synchronize())
        {
            midware_Synchronize_TCA();
        }
        else
        {
            return MDW_CB_RET_SET_HW_FAIL;
        }
    }

    if(bitmap &amp; MIDWARE_ENTRY_MIB_RESET)
    {
        /*ken need to be update*/
        if(!apm_alarm_db_obj_reset() || !apm_pm_db_obj_reset() || !apm_avc_db_obj_reset())
        {
            return MDW_CB_RET_SET_HW_FAIL;
        }

        if(ONU_OK != midware_sqlite3_reset_table_without_callback(MIDWARE_TABLE_ALARM))
        {
            return MDW_CB_RET_SET_HW_FAIL;
        }
        if(ONU_OK != midware_sqlite3_reset_table_without_callback(MIDWARE_TABLE_PM))
        {
            return MDW_CB_RET_SET_HW_FAIL;
        }
        if(ONU_OK != midware_sqlite3_reset_table_without_callback(MIDWARE_TABLE_AVC))
        {
            return MDW_CB_RET_SET_HW_FAIL;
        }

    }

    if(bitmap &amp; MIDWARE_ENTRY_PM_INTERVAL)
    {
#if 0
        /*ken need to be update*/
        if(!apm_pm_set_interval(OnuCfg-&gt;pm_interval))
        {
            return MDW_CB_RET_SET_HW_FAIL;
        }
#endif
    }

     return MDW_CB_RET_SET_HW_OK;
}

int  midware_mv_ext_get_if_mac(const char *ifName, UINT8 *pMac)
{
    struct ifreq req;
    int err;

     if (NULL == pMac)
     {
         return ERROR;
     }

    strcpy(req.ifr_name, ifName);
    int s=socket(AF_INET, SOCK_DGRAM, 0);
    err = ioctl(s,SIOCGIFHWADDR, &amp;req);
    close(s);

    memset(pMac, 0 , 6*sizeof(char));
    if (err!=-1)
         memcpy(pMac, req.ifr_hwaddr.sa_data, ETH_ALEN);

       return 0 ;
}

int  midware_mv_ext_get_if_addr(const char *ifName, UINT8 *ipAddr)
{
    struct ifreq req;
    int err;
    struct sockaddr_in *myaddr;

     if (NULL == ipAddr)
     {
         return ERROR;
     }

    strcpy(req.ifr_name, ifName);
    int s=socket(AF_INET, SOCK_DGRAM, 0);
    err = ioctl(s,SIOCGIFADDR, &amp;req);
    close(s);

    myaddr = (struct sockaddr_in *)&amp;(req.ifr_addr);

    memset(ipAddr, 0 , MIDWARE_IPV4_IP_LEN*sizeof(char));

    if (err!=-1)
    {
        ipAddr[0] = (ntohl(myaddr-&gt;sin_addr.s_addr)&amp;0xff000000)&gt;&gt;24;
        ipAddr[1] = (ntohl(myaddr-&gt;sin_addr.s_addr)&amp;0x00ff0000)&gt;&gt;16;
        ipAddr[2] = (ntohl(myaddr-&gt;sin_addr.s_addr)&amp;0x0000ff00)&gt;&gt;8;
        ipAddr[3] = (ntohl(myaddr-&gt;sin_addr.s_addr)&amp;0x0000000ff);
    }

    return 0 ;
}

int  midware_mv_ext_get_if_mask(const char *ifname, UINT8 *mask)
{
    struct ifreq req;
    int err;
    struct sockaddr_in *myaddr;

     if (NULL == mask)
     {
         return ERROR;
     }

    strcpy(req.ifr_name, ifname);
    int s=socket(AF_INET, SOCK_DGRAM, 0);
    err = ioctl(s,SIOCGIFNETMASK, &amp;req);
    close(s);

    myaddr = (struct sockaddr_in *)&amp;(req.ifr_netmask);

    memset(mask, 0 , MIDWARE_IPV4_IP_LEN*sizeof(char));
    if (err!=-1)
    {
        mask[0] = (ntohl(myaddr-&gt;sin_addr.s_addr)&amp;0xff000000)&gt;&gt;24;
        mask[1] = (ntohl(myaddr-&gt;sin_addr.s_addr)&amp;0x00ff0000)&gt;&gt;16;
        mask[2] = (ntohl(myaddr-&gt;sin_addr.s_addr)&amp;0x0000ff00)&gt;&gt;8;
        mask[3] = (ntohl(myaddr-&gt;sin_addr.s_addr)&amp;0x000000ff);
    }

    return 0 ;
}

int midware_mv_ext_get_if_gateway(const char *ifname,UINT8 *gateway)
{
    FILE *fp;
    char buf[256]; // 128 is enough for linux
    char iface[16];
    unsigned long dest_addr, gate_addr;

    memset(gateway,0,MIDWARE_IPV4_IP_LEN*sizeof(char));

    fp = fopen("/proc/net/route", "r");
    if (fp == NULL)
    return -1;
    /* Skip title line */
    fgets(buf, sizeof(buf), fp);
    while (fgets(buf, sizeof(buf), fp))
    {
        if (sscanf(buf, "%s\t%lX\t%lX", iface, &amp;dest_addr, &amp;gate_addr) != 3)
        {
            continue;
        }

        if(0!=strcmp(iface,ifname))
        {
            continue;
        }

        gateway[0] = (ntohl(gate_addr)&amp;0xff000000)&gt;&gt;24;
        gateway[1] = (ntohl(gate_addr)&amp;0x00ff0000)&gt;&gt;16;
        gateway[2] = (ntohl(gate_addr)&amp;0x0000ff00)&gt;&gt;8;
        gateway[3] = (ntohl(gate_addr)&amp;0x000000ff);

        break;
    }

    fclose(fp);
    return 0;
}

int midware_mv_ext_set_if_addr(const char *ifname, UINT8 *Ipaddr)
{
    int fd;
    struct ifreq ifr;
    struct sockaddr_in *sin;


    fd = socket(AF_INET, SOCK_DGRAM, 0);
    if(fd &lt; 0)
    {
        perror("socket   error");
        return -1;
    }

    memset(&amp;ifr,0,sizeof(ifr));
    strcpy(ifr.ifr_name,ifname);
    sin = (struct sockaddr_in*)&amp;ifr.ifr_addr;
    sin-&gt;sin_family = AF_INET;

    //ipaddr
    sin-&gt;sin_addr.s_addr = htonl((Ipaddr[0]&lt;&lt;24)+(Ipaddr[1]&lt;&lt;16)+(Ipaddr[2]&lt;&lt;8)+(Ipaddr[3]));

    if(ioctl(fd,SIOCSIFADDR,&amp;ifr) &lt; 0)
    {
        perror("ioctl   SIOCSIFADDR   error");
        return -3;
    }

    close(fd);
    return OK;
}

int midware_mv_ext_set_if_mask(const char *ifname, UINT8 *mask)
{
    int fd;
    struct ifreq ifr;
    struct sockaddr_in *sin;


    fd = socket(AF_INET, SOCK_DGRAM, 0);
    if(fd &lt; 0)
    {
        perror("socket   error");
        return -1;
    }

    memset(&amp;ifr,0,sizeof(ifr));
    strcpy(ifr.ifr_name,ifname);
    sin = (struct sockaddr_in*)&amp;ifr.ifr_addr;
    sin-&gt;sin_family = AF_INET;

    //netmask
    sin-&gt;sin_addr.s_addr = htonl((mask[0]&lt;&lt;24)+(mask[1]&lt;&lt;16)+(mask[2]&lt;&lt;8)+(mask[3]));

    if(ioctl(fd, SIOCSIFNETMASK, &amp;ifr) &lt; 0)
    {
        perror("ioctl");
        return -5;
    }

    close(fd);
    return OK;
}

int midware_mv_ext_set_if_gateway(const char *ifname, UINT8 *gateway)
{
    int fd;
    struct rtentry  rt;
    struct sockaddr_in sin;


    fd = socket(AF_INET, SOCK_DGRAM, 0);
    if(fd &lt; 0)
    {
        perror("socket   error");
        return -1;
    }

    sin.sin_family = AF_INET;


    //gateway
    memset(&amp;rt, 0, sizeof(struct rtentry));
    memset(&amp;sin, 0, sizeof(struct sockaddr_in));
    sin.sin_family = AF_INET;
    sin.sin_port = 0;

    sin.sin_addr.s_addr = htonl((gateway[0]&lt;&lt;24)+(gateway[1]&lt;&lt;16)+(gateway[2]&lt;&lt;8)+(gateway[3]));

    memcpy ( &amp;rt.rt_gateway, &amp;sin, sizeof(struct sockaddr_in));
    ((struct sockaddr_in *)&amp;rt.rt_dst)-&gt;sin_family=AF_INET;
    ((struct sockaddr_in *)&amp;rt.rt_genmask)-&gt;sin_family=AF_INET;
    rt.rt_flags = RTF_GATEWAY;

    if (ioctl(fd, SIOCADDRT, &amp;rt)&lt;0)
    {
        perror( "ioctl(SIOCADDRT) error in set_default_route\n");
        close(fd);
        return -1;
    }

    close(fd);
    return OK;
}

int midware_mv_ext_del_if_gateway(const char *ifname, UINT8 *gateway)
{
    int fd;
    struct rtentry  rt;
    struct sockaddr_in sin;


    fd = socket(AF_INET, SOCK_DGRAM, 0);
    if(fd &lt; 0)
    {
        perror("socket   error");
        return -1;
    }

    sin.sin_family = AF_INET;


    //gateway
    memset(&amp;rt, 0, sizeof(struct rtentry));
    memset(&amp;sin, 0, sizeof(struct sockaddr_in));
    sin.sin_family = AF_INET;
    sin.sin_port = 0;

    sin.sin_addr.s_addr = htonl((gateway[0]&lt;&lt;24)+(gateway[1]&lt;&lt;16)+(gateway[2]&lt;&lt;8)+(gateway[3]));

    memcpy ( &amp;rt.rt_gateway, &amp;sin, sizeof(struct sockaddr_in));
    ((struct sockaddr_in *)&amp;rt.rt_dst)-&gt;sin_family=AF_INET;
    ((struct sockaddr_in *)&amp;rt.rt_genmask)-&gt;sin_family=AF_INET;
    rt.rt_flags = RTF_GATEWAY;

    if (ioctl(fd, SIOCDELRT, &amp;rt)&lt;0)
    {
        perror( "ioctl(SIOCADDRT) error in set_default_route\n");
        close(fd);
        return -1;
    }

    close(fd);
    return OK;
}


ONU_STATUS midware_table_onu_ip_init(void)
{
    MIDWARE_TABLE_ONU_IP_T OnuIP;
    ONU_STATUS rc;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_ONU_IP))
    {
        //already got entries in the table,
        return ONU_OK;
    }

    #if 0
    //pon0
    memset(&amp;OnuIP, 0, sizeof(OnuIP));
    OnuIP.entity_id = 1;
    OnuIP.entity_type = MIDWARE_IP_TYPE_WAN_HOST;
    midware_mv_ext_get_if_mac("pon0",OnuIP.mac);
    midware_mv_ext_get_if_addr("pon0",OnuIP.cur_ip);
    midware_mv_ext_get_if_mask("pon0",OnuIP.cur_netmask);
    midware_mv_ext_get_if_gateway("pon0",OnuIP.cur_gateway);

    //insert the entry into SQLite
    table_info = midware_get_table_info(MIDWARE_TABLE_ONU_IP);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;OnuIP);
     if(ONU_FAIL == rc)
     {
         MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entry\n");
         return ONU_FAIL;
     }
    #endif

    //pon0
    memset(&amp;OnuIP, 0, sizeof(OnuIP));

    OnuIP.entity_id = MIDWARE_IP_PON0;
    OnuIP.entity_type = MIDWARE_IP_TYPE_WAN_HOST;
    midware_mv_ext_get_if_mac("pon0",OnuIP.mac);
    midware_mv_ext_get_if_addr("pon0",OnuIP.cur_ip);
    midware_mv_ext_get_if_mask("pon0",OnuIP.cur_netmask);
    midware_mv_ext_get_if_gateway("pon0",OnuIP.cur_gateway);

    //insert the entry into SQLite
    table_info = midware_get_table_info(MIDWARE_TABLE_ONU_IP);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;OnuIP);
    if(ONU_FAIL == rc)
    {
     MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entry\n");
     return ONU_FAIL;
    }


    //eth0
    memset(&amp;OnuIP, 0, sizeof(OnuIP));

    OnuIP.entity_id = MIDWARE_IP_ETH0;
    OnuIP.entity_type = MIDWARE_IP_TYPE_LAN_HOST;
    midware_mv_ext_get_if_mac("eth0",OnuIP.mac);
    midware_mv_ext_get_if_addr("eth0",OnuIP.cur_ip);
    midware_mv_ext_get_if_mask("eth0",OnuIP.cur_netmask);
    midware_mv_ext_get_if_gateway("eth0",OnuIP.cur_gateway);

    //insert the entry into SQLite
    table_info = midware_get_table_info(MIDWARE_TABLE_ONU_IP);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;OnuIP);
    if(ONU_FAIL == rc)
    {
     MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entry\n");
     return ONU_FAIL;
    }

    return ONU_OK;
}

MIDWARE_CALLBACK_RET midware_table_onu_ip_get(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_ONU_IP_T              *OnuIP;
    INT32                               rc;
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    UINT32 entity_id = 0;


    OnuIP = (MIDWARE_TABLE_ONU_IP_T *)entry;

    entity_id = OnuIP-&gt;entity_id;
    if(entity_id == MIDWARE_IP_ETH0)
    {
        entity_id = sizeof(network_if_name)/sizeof(const char*) - 1;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MAC)
    {
        rc = midware_mv_ext_get_if_mac(network_if_name[entity_id],OnuIP-&gt;mac);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to midware_mv_ext_get_if_mac\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_CUR_IP)
    {
        rc = midware_mv_ext_get_if_addr(network_if_name[entity_id],OnuIP-&gt;cur_ip);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to midware_mv_ext_get_if_addr\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_CUR_NETMASK)
    {
        rc = midware_mv_ext_get_if_mask(network_if_name[entity_id],OnuIP-&gt;cur_netmask);
        if (OK != rc)
        {
         MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to midware_mv_ext_get_if_mask\r\n");
         return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_CUR_GATEWAY)
    {
        rc = midware_mv_ext_get_if_gateway(network_if_name[entity_id],OnuIP-&gt;cur_gateway);
        if (OK != rc)
        {
         MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to midware_mv_ext_get_if_gateway\r\n");
         return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_onu_ip_set(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_ONU_IP_T              *OnuIP;
    INT32                               rc;
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    UINT8                               gateway[MIDWARE_IPV4_IP_LEN];
    UINT32 entity_id = 0;

    OnuIP = (MIDWARE_TABLE_ONU_IP_T *)entry;
    entity_id = OnuIP-&gt;entity_id;
    if(entity_id == MIDWARE_IP_ETH0)
    {
        entity_id = sizeof(network_if_name)/sizeof(const char*) - 1;
    }

    if(bitmap &amp; MIDWARE_ENTRY_IP)
    {
        rc = midware_mv_ext_set_if_addr(network_if_name[entity_id], OnuIP-&gt;ip);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to midware_mv_ext_set_if_addr\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_NETMASK)
    {
        rc = midware_mv_ext_set_if_mask(network_if_name[entity_id], OnuIP-&gt;netmask);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to midware_mv_ext_set_if_mask\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

     if(bitmap &amp; MIDWARE_ENTRY_GATEWAY)
     {
        if(0==*(UINT32 *)(OnuIP-&gt;gateway))
        {
            do
            {
                *(UINT32 *)(OnuIP-&gt;gateway)=0;
                midware_mv_ext_get_if_gateway(network_if_name[entity_id],OnuIP-&gt;gateway);
                if(0==*(UINT32 *)(OnuIP-&gt;gateway))
                {
                    break;
                }
                else
                {
                    midware_mv_ext_del_if_gateway(network_if_name[entity_id],OnuIP-&gt;gateway);
                }

            }while(0!=*(UINT32 *)(OnuIP-&gt;gateway));
        }
        else
        {
            do
            {
                *(UINT32 *)(gateway)=0;
                midware_mv_ext_get_if_gateway(network_if_name[entity_id],gateway);
                if(0==*(UINT32 *)(gateway))
                {
                    break;
                }
                else
                {
                    midware_mv_ext_del_if_gateway(network_if_name[entity_id],gateway);
                }

            }while(0!=*(UINT32 *)(gateway));

            rc = midware_mv_ext_set_if_gateway(network_if_name[entity_id], OnuIP-&gt;gateway);
            if (OK != rc)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to midware_mv_ext_set_if_gateway\r\n");
                return MDW_CB_RET_SET_HW_FAIL;
            }
            }
            callback_ret = MDW_CB_RET_SET_HW_OK;

    }

     return callback_ret;
}


///////////////////////////////////////////////
//MIDWARE_TABLE_UNI_CFG
///////////////////////////////////////////////
ONU_STATUS midware_table_uni_cfg_init(void)
{
    ONU_STATUS      rc=ONU_OK;
    MIDWARE_TABLE_UNI_CFG_T     uni_cfg;
    UINT32             i;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_UNI_CFG))
    {
        //already got entries in the table, restore
        rc = midware_table_restore(MIDWARE_TABLE_UNI_CFG);
        if (ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to restore MIDWARE_TABLE_UNI_CFG\r\n");
            return ONU_FAIL;
        }

        return ONU_OK;
    }

    //init the default entries
    memset(&amp;uni_cfg, 0, sizeof(uni_cfg));
    uni_cfg.port_id = TPM_SRC_PORT_UNI_0;
    uni_cfg.port_type = MIDWARE_UNI_TYPE_FE;
    uni_cfg.port_admin = MIDWARE_SFU_ENABLE;
    uni_cfg.autoneg_cfg = MIDWARE_SFU_AUTONEG;
    uni_cfg.autoneg_mode = TPM_SPEED_AUTO_DUPLEX_AUTO;
    uni_cfg.reset_autoneg = MIDWARE_SFU_DISABLE;
    /*uni_cfg.speed_cfg = MIDWARE_SFU_SPEED_100;*/
    uni_cfg.speed_state = MIDWARE_SFU_SPEED_100;
    /*uni_cfg.duplex_cfg = MIDWARE_SFU_MODE_FULL;*/
    uni_cfg.duplex_state = MIDWARE_SFU_MODE_FULL;
    uni_cfg.loopback = MIDWARE_SFU_DISABLE;
    //uni_cfg.port_isolate = 0xff-(1&lt;&lt;(uni_cfg.port_id-1));
    uni_cfg.port_flood = 0x00;
    uni_cfg.mac_learn_en = MIDWARE_SFU_ENABLE;
    uni_cfg.default_vid = MIDWARE_SFU_DEF_VLAN;
    uni_cfg.default_pri = MIDWARE_SFU_DEF_PRI;
    uni_cfg.discard_tag = MIDWARE_SFU_DISABLE;
    uni_cfg.discard_untag = MIDWARE_SFU_DISABLE;
    uni_cfg.vlan_filter = MIDWARE_SFU_DISABLE;
    uni_cfg.loop_detect = MIDWARE_SFU_DISABLE;
    uni_cfg.in_mirror_en = MIDWARE_SFU_DISABLE;
    uni_cfg.in_mirror_dst = TPM_SRC_PORT_UNI_0;
    uni_cfg.out_mirror_en = MIDWARE_SFU_DISABLE;
    uni_cfg.out_mirror_dst = TPM_SRC_PORT_UNI_0;
    uni_cfg.stp_state = MIDWARE_PORT_FORWARDING;

    table_info = midware_get_table_info(MIDWARE_TABLE_UNI_CFG);
    for(i = TPM_SRC_PORT_UNI_0; i &lt;= TPM_SRC_PORT_UNI_3; i++)
    {
        uni_cfg.port_id = i;
        uni_cfg.in_mirror_src = i;
        uni_cfg.out_mirror_src = i;
        uni_cfg.port_isolate = 0xfff-(1&lt;&lt;i);

        if(MIDWARE_UNI_TYPE_GE == midware_get_uni_port_type(i))
        {
            uni_cfg.port_type = MIDWARE_UNI_TYPE_GE;
            uni_cfg.speed_state = MIDWARE_SFU_SPEED_1000;
        }
        else
        {
            uni_cfg.port_type   = MIDWARE_UNI_TYPE_FE;
            uni_cfg.speed_state = MIDWARE_SFU_SPEED_100;

        }

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;uni_cfg);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for port: %ld\n", i);
            return ONU_FAIL;
        }

    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_uni_cfg_get(UINT32 bitmap, void *entry)
{
  MIDWARE_TABLE_UNI_CFG_T     *uni_cfg;
  tpm_error_code_t                      tpm_rc = ERR_GENERAL;
  MIDWARE_CALLBACK_RET        callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
  //bool         phy_port_state;
  bool         port_link_status;
  tpm_src_port_type_t   port_id;
  //tpm_src_port_type_t   dst_port_id;
  //tpm_src_port_type_t   src_port_id;
  //tpm_autoneg_mode_t  configurationInd;
  bool         autoneg_status;
  tpm_phy_speed_t       speed;
  bool         duplex_enable;
  //tpm_phy_loopback_mode_t loopback_mode;
  //bool   loopback_enable;
  //UINT32                    eth_port_vector;
  //bool                          flood_enable;

  uni_cfg = (MIDWARE_TABLE_UNI_CFG_T *)entry;

  //TBD
  //here maybe we need to adapt the midware portid to tpm portid
  port_id = uni_cfg-&gt;port_id;


  #if 0
  if(bitmap &amp; MIDWARE_ENTRY_PORT_ADMIN)
  {
      tpm_rc = tpm_phy_get_port_admin_state(0, port_id, &amp;phy_port_state);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_admin_state, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      if (phy_port_state)
      {
          uni_cfg-&gt;port_admin = 1;
      }
      else
      {
          uni_cfg-&gt;port_admin = 0;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }
  #endif

  if(bitmap &amp; MIDWARE_ENTRY_PORT_LINK_STATE)
  {
      tpm_rc = tpm_phy_get_port_link_status(0, port_id, &amp;port_link_status);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_link_state, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      if (port_link_status)
      {
          uni_cfg-&gt;link_state = 1;
      }
      else
      {
          uni_cfg-&gt;link_state = 0;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  /*
  if(    (bitmap &amp; MIDWARE_ENTRY_PORT_AUTONEG_CFG)
       || (bitmap &amp; MIDWARE_ENTRY_PORT_AUTONEG_STATE))
  */
  /*
  if(bitmap &amp; MIDWARE_ENTRY_PORT_CONFIGURATION_IND)
  {
      tpm_rc = tpm_phy_get_port_autoneg_mode(0, port_id, &amp;autoneg_status, &amp;configurationInd);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_admin_state, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }

      uni_cfg-&gt;configurationInd = configurationInd;
      callback_ret = MDW_CB_RET_SET_HW_OK;
      }
      */
  #if 0
  if(bitmap &amp; MIDWARE_ENTRY_PORT_SPEED_CFG)
  {
      tpm_rc = tpm_phy_get_port_speed(0, port_id, &amp;speed);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_admin_state, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      uni_cfg-&gt;speed_cfg = speed;
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }
  #endif

  if(bitmap &amp; MIDWARE_ENTRY_PORT_SPEED_STATE)
  {
      tpm_rc = tpm_phy_get_port_speed_mode(0, port_id, &amp;speed);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_admin_state, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      uni_cfg-&gt;speed_state = speed;
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  #if 0
  if(bitmap &amp; MIDWARE_ENTRY_PORT_DUPLEX_CFG)
  {
      tpm_rc = tpm_phy_get_port_duplex_mode(0, port_id, &amp;duplex_enable);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_admin_state, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      if (duplex_enable)
      {
          uni_cfg-&gt;duplex_cfg = 1;
      }
      else
      {
          uni_cfg-&gt;duplex_cfg = 0;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }
  #endif

  if(bitmap &amp; MIDWARE_ENTRY_PORT_DUPLEX_STATE)
  {
      tpm_rc = tpm_phy_get_port_duplex_status(0, port_id, &amp;duplex_enable);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_admin_state, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      if (duplex_enable)
      {
          uni_cfg-&gt;duplex_state = 1;
      }
      else
      {
          uni_cfg-&gt;duplex_state = 0;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  #if 0
  if(bitmap &amp; MIDWARE_ENTRY_PORT_LOOPBACK_CFG)
  {
      tpm_rc = tpm_phy_get_port_loopback(0, port_id, loopback_mode, &amp;loopback_enable);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_loopback, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      if (loopback_enable)
      {
          uni_cfg-&gt;loopback = 1;
      }
      else
      {
          uni_cfg-&gt;loopback = 0;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(bitmap &amp; MIDWARE_ENTRY_PORT_ISOLATE_CFG)
  {
      tpm_rc = tpm_sw_get_isolate_eth_port_vector(0, port_id, &amp;eth_port_vector);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_loopback, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      uni_cfg-&gt;port_isolate = eth_port_vector;
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(bitmap &amp; MIDWARE_ENTRY_PORT_FLOOD_CFG)
  {
      tpm_rc = tpm_sw_get_port_flooding(0, port_id, TPM_FLOOD_UNKNOWN_UNICAST, &amp;flood_enable);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_flooding, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      if (flood_enable)
      {
          uni_cfg-&gt;port_flood = 1;
      }
      else
      {
          uni_cfg-&gt;port_flood = 0;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(bitmap &amp; MIDWARE_ENTRY_PORT_MAC_LEARN)
  {
      tpm_rc = tpm_sw_get_mac_learn(0, port_id, &amp;flood_enable);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get mac_learn, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      if (flood_enable)
      {
          uni_cfg-&gt;mac_learn_en = 1;
      }
      else
      {
          uni_cfg-&gt;mac_learn_en = 0;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(    (bitmap &amp; MIDWARE_ENTRY_PORT_IN_MIRROR_DST)
       || (bitmap &amp; MIDWARE_ENTRY_PORT_IN_MIRROR_EN)
       || (bitmap &amp; MIDWARE_ENTRY_PORT_IN_MIRROR_SRC))
  {
      //TBD
      //here maybe we need to adapt the midware portid to tpm portid
      dst_port_id = uni_cfg-&gt;in_mirror_dst;
      src_port_id = uni_cfg-&gt;in_mirror_src;
      tpm_rc = tpm_sw_get_port_mirror(0, src_port_id, dst_port_id, TPM_SW_MIRROR_INGRESS, &amp;flood_enable);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_mirror, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      if (flood_enable)
      {
          uni_cfg-&gt;in_mirror_en = 1;
      }
      else
      {
          uni_cfg-&gt;in_mirror_en = 0;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(    (bitmap &amp; MIDWARE_ENTRY_PORT_OUT_MIRROR_DST)
       || (bitmap &amp; MIDWARE_ENTRY_PORT_OUT_MIRROR_EN)
       || (bitmap &amp; MIDWARE_ENTRY_PORT_OUT_MIRROR_SRC))
  {
      //TBD
      //here maybe we need to adapt the midware portid to tpm portid
      dst_port_id = uni_cfg-&gt;out_mirror_dst;
      src_port_id = uni_cfg-&gt;out_mirror_dst;
      tpm_rc = tpm_sw_get_port_mirror(0, src_port_id, dst_port_id, TPM_SW_MIRROR_EGRESS, &amp;flood_enable);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_mirror, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      if (flood_enable)
      {
          uni_cfg-&gt;out_mirror_en = 1;
      }
      else
      {
          uni_cfg-&gt;out_mirror_en = 0;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }
  #endif

   return callback_ret;
}


MIDWARE_CALLBACK_RET midware_table_uni_cfg_set(UINT32 bitmap, void *entry)
{
  MIDWARE_TABLE_UNI_CFG_T *uni_cfg;
  tpm_error_code_t         tpm_rc = ERR_GENERAL;
  MIDWARE_CALLBACK_RET     callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
  tpm_src_port_type_t      port_id;
  tpm_src_port_type_t      dst_port_id;
  tpm_src_port_type_t      src_port_id;
  tpm_phy_speed_t          speed;

  uni_cfg = (MIDWARE_TABLE_UNI_CFG_T *)entry;

  //TBD
  //here maybe we need to adapt the midware portid to tpm portid
  port_id = uni_cfg-&gt;port_id;

  if(bitmap &amp; MIDWARE_ENTRY_PORT_ADMIN)
  {
      tpm_rc = tpm_phy_set_port_admin_state(0, port_id, MIDWARE_U8_TO_BOOL(uni_cfg-&gt;port_admin));
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to Set port_admin_state, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(bitmap &amp; MIDWARE_ENTRY_PORT_AUTONEG_CFG)
  {
      tpm_rc = tpm_phy_set_port_autoneg_mode(0, port_id, uni_cfg-&gt;autoneg_cfg, TPM_SPEED_AUTO_DUPLEX_AUTO);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to Set MIDWARE_ENTRY_PORT_AUTONEG_CFG, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(bitmap &amp; MIDWARE_ENTRY_PORT_AUTONEG_MODE)
  {
      tpm_rc = tpm_phy_set_port_autoneg_mode(0, port_id, MIDWARE_SFU_AUTONEG, uni_cfg-&gt;autoneg_mode);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to Set MIDWARE_ENTRY_PORT_AUTONEG_MODE, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(bitmap &amp; MIDWARE_ENTRY_PORT_RESET_AUTONEG)
  {
      if(MIDWARE_SFU_ENABLE==uni_cfg-&gt;reset_autoneg)
      {
          tpm_rc = tpm_phy_restart_port_autoneg(0, port_id);
          if (tpm_rc != TPM_RC_OK)
          {
              MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to Set MIDWARE_ENTRY_PORT_RESET_AUTONEG, port: %d\r\n", port_id);
              return MDW_CB_RET_SET_HW_FAIL;
          }
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }
#if 0 /*victor masked temporary 2011-05-18, open and debug it in future*/
  if(bitmap &amp; MIDWARE_ENTRY_PORT_SPEED_CFG)
  {
      tpm_rc = tpm_phy_set_port_speed(0, port_id, uni_cfg-&gt;speed_cfg);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set port speed, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      uni_cfg-&gt;speed_cfg = speed;
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(bitmap &amp; MIDWARE_ENTRY_PORT_DUPLEX_CFG)
  {
      tpm_rc = tpm_phy_set_port_duplex_mode(0, port_id, MIDWARE_U8_TO_BOOL(uni_cfg-&gt;duplex_cfg));
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set port duplex mode, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }
#endif

#if 1
  if(bitmap &amp; MIDWARE_ENTRY_PORT_LOOPBACK_CFG)
  {
      if (MIDWARE_ETH_INTERNAL_LOOPBACK_DISABLE == uni_cfg-&gt;loopback) {
          tpm_rc = tpm_phy_set_port_loopback(0, port_id, TPM_PHY_INTERNAL_LOOPBACK, false);
      }
      else if (MIDWARE_ETH_INTERNAL_LOOPBACK_EN == uni_cfg-&gt;loopback) {
          tpm_rc = tpm_phy_set_port_loopback(0, port_id, TPM_PHY_INTERNAL_LOOPBACK, true);
      }
      else if (MIDWARE_ETH_EXTERNAL_LOOPBACK_DISABLE == uni_cfg-&gt;loopback) {
          tpm_rc = tpm_phy_set_port_loopback(0, port_id, TPM_PHY_EXTERNAL_LOOPBACK, false);
      }
      else if (MIDWARE_ETH_EXTERNAL_LOOPBACK_EN == uni_cfg-&gt;loopback) {
          tpm_rc = tpm_phy_set_port_loopback(0, port_id, TPM_PHY_EXTERNAL_LOOPBACK, true);
      }      

      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set port_loopback, port: %d, mode: %d\r\n", port_id, uni_cfg-&gt;loopback);
          return MDW_CB_RET_SET_HW_FAIL;
      }

      callback_ret = MDW_CB_RET_SET_HW_OK;
  }
#endif

#if 1
  if(bitmap &amp; MIDWARE_ENTRY_PORT_ISOLATE_CFG)
  {
      tpm_rc = tpm_sw_set_isolate_eth_port_vector(0, port_id, uni_cfg-&gt;port_isolate);

      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set port_isolate, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }
#endif

  if(bitmap &amp; MIDWARE_ENTRY_PORT_FLOOD_CFG)
  {
      tpm_rc = tpm_sw_set_port_flooding(0, port_id, TPM_FLOOD_UNKNOWN_UNICAST, MIDWARE_U8_TO_BOOL(uni_cfg-&gt;port_flood));
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_flooding, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(bitmap &amp; MIDWARE_ENTRY_PORT_MAC_LEARN)
  {
      tpm_rc = tpm_sw_set_mac_learn(0, port_id, MIDWARE_U8_TO_BOOL(uni_cfg-&gt;mac_learn_en));
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get mac_learn, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(bitmap &amp; MIDWARE_ENTRY_PORT_DISCARD_TAG)
  {
      tpm_rc = tpm_sw_set_port_tagged(0, port_id, ((uni_cfg-&gt;discard_tag)?1:0));
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set port_tagged, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(bitmap &amp; MIDWARE_ENTRY_PORT_DISCARD_UNTAG)
  {
      tpm_rc = tpm_sw_set_port_untagged(0, port_id, ((uni_cfg-&gt;discard_untag)?1:0));
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set port_untagged, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(bitmap &amp; MIDWARE_ENTRY_PORT_VID_FILTER)
  {
      tpm_rc = tpm_sw_port_set_vid_filter(0, port_id, uni_cfg-&gt;vlan_filter);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set vid_filter, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  
  if(    (bitmap &amp; MIDWARE_ENTRY_PORT_IN_MIRROR_DST)
       || (bitmap &amp; MIDWARE_ENTRY_PORT_IN_MIRROR_EN)
       || (bitmap &amp; MIDWARE_ENTRY_PORT_IN_MIRROR_SRC))
  {
      //TBD
      //here maybe we need to adapt the midware portid to tpm portid
      dst_port_id = uni_cfg-&gt;in_mirror_dst;
      src_port_id = uni_cfg-&gt;in_mirror_src;
      tpm_rc = tpm_sw_set_port_mirror(0, src_port_id, dst_port_id, TPM_SW_MIRROR_INGRESS, MIDWARE_U8_TO_BOOL(uni_cfg-&gt;in_mirror_en));
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set port_mirror, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

   if(    (bitmap &amp; MIDWARE_ENTRY_PORT_OUT_MIRROR_DST)
        || (bitmap &amp; MIDWARE_ENTRY_PORT_OUT_MIRROR_EN)
        || (bitmap &amp; MIDWARE_ENTRY_PORT_OUT_MIRROR_SRC))
   {
       //TBD
       //here maybe we need to adapt the midware portid to tpm portid
       dst_port_id = uni_cfg-&gt;out_mirror_dst;
       src_port_id = uni_cfg-&gt;out_mirror_dst;
       tpm_rc = tpm_sw_set_port_mirror(0, src_port_id, dst_port_id, TPM_SW_MIRROR_EGRESS, MIDWARE_U8_TO_BOOL(uni_cfg-&gt;out_mirror_en));
       if (tpm_rc != TPM_RC_OK)
       {
           MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_mirror, port: %d\r\n", port_id);
           return MDW_CB_RET_SET_HW_FAIL;
       }
       callback_ret = MDW_CB_RET_SET_HW_OK;
   }
   /*
   if(bitmap &amp; MIDWARE_ENTRY_PORT_STP_STATE)
   {
       tpm_rc = tpm_sw_set_port_stp_state(0, port_id, (tpm_port_stp_state)uni_cfg-&gt;stp_state);
       if (tpm_rc != TPM_RC_OK)
       {
           MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set port STP state, port: %d\r\n", port_id);
           return MDW_CB_RET_SET_HW_FAIL;
       }
       callback_ret = MDW_CB_RET_SET_HW_OK;
   }
    */
   return callback_ret;
}

ONU_STATUS midware_table_uni_qos_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_UNI_QOS_T    uni_qos;
    UINT32             i;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_UNI_QOS))
    {
        //already got entries in the table, restore
        rc = midware_table_restore(MIDWARE_TABLE_UNI_QOS);
        if (ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to restore MIDWARE_TABLE_UNI_QOS\r\n");
            return ONU_FAIL;
        }

        return ONU_OK;
    }

    //init the default entries
    uni_qos.fc_cfg = MIDWARE_SFU_DISABLE;
    uni_qos.fc_state = MIDWARE_SFU_DISABLE;
    uni_qos.pause_time = 0;
    uni_qos.us_policing_en = MIDWARE_SFU_DISABLE;
    uni_qos.us_policing_mode = TPM_SW_LIMIT_LAYER2;
    uni_qos.us_policing_cir = OAM_FE_BIT_RATE_IN_KBPS;
    uni_qos.us_policing_cbs = 0;
    uni_qos.us_policing_ebs = 0;
    uni_qos.ds_ratelimit_en = MIDWARE_SFU_DISABLE;
    uni_qos.ds_ratelimit_mode = TPM_SW_LIMIT_LAYER2;
    uni_qos.ds_ratelimit_cir = 0;
    uni_qos.ds_ratelimit_pir = 0;

    table_info = midware_get_table_info(MIDWARE_TABLE_UNI_QOS);
    for(i = TPM_SRC_PORT_UNI_0; i &lt;= TPM_SRC_PORT_UNI_3; i++)
    {
        uni_qos.port_id = i;
        if(MIDWARE_UNI_TYPE_GE == midware_get_uni_port_type(i))
        {
            uni_qos.us_policing_cir = OAM_GE_BIT_RATE_IN_KBPS;
        }
        else
        {
            uni_qos.us_policing_cir = OAM_FE_BIT_RATE_IN_KBPS;
        }

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;uni_qos);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for port: %ld\n", i);
            return ONU_FAIL;
        }

    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_uni_qos_get(UINT32 bitmap, void *entry)
{
  MIDWARE_TABLE_UNI_QOS_T   *qos_cfg;
  tpm_error_code_t                      tpm_rc = ERR_GENERAL;
  MIDWARE_CALLBACK_RET        callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
  bool         bool_state;
  //tpm_limit_mode_t    count_mode;
  tpm_src_port_type_t   port_id;

  qos_cfg = (MIDWARE_TABLE_UNI_QOS_T *)entry;

  //TBD
  //here maybe we need to adapt the midware portid to tpm portid
  port_id = qos_cfg-&gt;port_id;

  #if 0
  if(bitmap &amp; MIDWARE_ENTRY_QOS_FC_CFG)
  {
      tpm_rc = tpm_phy_get_port_flow_control_support(0, port_id, &amp;bool_state);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_flow_control_support, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      qos_cfg-&gt;fc_cfg = MIDWARE_BOOL_TO_U8(bool_state);
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }
  #endif

  if(bitmap &amp; MIDWARE_ENTRY_QOS_FC_STATE)
  {
      tpm_rc = tpm_phy_get_port_flow_control_state(0, port_id, &amp;bool_state);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get port_flow_control_state, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      qos_cfg-&gt;fc_state = MIDWARE_BOOL_TO_U8(bool_state);
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  #if 0
  if(    (bitmap &amp; MIDWARE_ENTRY_QOS_US_CBS)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_US_EBS)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_US_POLICING_EN)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_US_POLICING_MODE)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_US_CIR))
  {
      tpm_rc = tpm_sw_get_uni_ingr_police_rate(0, port_id, &amp;count_mode, (uint32_t*)&amp;qos_cfg-&gt;us_policing_cir,
                                                                 (uint32_t*)&amp;qos_cfg-&gt;us_policing_cbs, (uint32_t*)&amp;qos_cfg-&gt;us_policing_ebs);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get uni_ingr_police_rate, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      qos_cfg-&gt;us_policing_mode = count_mode;
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(    (bitmap &amp; MIDWARE_ENTRY_QOS_DS_RL_EN)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_DS_RL_MODE)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_DS_RL_CIR)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_DS_RL_PIR))
  {
      tpm_rc = tpm_sw_get_uni_egr_rate_limit(0, port_id, &amp;count_mode, &amp;qos_cfg-&gt;ds_ratelimit_cir);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to get uni_egr_rate_limit, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      qos_cfg-&gt;ds_ratelimit_mode = count_mode;
      qos_cfg-&gt;ds_ratelimit_pir = qos_cfg-&gt;ds_ratelimit_cir;
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }
  #endif
   return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_uni_qos_set(UINT32 bitmap, void *entry)
{
  MIDWARE_TABLE_UNI_QOS_T   *qos_cfg;
  tpm_error_code_t                      tpm_rc = ERR_GENERAL;
  MIDWARE_CALLBACK_RET        callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
  tpm_limit_mode_t    count_mode;
  tpm_src_port_type_t   port_id;

  //return (MDW_CB_RET_SET_HW_OK);
  qos_cfg = (MIDWARE_TABLE_UNI_QOS_T *)entry;

  //TBD
  //here maybe we need to adapt the midware portid to tpm portid
  port_id = qos_cfg-&gt;port_id;

  if(bitmap &amp; MIDWARE_ENTRY_QOS_FC_CFG)
  {
      tpm_rc = tpm_phy_set_port_flow_control_support(0, port_id, MIDWARE_U8_TO_BOOL(qos_cfg-&gt;fc_cfg));
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set port_flow_control_support, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(    (bitmap &amp; MIDWARE_ENTRY_QOS_US_CBS)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_US_EBS)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_US_POLICING_EN)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_US_POLICING_MODE)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_US_CIR))
  {
      count_mode = qos_cfg-&gt;us_policing_mode;
      tpm_rc = tpm_sw_set_uni_ingr_police_rate(0, port_id, count_mode, qos_cfg-&gt;us_policing_cir,
                                               qos_cfg-&gt;us_policing_cbs, qos_cfg-&gt;us_policing_ebs);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set uni_ingr_police_rate, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(    (bitmap &amp; MIDWARE_ENTRY_QOS_DS_RL_EN)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_DS_RL_MODE)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_DS_RL_CIR)
       || (bitmap &amp; MIDWARE_ENTRY_QOS_DS_RL_PIR))
  {
      count_mode = qos_cfg-&gt;ds_ratelimit_mode;
      tpm_rc = tpm_sw_set_uni_egr_rate_limit(0, port_id, count_mode, qos_cfg-&gt;ds_ratelimit_cir);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set uni_egr_rate_limit, port: %d\r\n", port_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

   return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_vlan_cmp_set_hw
(
    MIDWARE_TABLE_VLAN_T   *vlan_current,
    MIDWARE_TABLE_VLAN_T   *vlan_new
)
{
    UINT32    i;
    UINT32    tmp_port_vec;
    tpm_error_code_t   tpm_rc = TPM_RC_OK;
    tpm_src_port_type_t port_id;

    for(i = TPM_SRC_PORT_UNI_0; i &lt;= TPM_SRC_PORT_UNI_3; i++)
    {
        tmp_port_vec = 1 &lt;&lt; i;

        //TBD
        //here maybe we need to adapt the midware portid to tpm portid
        port_id = i;

        /* jinghua modify 2011-06-02
        if the port is moving from untag to tag or vise,
        do not need remove or add this port into vlan.
    */
        if(       (tmp_port_vec == (vlan_current-&gt;tag_member_vec &amp; tmp_port_vec))
            &amp;&amp; (0 == (vlan_new-&gt;tag_member_vec &amp; tmp_port_vec))
            &amp;&amp; (tmp_port_vec == (vlan_new-&gt;untag_member_vec &amp; tmp_port_vec)))
        {
            /* this port moves from tag to untag */
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_INFO,"this port moves from tag to untag\r\n");
            tpm_rc = tpm_sw_set_port_vid_egress_mode(0, port_id, (UINT16)vlan_current-&gt;vlan_id, MEMBER_EGRESS_UNTAGGED);
            if (tpm_rc != TPM_RC_OK)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to Set tpm_sw_set_port_vid_egress_mode, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
                return MDW_CB_RET_SET_HW_FAIL;
            }
            continue;
        }

        if(       (0 == (vlan_current-&gt;tag_member_vec &amp; tmp_port_vec))
            &amp;&amp; (tmp_port_vec == (vlan_new-&gt;tag_member_vec &amp; tmp_port_vec))
            &amp;&amp; (tmp_port_vec == (vlan_current-&gt;untag_member_vec &amp; tmp_port_vec)))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_INFO,"this port moves from untag to tag\r\n");
            /* this port moves from untag to tag */
            tpm_rc = tpm_sw_set_port_vid_egress_mode(0, port_id, (UINT16)vlan_current-&gt;vlan_id, MEMBER_EGRESS_TAGGED);
            if (tpm_rc != TPM_RC_OK)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to Set tpm_sw_set_port_vid_egress_mode, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
                return MDW_CB_RET_SET_HW_FAIL;
            }
            continue;
        }

        //handle tag member vec
        if(       (tmp_port_vec == (vlan_current-&gt;tag_member_vec &amp; tmp_port_vec))
            &amp;&amp; (0 == (vlan_new-&gt;tag_member_vec &amp; tmp_port_vec)))
        {
            //remove port from vlan
            tpm_rc = tpm_sw_port_del_vid(0, port_id, (UINT16)vlan_current-&gt;vlan_id);
            if (tpm_rc != TPM_RC_OK)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to Set tpm_sw_port_del_vid, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
                return MDW_CB_RET_SET_HW_FAIL;
            }
        }
        else if(       (0 == (vlan_current-&gt;tag_member_vec &amp; tmp_port_vec))
                   &amp;&amp; (tmp_port_vec == (vlan_new-&gt;tag_member_vec &amp; tmp_port_vec)))
        {
            //add port into vlan
            tpm_rc = tpm_sw_port_add_vid(0, port_id, (UINT16)vlan_current-&gt;vlan_id);
            if (tpm_rc != TPM_RC_OK)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to Set tpm_sw_port_add_vid, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
                return MDW_CB_RET_SET_HW_FAIL;
            }

            tpm_rc = tpm_sw_set_port_vid_egress_mode(0, port_id, (UINT16)vlan_current-&gt;vlan_id, MEMBER_EGRESS_TAGGED);
            if (tpm_rc != TPM_RC_OK)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to Set tpm_sw_set_port_vid_egress_mode, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
                return MDW_CB_RET_SET_HW_FAIL;
            }
        }


        //handle untag member vec
        if(       (tmp_port_vec == (vlan_current-&gt;untag_member_vec &amp; tmp_port_vec))
            &amp;&amp; (0 == (vlan_new-&gt;untag_member_vec &amp; tmp_port_vec)))
        {
            //remove port from vlan
            tpm_rc = tpm_sw_port_del_vid(0, port_id, (UINT16)vlan_current-&gt;vlan_id);
            if (tpm_rc != TPM_RC_OK)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to Set tpm_sw_port_del_vid, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
                return MDW_CB_RET_SET_HW_FAIL;
            }
        }
        else if(       (0 == (vlan_current-&gt;untag_member_vec &amp; tmp_port_vec))
                   &amp;&amp; (tmp_port_vec == (vlan_new-&gt;untag_member_vec &amp; tmp_port_vec)))
        {
            //add port into vlan
            tpm_rc = tpm_sw_port_add_vid(0, port_id, (UINT16)vlan_current-&gt;vlan_id);
            if (tpm_rc != TPM_RC_OK)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to Set tpm_sw_port_add_vid, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
                return MDW_CB_RET_SET_HW_FAIL;
            }

            tpm_rc = tpm_sw_set_port_vid_egress_mode(0, port_id, (UINT16)vlan_current-&gt;vlan_id, MEMBER_EGRESS_UNTAGGED);
            if (tpm_rc != TPM_RC_OK)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to Set tpm_sw_set_port_vid_egress_mode, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
                return MDW_CB_RET_SET_HW_FAIL;
            }
        }
    }

    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_vlan_insert(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_VLAN_T   vlan_current;
    MIDWARE_TABLE_VLAN_T   *vlan_new;
    MIDWARE_CALLBACK_RET  midware_rc;


    vlan_new = (MIDWARE_TABLE_VLAN_T*)entry;

    memset(&amp;vlan_current, 0, sizeof(vlan_current));
    vlan_current.vlan_id = vlan_new-&gt;vlan_id;

    midware_rc = midware_table_vlan_cmp_set_hw(&amp;vlan_current, vlan_new);

    if (MDW_CB_RET_SET_HW_OK != midware_rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set midware_table_vlan_cmp_set_hw, vlan: %ld\r\n", vlan_new-&gt;vlan_id);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_vlan_set(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_VLAN_T   vlan_current;
    MIDWARE_TABLE_VLAN_T   *vlan_new;
    MIDWARE_CALLBACK_RET  midware_rc;
    ONU_STATUS    rc;
    MIDWARE_TABLE_INFO * table_info;

    vlan_new = (MIDWARE_TABLE_VLAN_T*)entry;

    //get current vlan
    table_info = midware_get_table_info(MIDWARE_TABLE_VLAN);

    vlan_current.vlan_id = vlan_new-&gt;vlan_id;
    rc = midware_sqlite3_get_select_sql_prepared(table_info, &amp;vlan_current);
    if( ONU_FAIL == rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get entry for vlan: %ld\n", vlan_new-&gt;vlan_id);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    midware_rc = midware_table_vlan_cmp_set_hw(&amp;vlan_current, vlan_new);

    if (MDW_CB_RET_SET_HW_OK != midware_rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set midware_table_vlan_cmp_set_hw, vlan: %ld\r\n", vlan_new-&gt;vlan_id);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_vlan_remove(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_VLAN_T   vlan_current;
    MIDWARE_TABLE_VLAN_T   *vlan_new;
    MIDWARE_CALLBACK_RET  midware_rc;
    ONU_STATUS    rc;
    MIDWARE_TABLE_INFO * table_info;

    vlan_new = (MIDWARE_TABLE_VLAN_T*)entry;

    //get current vlan
    table_info = midware_get_table_info(MIDWARE_TABLE_VLAN);

    vlan_current.vlan_id = vlan_new-&gt;vlan_id;
    rc = midware_sqlite3_get_select_sql_prepared(table_info, &amp;vlan_current);
    if( ONU_FAIL == rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get entry for vlan: %ld\n", vlan_new-&gt;vlan_id);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    vlan_new-&gt;tag_member_vec = 0;
    vlan_new-&gt;untag_member_vec = 0;

    midware_rc = midware_table_vlan_cmp_set_hw(&amp;vlan_current, vlan_new);

    if (MDW_CB_RET_SET_HW_OK != midware_rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set midware_table_vlan_cmp_set_hw, vlan: %ld\r\n", vlan_new-&gt;vlan_id);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_wan_qos_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_WAN_QOS_T    wan_qos;
    UINT32             i;
    UINT32             queue_id;
    MIDWARE_TABLE_INFO *table_info;

    //init the default entries
    wan_qos.schedule_mode = 0;
    wan_qos.weight = 0;
    wan_qos.cir = 0;
    wan_qos.pir = 0;

    table_info = midware_get_table_info(MIDWARE_TABLE_WAN_QOS);
    for(i = 0; i &lt;= 7; i++)
    {
        wan_qos.llid = i;
        for(queue_id = 0; queue_id &lt;= 7; queue_id++)
        {
            wan_qos.queue_id = queue_id;

            rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;wan_qos);
            if(ONU_OK != rc)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for llid: %ld, queue_id: %ld\n", i, queue_id);
                return ONU_FAIL;
            }
        }
    }

    return ONU_OK;
}

MIDWARE_CALLBACK_RET midware_table_wan_qos_set(UINT32 bitmap, void *entry)
{
  MIDWARE_TABLE_WAN_QOS_T   *qos_cfg;
  tpm_error_code_t                      tpm_rc = ERR_GENERAL;
  MIDWARE_CALLBACK_RET        callback_ret = MDW_CB_RET_SET_HW_NO_NEED;

  qos_cfg = (MIDWARE_TABLE_WAN_QOS_T *)entry;

  if(    (bitmap &amp; MIDWARE_ENTRY_LLID)
       || (bitmap &amp; MIDWARE_ENTRY_WAN_QUEUE_ID)
       || (bitmap &amp; MIDWARE_ENTRY_WANC_SCHEDULE_MODE)
       || (bitmap &amp; MIDWARE_ENTRY_WAN_QOS_WEIGHT))
  {
      tpm_rc = tpm_tm_set_wan_egr_queue_sched(0, TPM_TRG_PORT_WAN, qos_cfg-&gt;schedule_mode,
                                              qos_cfg-&gt;queue_id, qos_cfg-&gt;weight/100);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set tpm_tm_set_wan_egr_queue_sched, queue_id: %d\r\n", qos_cfg-&gt;queue_id);
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

  if(    (bitmap &amp; MIDWARE_ENTRY_WAN_QOS_CIR)
       || (bitmap &amp; MIDWARE_ENTRY_WAN_QOS_PIR))
  {
      if(qos_cfg-&gt;cir != 0)
      {
      tpm_rc = tpm_tm_set_wan_queue_egr_rate_lim(0, TPM_TRG_PORT_WAN,
                                                 qos_cfg-&gt;queue_id, qos_cfg-&gt;cir, qos_cfg-&gt;pir);
      if (tpm_rc != TPM_RC_OK)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to set tpm_tm_set_wan_queue_egr_rate_lim\r\n");
          return MDW_CB_RET_SET_HW_FAIL;
      }
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

   return callback_ret;
}

// COPY FROM OMCI ...
#if 1

// Utility for reading U-Boot environment
#define FW_PRINTENVSTR                   "fw_printenv"
#define FW_SETENVSTR                     "fw_setenv"
#define FALLBACK_ACTIVE_BANK             'A'
#define FALLBACK_COMMITTED_BANK          'A'
#define FALLBACK_ISVALID_A               true
#define FALLBACK_ISVALID_B               false

#define UBVSTR_DUALIMAGE                 "dual_image"
#define UBVSTR_COMMITTED                 "committedBank"
#define UBVSTR_ISVALID_A                 "isValidA"
#define UBVSTR_ISVALID_B                 "isValidB"
#define UBVSTR_VERSION_A                 "versionA"
#define UBVSTR_VERSION_B                 "versionB"
#define UBVSTR_ACTIVATION_TEST           "act_test"
#define UBVSTR_ACT_BOOT_COMPLETE         "act_boot_complete"

#define PROFCACHE_BANK_A                   'A'
#define PROFCACHE_BANK_B                   'B'

typedef enum
{
    ENUM_UBV_COMMITTED, ENUM_UBV_ISVALID_A, ENUM_UBV_ISVALID_B, ENUM_UBV_VERSION_A, ENUM_UBV_VERSION_B,
    ENUM_UBV_ACTIVATION_TEST, ENUM_UBV_DUALIMAGE
} ENUM_UBOOTVARS;

typedef struct
{
    char  *varName;
    int   varEnum;
} UBootVarParseInfo_S;

typedef struct
{
    bool     isValidA;
    bool     isValidB;
    UINT8    committedBank;
    UINT8    activeBank;
    UINT8    versionA[15];
    UINT8    versionB[15];
    bool     altImageActivationVarSet;
} SwImage_S;

static UBootVarParseInfo_S swimageVarsParseAra[] =
{
    {UBVSTR_COMMITTED,           ENUM_UBV_COMMITTED},
    {UBVSTR_ISVALID_A,           ENUM_UBV_ISVALID_A},
    {UBVSTR_ISVALID_B,           ENUM_UBV_ISVALID_B},
    {UBVSTR_VERSION_A,           ENUM_UBV_VERSION_A},
    {UBVSTR_VERSION_B,           ENUM_UBV_VERSION_B},
    {UBVSTR_ACTIVATION_TEST,     ENUM_UBV_ACTIVATION_TEST},
    {UBVSTR_DUALIMAGE,     ENUM_UBV_DUALIMAGE},
};
static int swimageVarsParseAra_size = sizeof(swimageVarsParseAra)/sizeof(swimageVarsParseAra[0]);

static bool isCommittedValueOK(char *valueStr, char *rvalchar)
{
    char *token;

    token = strtok((char *)valueStr, "\n\r");

    if (strlen(token) == 1 &amp;&amp; (toupper(valueStr[0]) == 'A' || toupper(valueStr[0]) == 'B'))
    {
        *rvalchar = toupper(valueStr[0]);
        return true;
    }
    printf("%s: Illegal value \"%s\"\n", __FUNCTION__, valueStr);
    return false;
}

static bool isIsValidValueOK(char *valueStr, bool *rvalbool)
{
    char *token;

    token = strtok((char *)valueStr, "\n\r");

    if (strcmp(token, "true") == 0)
    {
        *rvalbool = true;
        return true;
    }
    else if (strcmp(token, "false") == 0)
    {
        *rvalbool = false;
        return true;
    }
    printf("%s: Illegal value \"%s\"\n", __FUNCTION__, token);
    return false;
}

static bool isDualImageValueOK(char *valueStr, bool *rvalbool)
{
    char *token;

    token = strtok((char *)valueStr, "\n\r");

    if (strcmp(token, "yes") == 0)
    {
        *rvalbool = 1;
        return true;
    }
    else if (strcmp(token, "no") == 0)
    {
        *rvalbool = 0;
        return true;
    }
    printf("%s: Illegal value \"%s\"\n", __FUNCTION__, token);
    return false;
}

static bool isVersionValueOK(char *valueStr, char **rvalstr)
{
    unsigned int  indx;
    char *token;

    token = strtok((char *)valueStr, "\n\r");

    for (indx = 0; indx &lt; strlen(token); indx++)
    {
        if (token[indx] != ' ')
        {
            *rvalstr = &amp;token[indx];
            return true;
        }
    }
    printf("%s: Illegal value \"%s\"\n", __FUNCTION__, valueStr);
    return false;
}

static bool isImageTestActivated_SetTo1(char *valueStr, bool *rvalbool)
{
    char *token;

    token = strtok((char *)valueStr, "\n\r");

    if (strlen(token) == 1)
    {
        if (token[0] == '1')
        {
            *rvalbool = true;
            return true;
        }
        else
        {
            *rvalbool = false;
            return true;
        }
    }
    printf("%s: Illegal value %s\n", __FUNCTION__, valueStr);
    return false;
}


static bool handleUbootSwImageVar(SwImage_S *p_RawSwImage, BOOL * dual_image, char *line)
{
    int                 indx;
    UBootVarParseInfo_S *p_UBootVarParseInfo;
    bool                rc = false;
    int                 namesize;
    char                rvalchar;
    bool                rvalbool;
    char                *rvalstr;

    for (indx = 0; indx &lt; swimageVarsParseAra_size; indx++)
    {
        p_UBootVarParseInfo = &amp;swimageVarsParseAra[indx];
        namesize            = strlen(p_UBootVarParseInfo-&gt;varName);

        // Look for matching U-Boot var followed by '='
        if (strncmp(line, p_UBootVarParseInfo-&gt;varName, namesize) == 0 &amp;&amp; line[namesize] == '=')
        {
            //printf("%s: Found U-Boot var %s\n", __FUNCTION__, line);

            if (p_UBootVarParseInfo-&gt;varEnum == ENUM_UBV_COMMITTED)
            {
                if (isCommittedValueOK(&amp;line[namesize+1], &amp;rvalchar) == true)
                {
                    p_RawSwImage-&gt;committedBank = rvalchar;
                    rc = true;
                    break;
                }
            }
            else if (p_UBootVarParseInfo-&gt;varEnum == ENUM_UBV_DUALIMAGE)
            {
                if (isDualImageValueOK(&amp;line[namesize+1], &amp;rvalbool) == true)
                {
                    *dual_image = rvalbool;
                    rc = true;
                    break;
                }
            }
            else if (p_UBootVarParseInfo-&gt;varEnum == ENUM_UBV_ISVALID_A)
            {
                if (isIsValidValueOK(&amp;line[namesize+1], &amp;rvalbool) == true)
                {
                    p_RawSwImage-&gt;isValidA = rvalbool;
                    rc = true;
                    break;
                }
            }
            else if (p_UBootVarParseInfo-&gt;varEnum == ENUM_UBV_ISVALID_B)
            {
                if (isIsValidValueOK(&amp;line[namesize+1], &amp;rvalbool) == true)
                {
                    p_RawSwImage-&gt;isValidB = rvalbool;
                    rc = true;
                    break;
                }
            }
            else if (p_UBootVarParseInfo-&gt;varEnum == ENUM_UBV_VERSION_A)
            {
                if (isVersionValueOK(&amp;line[namesize+1], &amp;rvalstr) == true)
                {
                    char *token;

                    // So we do not copy \n at end of line
                    token = strtok((char *)rvalstr, "\n\r");

                    strcpy((char *)p_RawSwImage-&gt;versionA, token);
                    rc = true;
                    break;
                }
            }
            else if (p_UBootVarParseInfo-&gt;varEnum == ENUM_UBV_VERSION_B)
            {
                if (isVersionValueOK(&amp;line[namesize+1], &amp;rvalstr) == true)
                {
                    char *token;

                    // So we do not copy \n at end of line
                    token = strtok((char *)rvalstr, "\n\r");

                    strcpy((char *)p_RawSwImage-&gt;versionB, token);
                    rc = true;
                    break;
                }
            }
            else if (p_UBootVarParseInfo-&gt;varEnum == ENUM_UBV_ACTIVATION_TEST)
            {
                if (isImageTestActivated_SetTo1(&amp;line[namesize+1], &amp;rvalbool) == true)
                {
                    p_RawSwImage-&gt;altImageActivationVarSet = rvalbool;
                    rc = true;
                    break;
                }
            }
        }
    }
    return rc;
}

static void parsePrintEnv(SwImage_S *p_RawSwImage, BOOL *dual_image)
{
    char  line[500];
    int   lineIndx   = 0;
    int   parsedVars = 0;
    FILE  *fptr;
    char  *outFile = "/tmp/printenv.txt";

    sprintf(line, "%s &gt; %s", FW_PRINTENVSTR, outFile);

    if (system(line))
    {
        printf("%s: \"%s\" FAILED. \n", __FUNCTION__, line);
    }
    else
    {
        if ((fptr = fopen(outFile, "r")) != 0)
        {
            while (fgets(line, sizeof(line), fptr) != 0)
            {
                lineIndx++;
                if (handleUbootSwImageVar(p_RawSwImage, dual_image, line) == true)
                {
                    parsedVars++;
                }
            }
            //printf("%s: Read %d lines from %s output. Parsed %d variables\n", __FUNCTION__, lineIndx, FW_PRINTENVSTR, parsedVars);
        }
        else
        {
            printf("%s: fopen(%s, \"r\") FAILED. \n", __FUNCTION__, outFile);
        }
        fclose(fptr);
    }
}

static void parseLinuxCmdLine(SwImage_S *p_RawSwImage)
{
    char  line[500];
    char  *token;
    FILE  *fptr;

    // Expect the line to include "ubi.mtd=2 root=ubi0:rootfsU" for execution from flash
    //    OR
    // Expect the line to include "ubi.mtd=5 root=ubi0:rootfsB" for execution from flash

    // Read the Linux command line - to identify the active bank
    if ((fptr = fopen("/proc/cmdline","r")) != NULL)
    {
        if (fgets(line, sizeof(line), fptr) != 0)
        {
            token = strtok((char *)line, " ");
            while (token != 0)
            {
                if (strstr(token, "root=ubi0:rootfsU") != 0)
                {
                    p_RawSwImage-&gt;activeBank = 'A';
                    break;
                }
                else if (strstr(token, "root=ubi0:rootfsB") != 0)
                {
                    p_RawSwImage-&gt;activeBank = 'B';
                    break;
                }
                token = strtok(NULL, " ");
            }
        }
        else
        {
            printf("%s: Failed to get Linux cmdline\n", __FUNCTION__);
        }
        fclose(fptr);
    }
    else
    {
        printf("%s: fopen(/proc/cmdline, \"r\") FAILED.\n", __FUNCTION__);
    }
}

static BOOL readImageVersion(char *version, int length)
{
    FILE  *filehandle;
    char  line[32];
    char  *token;

    if ((filehandle = fopen("/etc/version.txt", "r")) == NULL)
    {
        printf("fopen %s failed.\n", "/etc/version.txt");
        return FALSE;
    }

    if (fgets(line, 32, filehandle) != 0)
    {
        token = strtok(line, "\n\r");

        if (strlen(token) &gt; 0)
        {
            strncpy(version, token, length);
        }
    }

    if (fclose(filehandle) != 0)
    {
        printf("%s: fclose failed.\n", __FUNCTION__);
    }

    return TRUE;
}

#endif

ONU_STATUS midware_table_sw_image_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_IMAGE_T    sw_image;
    MIDWARE_TABLE_INFO *table_info;
    SwImage_S             image_info;
    char                  line[500];
    BOOL                  dual_image ;

    memset(&amp;image_info, 0, sizeof(SwImage_S));
    parsePrintEnv(&amp;image_info, &amp;dual_image);
    parseLinuxCmdLine(&amp;image_info);

    // The code below is disconnected from U-Boot. There is no way that U-Boot bankA, bankB information can be dictated from
    // midware. E.g if (image_info.isValidA == false) CANNOT EVER MAKE image_info.isValidA = true in U-Boot
    // If absolutely necessary, OMCI will update midware.
    if (dual_image)
    {
        /*check nvram variables*/
        if (image_info.committedBank == 0)
        {
           image_info.committedBank = image_info.activeBank;
#if 0
           sprintf(line, "%s %s %c", FW_SETENVSTR, UBVSTR_COMMITTED, image_info.committedBank);
           system(line);
#endif
        }

        if (image_info.isValidA == false)
        {
#if 0
           sprintf(line, "%s %s true", FW_SETENVSTR, UBVSTR_ISVALID_A);
           system(line);
#endif
           image_info.isValidA = true;
        }

        if (image_info.isValidB == false)
        {
#if 0
           sprintf(line, "%s %s true", FW_SETENVSTR, UBVSTR_ISVALID_B);
           system(line);
#endif
           image_info.isValidB= true;
        }
    }
    else
    {
           image_info.activeBank = 'A';
           image_info.committedBank = 'A';
           image_info.isValidA = true;
           image_info.isValidB = true;
    }

    // Force version to non-null
    /*versionA may be wrong if burn new flash without resetenv*/
    if (image_info.isValidA == true)/* &amp;&amp; (strlen((char *)image_info.versionA) == 0))*/
    {
        if (image_info.activeBank == 'A')
        {
            readImageVersion((char *)image_info.versionA, sizeof(image_info.versionA)-1);

            if(strlen((char *)image_info.versionA) == 0)
            {
                strcpy((char *)image_info.versionA, "&lt;forced-A&gt;");
            }
        }
#if 0
        sprintf(line, "%s %s %s", FW_SETENVSTR, UBVSTR_VERSION_A, (char *)image_info.versionA);
        if (system(line))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"%s: \"%s\" FAILED.\n", __FUNCTION__, line);
        }
#endif
    }

    if (image_info.isValidB == true) /*&amp;&amp; (strlen((char *)image_info.versionB) == 0))*/
    {
        if (image_info.activeBank == 'B')
        {
            readImageVersion((char *)image_info.versionB, sizeof(image_info.versionB)-1);

            if(strlen((char *)image_info.versionB) == 0)
            {
                strcpy((char *)image_info.versionB, "&lt;forced-B&gt;");
            }
        }

#if 0
        sprintf(line, "%s %s %s", FW_SETENVSTR, UBVSTR_VERSION_B, (char *)image_info.versionB);
        if (system(line))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"%s: \"%s\" FAILED.\n", __FUNCTION__, line);
        }
#endif
    }


    /*add the first active image*/
    memset(&amp;sw_image,0,sizeof(sw_image));
    sw_image.image_id = MIDWARE_MIN_IMAGE_ID;
    sw_image.active_image  = (image_info.activeBank == 'A') ? 1 : 0;
    sw_image.commit_image  = (image_info.committedBank == 'A') ? 1 : 0;
    sw_image.is_valid      = image_info.isValidA;
    sw_image.burn_to_flash = 0;
    sw_image.status = MIDWARE_SW_UPDATE_NOT_STARTED;

    strncpy((char *)sw_image.verion, (char *)image_info.versionA, MIDWARE_IMAGE_VER_LEN);
    sw_image.verion[MIDWARE_IMAGE_VER_LEN] = '\0';

    //insert the entry into SQLite
    table_info = midware_get_table_info(MIDWARE_TABLE_SW_IMAGE);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;sw_image);
    if (ONU_FAIL == rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entry\n");
        return ONU_FAIL;
    }

    /*add the second inactive image*/
    memset(&amp;sw_image, 0, sizeof(sw_image));
    sw_image.image_id     = MIDWARE_MAX_IMAGE_ID;
    sw_image.active_image = (image_info.activeBank == 'B') ? 1 : 0;
    sw_image.commit_image = (image_info.committedBank == 'B') ? 1 : 0;
    sw_image.is_valid     = image_info.isValidB;
    sw_image.status       = MIDWARE_SW_UPDATE_NOT_STARTED;

    strncpy((char *)sw_image.verion, (char *)image_info.versionB, MIDWARE_IMAGE_VER_LEN);
    sw_image.verion[MIDWARE_IMAGE_VER_LEN] = '\0';

    //insert the entry into SQLite
    table_info = midware_get_table_info(MIDWARE_TABLE_SW_IMAGE);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;sw_image);
    if (ONU_FAIL == rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entry\n");
        return ONU_FAIL;
    }

    // Clear the test activation variables
    if (image_info.altImageActivationVarSet == true)
    {
        sprintf(line, "%s %s 0", FW_SETENVSTR, UBVSTR_ACTIVATION_TEST);
        if (system(line))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"%s: \"%s\" FAILED.\n", __FUNCTION__, line);
            return ONU_FAIL;
        }

        sprintf(line, "%s %s 0", FW_SETENVSTR, UBVSTR_ACT_BOOT_COMPLETE);
        if (system(line))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"%s: \"%s\" FAILED.\n", __FUNCTION__, line);
            return ONU_FAIL;
        }
    }


    return ONU_OK;
}

#define BANK_2_IMG(x)    (((x) == 'A') ? 0 : 1)
#define IMG_2_BANK(x)    (!(x) ? 'A' : 'B')

MIDWARE_CALLBACK_RET midware_table_sw_image_get(UINT32 bitmap, void *entry)
{
    MIDWARE_CALLBACK_RET   callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    MIDWARE_TABLE_IMAGE_T *image;
    BurnStatus_S           burn_state;

    image = (MIDWARE_TABLE_IMAGE_T *)entry;

    memset(&amp;burn_state, 0, sizeof(BurnStatus_S));

    if (bitmap &amp; MIDWARE_ENTRY_UPGRADE_STATUS)
    {
        if (FlashApi_getBurnStatus(&amp;burn_state))
        {
            if (image-&gt;image_id != BANK_2_IMG(burn_state.bank))
            {
                //callback_ret = MDW_CB_RET_SET_HW_FAIL;
                image-&gt;status = MIDWARE_SW_UPDATE_NOT_STARTED;
                return callback_ret;
            }

            if (burn_state.inprogress)
            {
                image-&gt;status = MIDWARE_SW_UPDATE_BUSY;
            }
            else if (burn_state.iswriteok)
            {
                image-&gt;status = MIDWARE_SW_UPDATE_OK;
                if(bitmap &amp; MIDWARE_ENTRY_IMAGE_VERSION)
                {
                    memcpy(image-&gt;verion, burn_state.bankversion, sizeof(image-&gt;verion));
                }
            }
            else
            {
                image-&gt;status = MIDWARE_SW_UPDATE_NOT_STARTED;
            }
        }
        else
        {
            callback_ret = MDW_CB_RET_SET_HW_FAIL;
        }
    }

    return callback_ret;
}

extern void sycl_reboot(int delay);

static void midware_clear_other_image_commit(UINT8 image_id)
{
    MIDWARE_TABLE_INFO      *table_info;
    ONU_STATUS              rc;
    MIDWARE_TABLE_IMAGE_T   midware_image;
    UINT32 bitmap = MIDWARE_ENTRY_IMAGE_COMMIT;

    memset(&amp;midware_image, 0 , sizeof(midware_image));
    midware_image.image_id = 1 - image_id;
    midware_image.commit_image = 0;

    table_info = midware_get_table_info(MIDWARE_TABLE_SW_IMAGE);

    midware_sqlite3_get_update_sql_prepared(table_info, bitmap, &amp;midware_image);
}

MIDWARE_CALLBACK_RET midware_table_sw_image_set(UINT32 bitmap, void *entry)
{
    MIDWARE_CALLBACK_RET   callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    MIDWARE_TABLE_IMAGE_T *image;
    UINT8 bank;
    char filename[FILENAME_SIZE], clientId[CLIENTID_SIZE];

    image = (MIDWARE_TABLE_IMAGE_T *)entry;

    memset(filename, 0, sizeof(filename));
    memset(clientId, 0, sizeof(clientId));

    bank = IMG_2_BANK(image-&gt;image_id);

    if (bitmap &amp; MIDWARE_ENTRY_IMAGE_VALID)
    {
        if (image-&gt;is_valid == 0)
        {
            if (FlashApi_setImageToInvalid(bank))
            {
            }
            else
            {
                callback_ret = MDW_CB_RET_SET_HW_FAIL;
            }
        }
    }

    if (bitmap &amp; MIDWARE_ENTRY_IMAGE_TO_FLASH)
    {
        if (image-&gt;burn_to_flash)
        {
            strcpy(filename, image-&gt;image_file_name);
            if(TPM_EPON == wanTech)
            {
                clientId[0] = 'e'; clientId[1] = 'O'; clientId[2] = 'A'; clientId[3] = 'M'; 
            }
            else
            {
                clientId[0] = 'O'; clientId[1] = 'M'; clientId[2] = 'C'; clientId[3] = 'I'; 
            }

            if (FlashApi_setImageToInvalid(bank))
            {
                // TODO: invalidate current image.

                if (FlashApi_startWriteFlash(bank, filename, clientId))
                {
                }
                else
                {
                    callback_ret = MDW_CB_RET_SET_HW_FAIL;
                }
            }
            else
            {
                callback_ret = MDW_CB_RET_SET_HW_FAIL;
            }
        }
    }

    if (bitmap &amp; MIDWARE_ENTRY_IMAGE_ACTIVE)
    {
        if (FlashApi_prepareImageActivation(bank))
        {
            callback_ret = MDW_CB_RET_SET_HW_OK;
            if(TPM_EPON == wanTech)
            {
            sycl_reboot(3000);
        }

        }
        else
        {
            callback_ret = MDW_CB_RET_SET_HW_FAIL;
        }
    }

    if (bitmap &amp; MIDWARE_ENTRY_IMAGE_COMMIT)
    {
        if (FlashApi_setCommittedBank(bank))
        {
            midware_clear_other_image_commit(image-&gt;image_id);
            callback_ret = MDW_CB_RET_SET_HW_OK;
        }
        else
        {
            callback_ret = MDW_CB_RET_SET_HW_FAIL;
        }
    }

    if (bitmap &amp; MIDWARE_ENTRY_IMAGE_ABORT)
    {
        if (FlashApi_abortWriteFlash())
        {
            callback_ret = MDW_CB_RET_SET_HW_OK;
        }
        else
        {
            callback_ret = MDW_CB_RET_SET_HW_FAIL;
        }
    }

    return callback_ret;
}

ONU_STATUS midware_table_opt_transceiver_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_TRANSCEIVER_T    opt_transceiver;
    MIDWARE_TABLE_INFO *table_info;

    //init the default entries
    memset(&amp;opt_transceiver,0,sizeof(opt_transceiver));


    table_info = midware_get_table_info(MIDWARE_TABLE_OPT_TRANSCEIVER);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;opt_transceiver);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entriy for MIDWARE_TABLE_OPT_TRANSCEIVER\n");
        return ONU_FAIL;
    }

    return ONU_OK;
}

MIDWARE_CALLBACK_RET midware_table_opt_transceiver_get(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_TRANSCEIVER_T         *opt_transceiver;
    OnuXvrA2D_S                         onuXvrA2D;
    bool                               rc;
    bool                                enable;
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;

    opt_transceiver = (MIDWARE_TABLE_TRANSCEIVER_T *)entry;

    if(is_support_onu_xvr_I2c &gt; 0)
    {
        rc = localI2cApi_getOnuXvrA2dValues(&amp;onuXvrA2D);
        if (true != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to localI2cApi_getOnuXvrA2dValues\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }

        opt_transceiver-&gt;temperature = (UINT16)onuXvrA2D.temperature;
        opt_transceiver-&gt;supply_voltage = (UINT16)onuXvrA2D.supplyVoltage;
        opt_transceiver-&gt;bias_current = (UINT16)onuXvrA2D.txBiasCurrent;
        opt_transceiver-&gt;tx_power = (UINT16)onuXvrA2D.txOpticalPower;
        opt_transceiver-&gt;rx_power = (UINT16)onuXvrA2D.rxReceivedPower;

        callback_ret = MDW_CB_RET_SET_HW_OK;
    }
    else
    {
        //callback_ret = MDW_CB_RET_SET_HW_FAIL;
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }


     return callback_ret;
}

ONU_STATUS midware_table_epon_auth_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_LOID_T    epon_auth;
    MIDWARE_TABLE_INFO *table_info;
    char *default_admin = "admin";

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_EPON_AUTH))
    {
        //already got entries in the table,
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;epon_auth,0,sizeof(epon_auth));
    epon_auth.auth_mode = 0;
    //memcpy(epon_auth.loid, default_admin, sizeof("admin"));
    strcpy(epon_auth.loid, default_admin);
    //memcpy(epon_auth.pwd, default_admin, sizeof("admin"));
    strcpy(epon_auth.pwd, default_admin);

    table_info = midware_get_table_info(MIDWARE_TABLE_EPON_AUTH);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;epon_auth);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_EPON_AUTH\n");
        return ONU_FAIL;
    }

    return ONU_OK;
}

ONU_STATUS midware_table_web_account_init(void)
{
    ONU_STATUS           rc;
    MIDWARE_TABLE_WEB_ACCOUNT_T web_account;
    MIDWARE_TABLE_INFO   *table_info;
    char *default_account = "admin";

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_WEB_ACCOUNT))
    {
        //already got entries in the table, restore
        rc = midware_table_restore(MIDWARE_TABLE_WEB_ACCOUNT);
        if (ONU_OK == rc)
        {
            return ONU_OK;

        }
        else
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to restore MIDWARE_TABLE_WEB_ACCOUNT\r\n");
            return ONU_FAIL;
        }
    }

    //init the default entries
    memset(&amp;web_account,0,sizeof(web_account));
    web_account.account_type = 0;
    strcpy(web_account.name, default_account);
    strcpy(web_account.pwd, default_account);

    table_info = midware_get_table_info(MIDWARE_TABLE_WEB_ACCOUNT);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;web_account);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_WEB_ACCOUNT\n");
        return ONU_FAIL;
    }

    return ONU_OK;
}

ONU_STATUS midware_table_rstp_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_RSTP_T    rstp;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_RSTP))
    {
        //already got entries in the table,
        return ONU_OK;
    }

    //init the default entries
    rstp.index = 0;
    rstp.rstp_en = MIDWARE_SFU_ENABLE;
    rstp.bridge_pri = MIDWARE_SFU_BRIDGE_PRIORITY;
    rstp.fwd_delay = MIDWARE_SFU_FWD_DELAY;
    rstp.hello_time = MIDWARE_SFU_HELLO_TIME;
    rstp.age_time = MIDWARE_SFU_AGE_TIME;

    table_info = midware_get_table_info(MIDWARE_TABLE_RSTP);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;rstp);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entriy for MIDWARE_TABLE_RSTP\n");
        return ONU_FAIL;
    }

    return ONU_OK;
}

MIDWARE_CALLBACK_RET midware_table_rstp_get(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_RSTP_T               *rstp;
    INT32                                                            rc;
    bool                                                   enable;
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;

    rstp = (MIDWARE_TABLE_RSTP_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_RSTP_STATE)
    {
        rc = RSTP_get_enable(&amp;enable);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to RSTP_get_enable\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        rstp-&gt;rstp_en = MIDWARE_BOOL_TO_U8(enable) ;
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    #if 0
    if(bitmap &amp; MIDWARE_ENTRY_RSTP_BRIDGE_PRI)
    {
        rc = RSTP_get_bridge_priority(&amp;rstp-&gt;bridge_pri);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to RSTP_get_bridge_priority\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

     if(    (bitmap &amp; MIDWARE_ENTRY_RSTP_FWD_DELAY)
          || (bitmap &amp; MIDWARE_ENTRY_RSTP_HELLO_TIME)
          || (bitmap &amp; MIDWARE_ENTRY_RSTP_AGE_TIME))
     {
         rc = RSTP_get_time(&amp;rstp-&gt;fwd_delay, &amp;rstp-&gt;hello_time, &amp;rstp-&gt;age_time);
         if (OK != rc)
         {
             MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to RSTP_get_time\r\n");
             return MDW_CB_RET_SET_HW_FAIL;
         }
         callback_ret = MDW_CB_RET_SET_HW_OK;
     }

    #endif

     return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_rstp_set(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_RSTP_T               *rstp;
    INT32                                                            rc;
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;

    rstp = (MIDWARE_TABLE_RSTP_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_RSTP_STATE)
    {
        rc = RSTP_set_enable(MIDWARE_U8_TO_BOOL(rstp-&gt;rstp_en));
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to RSTP_set_enable\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_RSTP_BRIDGE_PRI)
    {
        rc = RSTP_set_bridge_priority(rstp-&gt;bridge_pri);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to RSTP_set_time\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

     if(    (bitmap &amp; MIDWARE_ENTRY_RSTP_FWD_DELAY)
          || (bitmap &amp; MIDWARE_ENTRY_RSTP_HELLO_TIME)
          || (bitmap &amp; MIDWARE_ENTRY_RSTP_AGE_TIME))
     {
         rc = RSTP_set_time(rstp-&gt;fwd_delay, rstp-&gt;hello_time, rstp-&gt;age_time);
         if (OK != rc)
         {
             MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to RSTP_set_time\r\n");
             return MDW_CB_RET_SET_HW_FAIL;
         }
         callback_ret = MDW_CB_RET_SET_HW_OK;
     }

     return callback_ret;
}

ONU_STATUS midware_table_rstp_port_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_RSTP_PORT_T    rstp_port;
    UINT32             i;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_RSTP_PORT))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    rstp_port.rstp_en = MIDWARE_SFU_ENABLE;
    rstp_port.port_pri = MIDWARE_SFU_PORT_PRIORITY;

    table_info = midware_get_table_info(MIDWARE_TABLE_RSTP_PORT);
    for(i = TPM_SRC_PORT_UNI_0; i &lt;= TPM_SRC_PORT_UNI_3; i++)
    {
        rstp_port.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;rstp_port);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for port: %ld\n", i);
            return ONU_FAIL;
        }
    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_rstp_port_get(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_RSTP_PORT_T               *rstp;
    INT32                                                            rc;
    bool                                                   enable;
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;

    rstp = (MIDWARE_TABLE_RSTP_PORT_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_RSTP_PORT_STATE)
    {
        rc = RSTP_port_get_enable(rstp-&gt;port_id, &amp;enable);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to RSTP_port_get_enable\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        rstp-&gt;rstp_en = MIDWARE_BOOL_TO_U8(enable) ;
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    #if 0
    if(bitmap &amp; MIDWARE_ENTRY_RSTP_PORT_PRI)
    {
        rc = RSTP_get_priority(rstp-&gt;port_id, &amp;rstp-&gt;port_pri);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to RSTP_get_bridge_priority\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }
    #endif

     return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_mc_port_set_to_igmp(MIDWARE_TABLE_MC_PORT_CFG_T *mc_port)
{
    INT32                                                            rc;
    ONU_STATUS      midware_rc;
    MIDWARE_TABLE_MC_DS_VLAN_TRANS_T  *mc_vlan;
    MIDWARE_TABLE_INFO *table_info;
    UINT32    mc_vlan_num;
    MULTICAST_PORT_TAG_OPER_T tag_strip;
    UINT32    i;

    /*
    1. get all the current mc vlan for this port
    2. get mc port cfg for this port
    3. set these info to IGMP module
    */
    memset(&amp;tag_strip, 0, sizeof(tag_strip));

    tag_strip.us_tag_oper = mc_port-&gt;us_tag_oper;
    tag_strip.ds_tag_oper = mc_port-&gt;ds_tag_oper;
    tag_strip.us_tag_default_tci = mc_port-&gt;us_tag_default_tci;
    tag_strip.ds_tag_default_tci = mc_port-&gt;ds_tag_default_tci;
    tag_strip.multicast_ds_vlan_switching.number_of_entries = 0;

    mc_vlan_num = midware_sqlite3_get_entry_count(MIDWARE_TABLE_MC_DS_VLAN_TRANS);
    if((tag_strip.ds_tag_oper != IGMP_REPLACE_VLAN_ID_DOWN)
        ||(tag_strip.ds_tag_default_tci != MIDWARE_TAG_TCI_NO_USE) || (mc_vlan_num == 0))
    {
        //not ctc IGMP_REPLACE_VLAN_ID_DOWN or no vlan for this port
        rc = IGMP_set_multicast_tag_strip(mc_port-&gt;port_id, &amp;tag_strip);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_set_multicast_tag_strip\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        return MDW_CB_RET_SET_HW_OK;
    }

    mc_vlan = malloc(mc_vlan_num * sizeof(MIDWARE_TABLE_MC_DS_VLAN_TRANS_T));
    if( 0 == mc_vlan )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't malloc mem for MIDWARE_TABLE_MC_DS_VLAN_TRANS_T entry for num: %ld\n", mc_vlan_num);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    midware_rc = midware_sqlite3_get_all_entry(MIDWARE_TABLE_MC_DS_VLAN_TRANS, &amp;mc_vlan_num, mc_vlan);
    if( ONU_FAIL == midware_rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get all_entry for MIDWARE_TABLE_MC_DS_VLAN_TRANS for port: %ld\n", mc_port-&gt;port_id);
        free(mc_vlan);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    for(i = 0; i &lt; mc_vlan_num; i++)
    {
        if( mc_vlan[i].port_id != mc_port-&gt;port_id)
        {
            continue;
        }

        tag_strip.multicast_ds_vlan_switching.entries[tag_strip.multicast_ds_vlan_switching.number_of_entries].in_vid = mc_vlan[i].in_vid;
        tag_strip.multicast_ds_vlan_switching.entries[tag_strip.multicast_ds_vlan_switching.number_of_entries].out_vid = mc_vlan[i].out_vid;
        tag_strip.multicast_ds_vlan_switching.number_of_entries++;
    }

    rc = IGMP_set_multicast_tag_strip(mc_port-&gt;port_id, &amp;tag_strip);
    free(mc_vlan);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_set_multicast_tag_strip\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }
    return MDW_CB_RET_SET_HW_OK;
}

/*the fun must be call for ctc downstream vlan translate vid set*/
MIDWARE_CALLBACK_RET midware_table_mc_ds_vlan_set_to_igmp(MIDWARE_TABLE_MC_DS_VLAN_TRANS_T *entry,
    MIDWARE_MC_VLAN_OPERATION op)
{
    INT32                                                            rc;
    ONU_STATUS      midware_rc;
    MIDWARE_TABLE_MC_PORT_CFG_T  mc_port;
    MIDWARE_TABLE_MC_DS_VLAN_TRANS_T  *mc_vlan;
    MIDWARE_TABLE_INFO *table_info;
    UINT32    mc_vlan_num;
    MULTICAST_PORT_TAG_OPER_T tag_strip;
    UINT32    i;
    UINT32 port_id = entry-&gt;port_id;

    /*
    1. get all the current mc vlan for this port
    2. get mc port cfg for this port
    3. set these info to IGMP module
    */
    memset(&amp;tag_strip, 0, sizeof(tag_strip));
    mc_port.port_id = port_id;
    table_info = midware_get_table_info(MIDWARE_TABLE_MC_PORT_CFG);
    midware_rc = midware_sqlite3_get_select_sql_prepared(table_info, &amp;mc_port);
    if( ONU_FAIL == midware_rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get MIDWARE_TABLE_MC_PORT_CFG entry for port: %ld\n", port_id);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    /*MIDWARE_TAG_TCI_NO_USE mean now is ctc downstream vlan translate*/
    mc_port.ds_tag_default_tci = MIDWARE_TAG_TCI_NO_USE;

    tag_strip.us_tag_oper = mc_port.us_tag_oper;
    tag_strip.ds_tag_oper = mc_port.ds_tag_oper;
    tag_strip.us_tag_default_tci = mc_port.us_tag_default_tci;
    tag_strip.ds_tag_default_tci = mc_port.ds_tag_default_tci;
    tag_strip.multicast_ds_vlan_switching.number_of_entries = 0;

    mc_vlan_num = midware_sqlite3_get_entry_count(MIDWARE_TABLE_MC_DS_VLAN_TRANS);
    if(0 == mc_vlan_num &amp;&amp; op != MDW_MC_VLAN_INSETT)
    {
        //no vlan for this port
        rc = IGMP_set_multicast_tag_strip(port_id, &amp;tag_strip);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_set_multicast_tag_strip\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        return MDW_CB_RET_SET_HW_OK;
    }

    mc_vlan = malloc(mc_vlan_num * sizeof(MIDWARE_TABLE_MC_DS_VLAN_TRANS_T));
    if( 0 == mc_vlan )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't malloc mem for MIDWARE_TABLE_MC_DS_VLAN_TRANS_T entry for num: %ld\n", mc_vlan_num);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    midware_rc = midware_sqlite3_get_all_entry(MIDWARE_TABLE_MC_DS_VLAN_TRANS, &amp;mc_vlan_num, mc_vlan);
    if( ONU_FAIL == midware_rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get all_entry for MIDWARE_TABLE_MC_DS_VLAN_TRANS for port: %ld\n", port_id);
        free(mc_vlan);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    for(i = 0; i &lt; mc_vlan_num; i++)
    {
        if( mc_vlan[i].port_id != port_id)
        {
            continue;
        }

        /*is update mc vlan*/
        if(mc_vlan[i].in_vid == entry-&gt;in_vid)
        {
            if(MDW_MC_VLAN_UPDATE == op)
            {
                mc_vlan[i].out_vid = entry-&gt;out_vid;
            }
            else if(MDW_MC_VLAN_REMOVE == op)
            {
                continue;
            }
        }

        tag_strip.multicast_ds_vlan_switching.entries[tag_strip.multicast_ds_vlan_switching.number_of_entries].in_vid = mc_vlan[i].in_vid;
        tag_strip.multicast_ds_vlan_switching.entries[tag_strip.multicast_ds_vlan_switching.number_of_entries].out_vid = mc_vlan[i].out_vid;
        tag_strip.multicast_ds_vlan_switching.number_of_entries++;
    }

    if(MDW_MC_VLAN_INSETT == op)
    {
        tag_strip.multicast_ds_vlan_switching.entries[tag_strip.multicast_ds_vlan_switching.number_of_entries].in_vid = entry-&gt;in_vid;
        tag_strip.multicast_ds_vlan_switching.entries[tag_strip.multicast_ds_vlan_switching.number_of_entries].out_vid = entry-&gt;out_vid;
        tag_strip.multicast_ds_vlan_switching.number_of_entries++;
    }

    rc = IGMP_set_multicast_tag_strip(port_id, &amp;tag_strip);
    free(mc_vlan);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_set_multicast_tag_strip\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    midware_rc = midware_sqlite3_get_update_sql_prepared(table_info, MIDWARE_ENTRY_MC_DS_TAG_DEF_TCI, mc_port);
    if( ONU_FAIL == midware_rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't update MIDWARE_ENTRY_MC_DS_TAG_DEF_TCI entry for port: %ld\n", port_id);
        return MDW_CB_RET_SET_HW_FAIL;
    }
    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_rstp_port_set(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_RSTP_PORT_T               *rstp;
    INT32                                                            rc;
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;

    rstp = (MIDWARE_TABLE_RSTP_PORT_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_RSTP_PORT_STATE)
    {
        rc = RSTP_port_set_enable(rstp-&gt;port_id, MIDWARE_U8_TO_BOOL(rstp-&gt;rstp_en));
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to RSTP_port_set_enable\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }

        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_RSTP_PORT_PRI)
    {
        rc = RSTP_set_priority(rstp-&gt;port_id, rstp-&gt;port_pri);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to RSTP_set_bridge_priority\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

     return callback_ret;
}

ONU_STATUS midware_table_mc_cfg_init(void)
{
    MIDWARE_TABLE_MC_CFG_T McCfg;
    ONU_STATUS rc;
    MIDWARE_TABLE_INFO *table_info;

    //get all the attr from XML
    //for now, there is no XML
    memset(&amp;McCfg,0,sizeof(McCfg));
    McCfg.igmp_version       = MIDWARE_IGMP_VERSION_3;
    McCfg.mc_mode            = MIDWARE_MC_TYPE_IGMP_SNOOPING;
    McCfg.filter_mode        = MIDWARE_MC_CTRL_TYPE_DA_VID;
    McCfg.fast_leave_ability = MIDWARE_MC_IGMP_SNOOPING_NON_FAST_LEAVE_SUPPORT|MIDWARE_MC_IGMP_SNOOPING_FAST_LEAVE_SUPPORT|MIDWARE_MC_CTC_CONTROL_FAST_LEAVE_SUPPORT|MIDWARE_MC_CTC_CONTROL_NON_FAST_LEAVE_SUPPORT;
    McCfg.fast_leave_state   = MIDWARE_FAST_LEAVE_ADMIN_STATE_ENABLED;


    //insert the entry into SQLite
    table_info = midware_get_table_info(MIDWARE_TABLE_MC_CFG);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;McCfg);
     if(ONU_FAIL == rc)
     {
         MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entry\n");
         return ONU_FAIL;
     }

     return ONU_OK;
}

MIDWARE_CALLBACK_RET midware_table_mc_cfg_get(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    MIDWARE_TABLE_MC_CFG_T              *McCfg;
    MULTICAST_CONTROL_T                 mc_control;
    MULTICAST_PROTOCOL_T                multicast_protocol;
    IGMP_FAST_LEAVE_ADMIN_STATE_T       fast_leave_admin_state;
    MULTICAST_FAST_LEAVE_ABILITY_T      fast_leave_ability;
    int i=0;

    McCfg = (MIDWARE_TABLE_MC_CFG_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_IMGP_VERSION)
    {
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_MODE)
    {
        rc = IGMP_get_multicast_switch(&amp;multicast_protocol);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_get_multicast_switch\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        McCfg-&gt;mc_mode = (UINT8)multicast_protocol;
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_FILTER_MODE)
    {
        rc = IGMP_get_multicast_control(&amp;mc_control);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_get_multicast_control\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }

        McCfg-&gt;filter_mode = (UINT8)mc_control.control_type;
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_FAST_ABILITY)
    {
        rc = IGMP_get_fast_leave_ability(&amp;fast_leave_ability);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_get_multicast_switch\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }

        McCfg-&gt;fast_leave_ability = 0;
        for(i=0;i&lt;fast_leave_ability.num_of_modes;i++)
        {
            switch (fast_leave_ability.modes[i])
            {
                case IGMP_SNOOPING_NON_FAST_LEAVE_SUPPORT:
                    McCfg-&gt;fast_leave_ability |= 1&lt;&lt;0;
                    break;
                case IGMP_SNOOPING_FAST_LEAVE_SUPPORT:
                    McCfg-&gt;fast_leave_ability |= 1&lt;&lt;1;
                    break;
                case IGMP_MC_CONTROL_NON_FAST_LEAVE_SUPPORT:
                    McCfg-&gt;fast_leave_ability |= 1&lt;&lt;2;
                    break;
                case IGMP_MC_CONTROL_FAST_LEAVE_SUPPORT:
                    McCfg-&gt;fast_leave_ability |= 1&lt;&lt;3;
                    break;
                case IGMP_MLD_SNOOPING_NON_FAST_LEAVE_SUPPORT:
                    McCfg-&gt;fast_leave_ability |= 1&lt;&lt;4;
                    break;
                case IGMP_MLD_SNOOPING_FAST_LEAVE_SUPPORT:
                    McCfg-&gt;fast_leave_ability |= 1&lt;&lt;5;
                    break;
                default:
                    break;
            }
        }

        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_FAST_STATE)
    {
        rc = IGMP_get_fast_leave_admin_state(&amp;fast_leave_admin_state);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_get_multicast_switch\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        McCfg-&gt;fast_leave_state = (UINT8)fast_leave_admin_state;
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

     return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_mc_cfg_set(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_MC_CFG_T              *McCfg;
    MULTICAST_CONTROL_T                 mc_control;
    MULTICAST_PROTOCOL_T                multicast_protocol;
    IGMP_FAST_LEAVE_ADMIN_STATE_T       fast_leave_admin_state;
    INT32                               rc;
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;

    McCfg = (MIDWARE_TABLE_MC_CFG_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_IMGP_VERSION)
    {
        multicast_protocol = (MULTICAST_PROTOCOL_T)McCfg-&gt;mc_mode;
        rc = IGMP_set_multicast_switch(&amp;multicast_protocol);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_set_multicast_switch\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }

        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_MODE)
    {
        multicast_protocol = (MULTICAST_PROTOCOL_T)McCfg-&gt;mc_mode;
        rc = IGMP_set_multicast_switch(&amp;multicast_protocol);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_set_multicast_switch\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }

        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_FILTER_MODE)
    {
        rc = IGMP_get_multicast_control(&amp;mc_control);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_get_multicast_control\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }

        mc_control.control_type = (MULTICAST_CONTROL_TYPE_T)McCfg-&gt;filter_mode;
        rc = IGMP_set_multicast_control(&amp;mc_control);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_get_multicast_control\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }

        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_FAST_STATE)
    {
        fast_leave_admin_state = (IGMP_FAST_LEAVE_ADMIN_STATE_T)McCfg-&gt;fast_leave_state;
        rc = IGMP_set_fast_leave_admin_control(&amp;fast_leave_admin_state);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_set_fast_leave_admin_control\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }

        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

     return callback_ret;
}

ONU_STATUS midware_table_mc_port_init(void)
{
    ONU_STATUS                     rc;
    MIDWARE_TABLE_MC_PORT_CFG_T    mc_port;
    UINT32                         i;
    MIDWARE_TABLE_INFO            *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_MC_PORT_CFG))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;mc_port, 0, sizeof(mc_port));
    mc_port.us_igmp_rate          = MIDWARE_IGMP_MAX_RATE;
    mc_port.max_group_num         = MIDWARE_SFU_MAX_GROUP_NUM;
    mc_port.us_tag_oper           = IGMP_NO_OP_VLAN_TAG;
    mc_port.us_tag_default_tci    = MIDWARE_TAG_TCI_NO_USE;
    mc_port.ds_tag_default_tci    = MIDWARE_TAG_TCI_NO_USE;
    mc_port.robust                = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port.query_interval        = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port.query_interval        = MIDWARE_IGMP_QUERY_DEFT_INTERVAL;
    mc_port.query_max_resp_time   = MIDWARE_IGMP_MAX_RESP_TIME;
    mc_port.last_query_time       = MIDWARE_IGMP_LAST_QUERY_TIME;
    mc_port.unauth_join_behaviour = MIDWARE_DEFAULT_ZERO_VAL;

    table_info = midware_get_table_info(MIDWARE_TABLE_MC_PORT_CFG);
    for(i = TPM_SRC_PORT_UNI_0; i &lt;= TPM_SRC_PORT_UNI_3; i++)
    {
        mc_port.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;mc_port);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_MC_PORT_CFG port: %ld\n", i);
            return ONU_FAIL;
        }
    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_mc_port_get(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    MIDWARE_TABLE_MC_PORT_CFG_T    *mc_port;
    MULTICAST_PORT_TAG_OPER_T tag_oper;

    mc_port = (MIDWARE_TABLE_MC_PORT_CFG_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_MC_MAX_GROUP)
    {
        rc = IGMP_get_multicast_group_num(mc_port-&gt;port_id, &amp;mc_port-&gt;max_group_num);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_get_multicast_group_num\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_US_TAG_OPER)
    {
        rc = IGMP_get_multicast_tag_strip(mc_port-&gt;port_id, &amp;tag_oper);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_get_multicast_tag_strip\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        mc_port-&gt;us_tag_oper = tag_oper.us_tag_oper;
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_DS_TAG_OPER)
    {
        rc = IGMP_get_multicast_tag_strip(mc_port-&gt;port_id, &amp;tag_oper);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_get_multicast_tag_strip\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        mc_port-&gt;ds_tag_oper = tag_oper.ds_tag_oper;
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

     return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_mc_port_set(UINT32 bitmap, void *entry)
{
    INT32                            rc;
    MIDWARE_CALLBACK_RET             callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    MIDWARE_TABLE_MC_PORT_CFG_T      mc_port;
    MIDWARE_TABLE_MC_PORT_CFG_T     *p_mc_port_cfg;
    MIDWARE_TABLE_INFO              *table_info;
    ONU_STATUS                       midware_rc;

    p_mc_port_cfg = (MIDWARE_TABLE_MC_PORT_CFG_T *)entry;

    mc_port.port_id = p_mc_port_cfg-&gt;port_id;
    table_info = midware_get_table_info(MIDWARE_TABLE_MC_PORT_CFG);
    midware_rc = midware_sqlite3_get_select_sql_prepared(table_info, &amp;mc_port);
    if( ONU_FAIL == midware_rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get MIDWARE_TABLE_MC_PORT_CFG entry for port: %ld\n", p_mc_port_cfg-&gt;port_id);
        return MDW_CB_RET_SET_HW_FAIL;
    }


    if(bitmap &amp; MIDWARE_ENTRY_MC_MAX_GROUP)
    {
        rc = IGMP_set_multicast_group_num(p_mc_port_cfg-&gt;port_id, p_mc_port_cfg-&gt;max_group_num);
        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to IGMP_set_multicast_group_num\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_US_TAG_OPER)
    {
        mc_port.us_tag_oper = p_mc_port_cfg-&gt;us_tag_oper;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_DS_TAG_OPER)
    {
        mc_port.ds_tag_oper = p_mc_port_cfg-&gt;ds_tag_oper;
    }


    if(bitmap &amp; MIDWARE_ENTRY_MC_US_TAG_DEF_TCI)
    {
        mc_port.us_tag_default_tci = p_mc_port_cfg-&gt;us_tag_default_tci;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_DS_TAG_DEF_TCI)
    {
        mc_port.ds_tag_default_tci = p_mc_port_cfg-&gt;ds_tag_default_tci;
    }

    if(bitmap &amp; (MIDWARE_ENTRY_MC_US_TAG_OPER | MIDWARE_ENTRY_MC_DS_TAG_OPER | MIDWARE_ENTRY_MC_US_TAG_DEF_TCI | MIDWARE_ENTRY_MC_DS_TAG_DEF_TCI))
    {
        callback_ret = midware_table_mc_port_set_to_igmp(&amp;mc_port);
        if (MDW_CB_RET_SET_HW_FAIL == rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to midware_table_mc_vlan_set\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
    }

     return callback_ret;
}

ONU_STATUS midware_table_mc_port_status_init(void)
{
    ONU_STATUS                        rc;
    MIDWARE_TABLE_MC_PORT_STATUS_T    mc_port_status;
    UINT32                            i;
    MIDWARE_TABLE_INFO               *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_MC_PORT_STATUS))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;mc_port_status, 0, sizeof(mc_port_status));
    mc_port_status.mc_current_bw      = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_status.join_count         = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_status.exceed_bw_count    = MIDWARE_DEFAULT_ZERO_VAL;

    table_info = midware_get_table_info(MIDWARE_TABLE_MC_PORT_STATUS);
    for(i = TPM_SRC_PORT_UNI_0; i &lt;= TPM_SRC_PORT_UNI_3; i++)
    {
        mc_port_status.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;mc_port_status);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_MC_PORT_STATUS port: %ld\n", i);
            return ONU_FAIL;
        }
    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_mc_port_status_get(UINT32 bitmap, void *entry)
{
    INT32                            rc;
    MIDWARE_CALLBACK_RET             callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    MIDWARE_TABLE_MC_PORT_STATUS_T  *mc_port;

    mc_port = (MIDWARE_TABLE_MC_PORT_STATUS_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_MC_CURRENT_BW)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_JOIN_MSG_COUNTET)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_EXCEED_BW_COUNT)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

     return callback_ret;
}

ONU_STATUS midware_table_mc_port_acl_init(void)
{
    ONU_STATUS                        rc;
    MIDWARE_TABLE_MC_PORT_CTRL_T      mc_port_acl;
    UINT32                            i;
    MIDWARE_TABLE_INFO               *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_MC_PORT_CONTROL))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;mc_port_acl, 0, sizeof(mc_port_acl));
    mc_port_acl.table_type           = MIDWARE_MC_ACL_DYNAMIC_TABLE;
    mc_port_acl.set_ctrl             = MIDWARE_MC_SET_TYPE_RESERVED;
    mc_port_acl.row_key              = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_acl.gem_port             = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_acl.src_ip               = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_acl.dst_ip_start         = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_acl.dst_ip_end           = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_acl.imputed_group_bw     = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_acl.preview_len          = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_acl.preview_repeat_time  = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_acl.preview_repeat_count = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_acl.preview_reset_time   = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_acl.vendor_spec          = MIDWARE_DEFAULT_ZERO_VAL;

    table_info = midware_get_table_info(MIDWARE_TABLE_MC_PORT_CONTROL);
    for(i = TPM_SRC_PORT_UNI_0; i &lt;= TPM_SRC_PORT_UNI_3; i++)
    {
        mc_port_acl.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;mc_port_acl);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_MC_PORT_CONTROL port: %ld\n", i);
            return ONU_FAIL;
        }
    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_mc_port_acl_set(UINT32 bitmap, void *entry)
{
    INT32                         rc;
    MIDWARE_CALLBACK_RET          callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    mrvl_eth_mc_port_ctrl_t       mc_port_acl;
    MIDWARE_TABLE_MC_PORT_CTRL_T *p_mc_port_acl;
    MIDWARE_TABLE_INFO           *table_info;
    ONU_STATUS                    midware_rc;

    p_mc_port_acl = (MIDWARE_TABLE_MC_PORT_CTRL_T *)entry;

    mc_port_acl.port_id = p_mc_port_acl-&gt;port_id;

    table_info = midware_get_table_info(MIDWARE_TABLE_MC_PORT_CONTROL);
    midware_rc = midware_sqlite3_get_select_sql_prepared(table_info, &amp;mc_port_acl);
    if( ONU_FAIL == midware_rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get MIDWARE_TABLE_MC_PORT_CONTROL entry for port: %ld\n", p_mc_port_acl-&gt;port_id);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_TABLE_TYPE)
    {
        mc_port_acl.table_type = p_mc_port_acl-&gt;table_type;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_SET_TYPE)
    {
        mc_port_acl.set_ctrl = p_mc_port_acl-&gt;set_ctrl;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_ROW_KEY)
    {
        mc_port_acl.row_key = p_mc_port_acl-&gt;row_key;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_GEM_PORT)
    {
        mc_port_acl.gem_port = p_mc_port_acl-&gt;gem_port;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_VID)
    {
        mc_port_acl.ani_vid = p_mc_port_acl-&gt;ani_vid;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_SRC_IP)
    {
        mc_port_acl.src_ip = p_mc_port_acl-&gt;src_ip;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_DST_IP_START)
    {
        mc_port_acl.dst_ip_start = p_mc_port_acl-&gt;dst_ip_start;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_DST_IP_END)
    {
        mc_port_acl.dst_ip_end = p_mc_port_acl-&gt;dst_ip_end;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_GROUP_BW)
    {
     mc_port_acl.imputed_group_bw = p_mc_port_acl-&gt;imputed_group_bw;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_SRC_IPV6)
    {
        memcpy(mc_port_acl.src_ipv6, p_mc_port_acl-&gt;src_ipv6, sizeof(mc_port_acl.src_ipv6));
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_DST_IPV6)
    {
        memcpy(mc_port_acl.dst_ipv6, p_mc_port_acl-&gt;dst_ipv6, sizeof(mc_port_acl.dst_ipv6));
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_PREVIEW_LEN)
    {
        mc_port_acl.preview_len = p_mc_port_acl-&gt;preview_len;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_PREVIEW_TIME)
    {
        mc_port_acl.preview_repeat_time = p_mc_port_acl-&gt;preview_repeat_time;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_PREVIEW_COUNT)
    {
     mc_port_acl.preview_repeat_count = p_mc_port_acl-&gt;preview_repeat_count;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_PREVIEW_RESET)
    {
        mc_port_acl.preview_reset_time = p_mc_port_acl-&gt;preview_reset_time;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_CTRL_VENDOR_SPEC)
    {
        mc_port_acl.vendor_spec = p_mc_port_acl-&gt;vendor_spec;
    }

    rc = IGMP_set_acl_rule(&amp;mc_port_acl);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to call IGMP_set_acl_rule\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    return callback_ret;
}


ONU_STATUS midware_table_mc_port_serv_init(void)
{
    ONU_STATUS                        rc;
    MIDWARE_TABLE_MC_PORT_SERV_T      mc_port_serv;
    UINT32                            i;
    MIDWARE_TABLE_INFO               *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_MC_PORT_SERV))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;mc_port_serv, 0, sizeof(mc_port_serv));
    mc_port_serv.set_ctrl        = MIDWARE_MC_SET_TYPE_RESERVED;
    mc_port_serv.row_key         = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_serv.vid             = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_serv.max_sum_group   = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_serv.max_mc_bw       = MIDWARE_DEFAULT_ZERO_VAL;

    table_info = midware_get_table_info(MIDWARE_TABLE_MC_PORT_SERV);
    for(i = TPM_SRC_PORT_UNI_0; i &lt;= TPM_SRC_PORT_UNI_3; i++)
    {
        mc_port_serv.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;mc_port_serv);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_MC_PORT_SERV port: %ld\n", i);
            return ONU_FAIL;
        }
    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_mc_port_serv_set(UINT32 bitmap, void *entry)
{
    INT32                         rc;
    MIDWARE_CALLBACK_RET          callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    mrvl_eth_mc_port_serv_t       mc_port_serv;
    MIDWARE_TABLE_MC_PORT_SERV_T *p_mc_port_serv;
    MIDWARE_TABLE_INFO           *table_info;
    ONU_STATUS                    midware_rc;

    p_mc_port_serv = (MIDWARE_TABLE_MC_PORT_SERV_T *)entry;

    mc_port_serv.port_id = p_mc_port_serv-&gt;port_id;

    table_info = midware_get_table_info(MIDWARE_TABLE_MC_PORT_SERV);
    midware_rc = midware_sqlite3_get_select_sql_prepared(table_info, &amp;mc_port_serv);
    if( ONU_FAIL == midware_rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get MIDWARE_TABLE_MC_PORT_SERV entry for port: %ld\n", p_mc_port_serv-&gt;port_id);
        return MDW_CB_RET_SET_HW_FAIL;
    }


    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_SRV_SET_TYPE)
    {
        mc_port_serv.set_ctrl = p_mc_port_serv-&gt;set_ctrl;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_SRV_ROW_KEY)
    {
        mc_port_serv.row_key = p_mc_port_serv-&gt;row_key;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_SRV_VID)
    {
        mc_port_serv.vid = p_mc_port_serv-&gt;vid;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_SRV_MAX_GROUP)
    {
        mc_port_serv.max_sum_group = p_mc_port_serv-&gt;max_sum_group;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_SRV_MAX_BW)
    {
        mc_port_serv.max_mc_bw = p_mc_port_serv-&gt;max_mc_bw;
    }

    rc = IGMP_set_serv_rule(&amp;mc_port_serv);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to call IGMP_set_serv_rule\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    return callback_ret;
}

ONU_STATUS midware_table_mc_port_preview_init(void)
{
    ONU_STATUS                        rc;
    MIDWARE_TABLE_MC_PORT_PREVIEW_T   mc_port_preview;
    UINT32                            i;
    MIDWARE_TABLE_INFO               *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_MC_PORT_PREVIEW))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;mc_port_preview, 0, sizeof(mc_port_preview));
    mc_port_preview.set_ctrl        = MIDWARE_MC_SET_TYPE_RESERVED;
    mc_port_preview.row_key         = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_preview.ani_vid         = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_preview.uni_vid         = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_preview.duration        = MIDWARE_DEFAULT_ZERO_VAL;
    mc_port_preview.time_left       = MIDWARE_DEFAULT_ZERO_VAL;

    table_info = midware_get_table_info(MIDWARE_TABLE_MC_PORT_PREVIEW);
    for(i = TPM_SRC_PORT_UNI_0; i &lt;= TPM_SRC_PORT_UNI_3; i++)
    {
        mc_port_preview.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;mc_port_preview);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_MC_PORT_PREVIEW port: %ld\n", i);
            return ONU_FAIL;
        }
    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_mc_port_preview_set(UINT32 bitmap, void *entry)
{
    INT32                            rc;
    MIDWARE_CALLBACK_RET             callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    mrvl_eth_mc_port_preview_t       mc_port_preview;
    MIDWARE_TABLE_MC_PORT_PREVIEW_T *p_mc_port_preview;
    MIDWARE_TABLE_INFO              *table_info;
    ONU_STATUS                       midware_rc;

    p_mc_port_preview = (MIDWARE_TABLE_MC_PORT_PREVIEW_T *)entry;

    mc_port_preview.port_id = p_mc_port_preview-&gt;port_id;

    table_info = midware_get_table_info(MIDWARE_TABLE_MC_PORT_PREVIEW);
    midware_rc = midware_sqlite3_get_select_sql_prepared(table_info, &amp;mc_port_preview);
    if( ONU_FAIL == midware_rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get MIDWARE_TABLE_MC_PORT_PREVIEW entry for port: %ld\n", p_mc_port_preview-&gt;port_id);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_PREV_SET_TYPE)
    {
        mc_port_preview.set_ctrl = p_mc_port_preview-&gt;set_ctrl;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_PREV_SRC_IP)
    {
        memcpy(mc_port_preview.src_ip, p_mc_port_preview-&gt;src_ip, sizeof(mc_port_preview.src_ip));
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_PREV_DST_IP)
    {
        memcpy(mc_port_preview.dst_ip, p_mc_port_preview-&gt;dst_ip, sizeof(mc_port_preview.dst_ip));
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_PREV_ANI_VID)
    {
        mc_port_preview.ani_vid = p_mc_port_preview-&gt;ani_vid;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_PREV_UNI_VID)
    {
        mc_port_preview.uni_vid = p_mc_port_preview-&gt;uni_vid;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_PREV_DURATION)
    {
        mc_port_preview.duration = p_mc_port_preview-&gt;duration;
    }

    if(bitmap &amp; MIDWARE_ENTRY_MC_PORT_PREV_TIME_LEFT)
    {
        mc_port_preview.time_left = p_mc_port_preview-&gt;time_left;
    }

    rc = IGMP_set_preview_rule(&amp;mc_port_preview);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to call IGMP_set_preview_rule\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    return callback_ret;

}

MIDWARE_CALLBACK_RET midware_table_mc_ds_vlan_set(UINT32 bitmap, void *entry)
{
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    MIDWARE_TABLE_MC_DS_VLAN_TRANS_T *mc_vlan;

    mc_vlan = (MIDWARE_TABLE_MC_DS_VLAN_TRANS_T *)entry;

    callback_ret = midware_table_mc_ds_vlan_set_to_igmp(mc_vlan, MDW_MC_VLAN_UPDATE);
    if (MDW_CB_RET_SET_HW_FAIL == callback_ret)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to midware_table_mc_ds_vlan_set_to_igmp\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_mc_ds_vlan_insert(UINT32 bitmap, void *entry)
{
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    MIDWARE_TABLE_MC_DS_VLAN_TRANS_T *mc_vlan;

    mc_vlan = (MIDWARE_TABLE_MC_DS_VLAN_TRANS_T *)entry;

    callback_ret = midware_table_mc_ds_vlan_set_to_igmp(mc_vlan, MDW_MC_VLAN_INSETT);
    if (MDW_CB_RET_SET_HW_FAIL == callback_ret)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to midware_table_mc_ds_vlan_set_to_igmp\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_mc_ds_vlan_remove(UINT32 bitmap, void *entry)
{
    MIDWARE_CALLBACK_RET                callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    MIDWARE_TABLE_MC_DS_VLAN_TRANS_T *mc_vlan;

    mc_vlan = (MIDWARE_TABLE_MC_DS_VLAN_TRANS_T *)entry;

    callback_ret = midware_table_mc_ds_vlan_set_to_igmp(mc_vlan, MDW_MC_VLAN_REMOVE);
    if (MDW_CB_RET_SET_HW_FAIL == callback_ret)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to midware_table_mc_ds_vlan_set_to_igmp\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_mc_us_vlan_set(UINT32 bitmap, void *entry)
{
     return MDW_CB_RET_SET_HW_NO_NEED;
}

MIDWARE_CALLBACK_RET midware_table_mc_us_vlan_insert(UINT32 bitmap, void *entry)
{

     return MDW_CB_RET_SET_HW_NO_NEED;
}

MIDWARE_CALLBACK_RET midware_table_mc_us_vlan_remove(UINT32 bitmap, void *entry)
{
     return MDW_CB_RET_SET_HW_NO_NEED;
}

ONU_STATUS midware_table_iad_port_admin_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_POTS_ADMIN_T    iad_port_admin;
    UINT32             i;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_IAD_PORT_ADMIN))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    iad_port_admin.port_admin = MIDWARE_SFU_DISABLE;

    table_info = midware_get_table_info(MIDWARE_TABLE_IAD_PORT_ADMIN);
    for(i = 1; i &lt;= 2; i++)
    {
        iad_port_admin.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;iad_port_admin);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_IAD_PORT_ADMIN port: %ld\n", i);
            return ONU_FAIL;
        }
    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_iad_port_admin_get(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_POTS_ADMIN_T    *iad_port_admin;
    VOIP_ST_PORT_ACTIVE_STATE info;

    iad_port_admin = (MIDWARE_TABLE_POTS_ADMIN_T *)entry;

    rc = VOIP_getPortActiveState_F(iad_port_admin-&gt;port_id, &amp;info);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_GetPortActiveState_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }
    if(info == VOIP_ETH_PORT_ADMIN_ACTIVATE)
        iad_port_admin-&gt;port_admin = MIDWARE_UNI_CFG_ENABLE;
    else
        iad_port_admin-&gt;port_admin = MIDWARE_UNI_CFG_DISABLE;


     return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_iad_port_admin_set(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_POTS_ADMIN_T    *iad_port_admin;
    VOIP_ST_PORT_ACTIVE_STATE info;

    iad_port_admin = (MIDWARE_TABLE_POTS_ADMIN_T *)entry;

    if(iad_port_admin-&gt;port_admin  == MIDWARE_UNI_CFG_ENABLE)
        info = VOIP_ETH_PORT_ADMIN_ACTIVATE;
    else
        info = VOIP_ETH_PORT_ADMIN_DEACTIVATE;

    rc = VOIP_setPortActiveState_F(iad_port_admin-&gt;port_id, &amp;info);

    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_SetPortActiveState_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_iad_info_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_IAD_INFO_T    iad_info;
    MIDWARE_TABLE_INFO *table_info;

    //init the default entries
    memset(&amp;iad_info, 0, sizeof(iad_info));

    midware_mv_ext_get_if_mac("pon0",iad_info.mac_addr);
    iad_info.pots_num = MIDWARE_SFU_POTS_PORT_NUM;
    iad_info.protocol = MIDWARE_SFU_PROTOCOL_SIP;
    table_info = midware_get_table_info(MIDWARE_TABLE_IAD_INFO);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;iad_info);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_IAD_INFO \n");
        return ONU_FAIL;
    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_iad_info_get(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_IAD_INFO_T   *midware_iad_info;
    VOIP_ST_IADINFO voip_iad_info;

    midware_iad_info = (MIDWARE_TABLE_IAD_INFO_T *)entry;

    rc = VOIP_getIadInfo_F(&amp;voip_iad_info);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_GetIadInfo_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    memcpy(midware_iad_info-&gt;mac_addr, voip_iad_info.mac_address, sizeof(midware_iad_info-&gt;mac_addr));
    midware_iad_info-&gt;protocol = voip_iad_info.voip_protocol;
    memcpy(midware_iad_info-&gt;sw_ver, voip_iad_info.sw_version, sizeof(midware_iad_info-&gt;sw_ver));
    memcpy(midware_iad_info-&gt;sw_time, voip_iad_info.sw_time, sizeof(midware_iad_info-&gt;sw_time));
    midware_iad_info-&gt;pots_num = voip_iad_info.user_count;

     return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_iad_cfg_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_IAD_CFG_T     iad_cfg;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_IAD_CFG))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;iad_cfg, 0, sizeof(iad_cfg));
    iad_cfg.ip_mode = MIDWARE_SFU_VOICE_IP_MODE_STATIC;

    table_info = midware_get_table_info(MIDWARE_TABLE_IAD_CFG);
    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;iad_cfg);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_IAD_CFG  \n");
        return ONU_FAIL;
    }
    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_iad_cfg_get(UINT32 bitmap, void *entry)
{
/*
    INT32                                                            rc;
    ONU_STATUS      midware_rc;
    MIDWARE_TABLE_IAD_CFG_T     *midware_iad_cfg;
    MIDWARE_TABLE_INFO *table_info;
    VOIP_ST_SIP_PARAMETER_CONFIG voip_iad_cfg;

    midware_iad_cfg = (MIDWARE_TABLE_IAD_CFG_T *)entry;

    rc = VOIP_GetSipParamConfig_F(&amp;voip_iad_cfg);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_GetIadInfo_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    memcpy(midware_iad_info-&gt;mac_addr, voip_iad_info.mac_address, sizeof(midware_iad_info-&gt;mac_addr));
    midware_iad_info-&gt;protocol = voip_iad_info.voip_protocol;
    memcpy(midware_iad_info-&gt;sw_ver, voip_iad_info.sw_version, sizeof(midware_iad_info-&gt;sw_ver));
    memcpy(midware_iad_info-&gt;sw_time, voip_iad_info.sw_time, sizeof(midware_iad_info-&gt;sw_time));
    midware_iad_info-&gt;pots_num = voip_iad_info.user_count;
*/
     return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_iad_cfg_set(UINT32 bitmap, void *entry)
{

    INT32                                                            rc;
    MIDWARE_TABLE_IAD_CFG_T     *midware_iad_cfg;
    VOIP_GLOBAL_PARAM_T voip_iad_cfg;

    midware_iad_cfg = (MIDWARE_TABLE_IAD_CFG_T *)entry;

    voip_iad_cfg.voice_ip_mode =                         midware_iad_cfg-&gt;ip_mode ;
    voip_iad_cfg.iad_ip_addr =                           midware_iad_cfg-&gt;ip_addr ;
    voip_iad_cfg.iad_net_mask =                          midware_iad_cfg-&gt;net_mask ;
    voip_iad_cfg.iad_def_gw =                            midware_iad_cfg-&gt;def_gw ;
    voip_iad_cfg.pppoe_mode =                            midware_iad_cfg-&gt;pppoe_mode ;
    memcpy(voip_iad_cfg.pppoe_user,  midware_iad_cfg-&gt;pppoe_user, sizeof(voip_iad_cfg.pppoe_user));
    memcpy(voip_iad_cfg.pppoe_passwd,  midware_iad_cfg-&gt;pppoe_pwd, sizeof(voip_iad_cfg.pppoe_passwd));
    voip_iad_cfg.vlan_tag_mode =                         midware_iad_cfg-&gt;tag_flag ;
    voip_iad_cfg.cvlan_id =                              midware_iad_cfg-&gt;cvlan ;
    voip_iad_cfg.svlan_id =                              midware_iad_cfg-&gt;svlan ;
    voip_iad_cfg.priority =                              midware_iad_cfg-&gt;pbits ;

    rc = VOIP_setGlobalParam_F(&amp;voip_iad_cfg);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_SetGlobalParam_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_h248_cfg_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_H248_CFG_T     h248_cfg;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_H248_CFG))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;h248_cfg, 0, sizeof(h248_cfg));
    h248_cfg.mg_port = MIDWARE_SFU_H248_MG_PORT_NUM;
    h248_cfg.heartbeat_mode = MIDWARE_SFU_H248_HEARTBEAT_MODE_CLOSE;
    h248_cfg.heartbeat_cycle = MIDWARE_SFU_HEARTBEAT_CYCLE;
    h248_cfg.heartbeat_count = MIDWARE_SFU_HEARTBEAT_HEARTBEAT_COUNT;

    table_info = midware_get_table_info(MIDWARE_TABLE_H248_CFG);
    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;h248_cfg);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_H248_CFG  \n");
        return ONU_FAIL;
    }
    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_h248_cfg_get(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_H248_CFG_T   *midware_h248_cfg;
    VOIP_ST_H248_PARAMETER_CONFIG voip_h248_cfg;

    midware_h248_cfg = (MIDWARE_TABLE_H248_CFG_T *)entry;

    rc = VOIP_getH248ParamConfig_F(&amp;voip_h248_cfg);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_GetH248ParamConfig_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }


    midware_h248_cfg-&gt;mg_port = voip_h248_cfg.mg_port;
    midware_h248_cfg-&gt;mgc_ip = voip_h248_cfg.mgcip;
    midware_h248_cfg-&gt;mgc_port = voip_h248_cfg.mgccom_port_num;
    midware_h248_cfg-&gt;backup_mgc_ip = voip_h248_cfg.back_mgcip;
    midware_h248_cfg-&gt;backup_mgc_port = voip_h248_cfg.back_mgccom_port_num;
    midware_h248_cfg-&gt;active_mgc = voip_h248_cfg.active_mgc;
    midware_h248_cfg-&gt;reg_mode = voip_h248_cfg.reg_mode;
    memcpy(midware_h248_cfg-&gt;mg_id, voip_h248_cfg.mid, sizeof(midware_h248_cfg-&gt;mg_id));
    midware_h248_cfg-&gt;heartbeat_mode = voip_h248_cfg.heart_beat_mode;
    midware_h248_cfg-&gt;heartbeat_cycle = voip_h248_cfg.heart_beat_cycle;
    midware_h248_cfg-&gt;heartbeat_count = voip_h248_cfg.heart_beat_count;

     return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_h248_cfg_set(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_H248_CFG_T   *midware_h248_cfg;
    VOIP_ST_H248_PARAMETER_CONFIG voip_h248_cfg;

    midware_h248_cfg = (MIDWARE_TABLE_H248_CFG_T *)entry;

    voip_h248_cfg.mg_port = midware_h248_cfg-&gt;mg_port;
    voip_h248_cfg.mgcip = midware_h248_cfg-&gt;mgc_ip;
    voip_h248_cfg.mgccom_port_num = midware_h248_cfg-&gt;mgc_port;
    voip_h248_cfg.back_mgcip = midware_h248_cfg-&gt;backup_mgc_ip;
    voip_h248_cfg.back_mgccom_port_num = midware_h248_cfg-&gt;backup_mgc_port;
    voip_h248_cfg.active_mgc = midware_h248_cfg-&gt;active_mgc;
    voip_h248_cfg.reg_mode = midware_h248_cfg-&gt;reg_mode;
    memcpy(voip_h248_cfg.mid, midware_h248_cfg-&gt;mg_id, sizeof(voip_h248_cfg.mid));
    voip_h248_cfg.heart_beat_mode = midware_h248_cfg-&gt;heartbeat_mode;
    voip_h248_cfg.heart_beat_cycle = midware_h248_cfg-&gt;heartbeat_cycle;
    voip_h248_cfg.heart_beat_count = midware_h248_cfg-&gt;heartbeat_count;

    rc = VOIP_setH248ParamConfig_F(&amp;voip_h248_cfg);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_SetH248ParamConfig_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_h248_user_info_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_H248_USER_INFO_T     h248_user_info;
    MIDWARE_TABLE_INFO *table_info;
    UINT32 i;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_H248_USER_INFO))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;h248_user_info, 0, sizeof(h248_user_info));

    table_info = midware_get_table_info(MIDWARE_TABLE_H248_USER_INFO);
    for(i = 1; i &lt;= 2; i++)
    {
        h248_user_info.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;h248_user_info);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_H248_USER_INFO  \n");
            return ONU_FAIL;
        }
    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_h248_user_info_get(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_H248_USER_INFO_T   *midware_h248_user_info;
    VOIP_ST_H248_USER_TIDINFO voip_h248_user_info;

    midware_h248_user_info = (MIDWARE_TABLE_H248_USER_INFO_T *)entry;

    rc = VOIP_getH248UserTIDInfo_F(midware_h248_user_info-&gt;port_id, &amp;voip_h248_user_info);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_GetH248ParamConfig_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    memcpy(midware_h248_user_info-&gt;user_name, voip_h248_user_info.user_tid_name, sizeof(midware_h248_user_info-&gt;user_name));

     return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_h248_user_info_set(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_H248_USER_INFO_T   *midware_h248_user_info;
    VOIP_ST_H248_USER_TIDINFO voip_h248_user_info;

    midware_h248_user_info = (MIDWARE_TABLE_H248_USER_INFO_T *)entry;

    memcpy(voip_h248_user_info.user_tid_name, midware_h248_user_info-&gt;user_name, sizeof(voip_h248_user_info.user_tid_name));

    rc = VOIP_setH248UserTIDInfo_F(midware_h248_user_info-&gt;port_id, &amp;voip_h248_user_info);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_GetH248ParamConfig_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_h248_rtp_cfg_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_H248_RTP_CFG_T     h248_rtp_cfg;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_H248_RTP_CFG))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;h248_rtp_cfg, 0, sizeof(h248_rtp_cfg));

    table_info = midware_get_table_info(MIDWARE_TABLE_H248_RTP_CFG);
    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;h248_rtp_cfg);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_H248_RTP_CFG  \n");
        return ONU_FAIL;
    }
    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_h248_rtp_cfg_get(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_H248_RTP_CFG_T   *midware_h248_rtp_cfg;
    VOIP_ST_H248_RTP_TID_CONFIG voip_h248_rtp_cfg;

    midware_h248_rtp_cfg = (MIDWARE_TABLE_H248_RTP_CFG_T *)entry;

    rc = VOIP_getH248RtpTIDConfig_F(&amp;voip_h248_rtp_cfg);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_GetH248RtpTIDConfig_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     midware_h248_rtp_cfg-&gt;num_of_rtp = voip_h248_rtp_cfg.num_of_rtp_tid;
     memcpy(midware_h248_rtp_cfg-&gt;rtp_prefix, voip_h248_rtp_cfg.rtp_tid_prefix, sizeof(midware_h248_rtp_cfg-&gt;rtp_prefix));
     memcpy(midware_h248_rtp_cfg-&gt;rtp_digit, voip_h248_rtp_cfg.rtp_tid_digit_begin, sizeof(midware_h248_rtp_cfg-&gt;rtp_digit));
     midware_h248_rtp_cfg-&gt;rtp_mode = voip_h248_rtp_cfg.rtp_tid_mode;
     midware_h248_rtp_cfg-&gt;rtp_digit_len = voip_h248_rtp_cfg.rtp_tid_digit_length;

     return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_h248_rtp_cfg_set(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_H248_RTP_CFG_T   *midware_h248_rtp_cfg;
    VOIP_ST_H248_RTP_TID_CONFIG voip_h248_rtp_cfg;

    midware_h248_rtp_cfg = (MIDWARE_TABLE_H248_RTP_CFG_T *)entry;

     voip_h248_rtp_cfg.num_of_rtp_tid = midware_h248_rtp_cfg-&gt;num_of_rtp;
     memcpy(voip_h248_rtp_cfg.rtp_tid_prefix, midware_h248_rtp_cfg-&gt;rtp_prefix, sizeof(voip_h248_rtp_cfg.rtp_tid_prefix));
     memcpy(voip_h248_rtp_cfg.rtp_tid_digit_begin, midware_h248_rtp_cfg-&gt;rtp_digit, sizeof(voip_h248_rtp_cfg.rtp_tid_digit_begin));
     voip_h248_rtp_cfg.rtp_tid_mode = midware_h248_rtp_cfg-&gt;rtp_mode;
     voip_h248_rtp_cfg.rtp_tid_digit_length = midware_h248_rtp_cfg-&gt;rtp_digit_len;

     rc = VOIP_setH248RtpTIDConfig_F(&amp;voip_h248_rtp_cfg);
     if (OK != rc)
     {
         MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_SetH248RtpTIDConfig_F\r\n");
         return MDW_CB_RET_SET_HW_FAIL;
     }

     return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_h248_rtp_info_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_H248_RTP_INFO_T     h248_rtp_info;
    MIDWARE_TABLE_INFO *table_info;

    //init the default entries
    memset(&amp;h248_rtp_info, 0, sizeof(h248_rtp_info));

    table_info = midware_get_table_info(MIDWARE_TABLE_H248_RTP_INFO);

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;h248_rtp_info);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_H248_RTP_INFO  \n");
        return ONU_FAIL;
    }

    return ONU_OK;

}
MIDWARE_CALLBACK_RET midware_table_h248_rtp_info_get(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_H248_RTP_INFO_T     *midware_h248_rtp_info;
    VOIP_ST_H248_RTP_TID_INFO                  voip_h248_rtp_info;

    midware_h248_rtp_info = (MIDWARE_TABLE_H248_RTP_INFO_T *)entry;

     rc = VOIP_getH248RtpTIDInfo_F(&amp;voip_h248_rtp_info);
     if (OK != rc)
     {
         MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_SetH248RtpTIDConfig_F\r\n");
         return MDW_CB_RET_SET_HW_FAIL;
     }

     midware_h248_rtp_info-&gt;num_of_rtp = voip_h248_rtp_info.num_of_rtp_tid;
     memcpy(midware_h248_rtp_info-&gt;first_rtp_name, voip_h248_rtp_info.rtp_tid_name, sizeof(midware_h248_rtp_info-&gt;first_rtp_name));

     return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_sip_cfg_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_SIP_CFG_T     sip_cfg;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_SIP_CFG))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;sip_cfg, 0, sizeof(sip_cfg));
    sip_cfg.mg_port = MIDWARE_SFU_SIP_MG_PORT_NUM;
    sip_cfg.reg_interval = MIDWARE_SFU_SIP_REG_INTERVAL;
    sip_cfg.heartbeat_switch = MIDWARE_SFU_SIP_HEARTBEAT_SWITCH_OPEN;
    sip_cfg.heartbeat_cycle = MIDWARE_SFU_HEARTBEAT_CYCLE;
    sip_cfg.heartbeat_count = MIDWARE_SFU_HEARTBEAT_HEARTBEAT_COUNT;

    table_info = midware_get_table_info(MIDWARE_TABLE_SIP_CFG);
    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;sip_cfg);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_SIP_CFG  \n");
        return ONU_FAIL;
    }
    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_sip_cfg_get(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_SIP_CFG_T   *midware_sip_cfg;
    VOIP_ST_SIP_PARAMETER_CONFIG voip_sip_cfg;

    midware_sip_cfg = (MIDWARE_TABLE_SIP_CFG_T *)entry;

    rc = VOIP_getSipParamConfig_F(&amp;voip_sip_cfg);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_GetSipParamConfig_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    midware_sip_cfg-&gt;mg_port             =  voip_sip_cfg.mg_port;
    midware_sip_cfg-&gt;proxy_ip            =  voip_sip_cfg.server_ip;
    midware_sip_cfg-&gt;proxy_port          =  voip_sip_cfg.serv_com_port;
    midware_sip_cfg-&gt;backup_proxy_ip     =  voip_sip_cfg.back_server_ip;
    midware_sip_cfg-&gt;backup_proxy_port   =  voip_sip_cfg.back_serv_com_port;
    midware_sip_cfg-&gt;active_proxy        =  voip_sip_cfg.active_proxy_server;
    midware_sip_cfg-&gt;reg_ip              =  voip_sip_cfg.reg_server_ip;
    midware_sip_cfg-&gt;reg_port            =  voip_sip_cfg.reg_serv_com_port;
    midware_sip_cfg-&gt;backup_reg_ip       =  voip_sip_cfg.back_reg_server_ip;
    midware_sip_cfg-&gt;backup_reg_port     =  voip_sip_cfg.back_reg_serv_com_port;
    midware_sip_cfg-&gt;outband_ip          =  voip_sip_cfg.outbound_server_ip;
    midware_sip_cfg-&gt;outband_port        =  voip_sip_cfg.outbound_serv_com_port;
    midware_sip_cfg-&gt;reg_interval        =  voip_sip_cfg.reg_interval;
    midware_sip_cfg-&gt;heartbeat_switch    =  voip_sip_cfg.heart_beat_switch;
    midware_sip_cfg-&gt;heartbeat_cycle     =  voip_sip_cfg.heart_beat_cycle;
    midware_sip_cfg-&gt;heartbeat_count     =  voip_sip_cfg.heart_beat_count;

     return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_sip_cfg_set(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_SIP_CFG_T   *midware_sip_cfg;
    VOIP_ST_SIP_PARAMETER_CONFIG voip_sip_cfg;

    midware_sip_cfg = (MIDWARE_TABLE_SIP_CFG_T *)entry;

    voip_sip_cfg.mg_port                  =  midware_sip_cfg-&gt;mg_port;
    voip_sip_cfg.server_ip                =  midware_sip_cfg-&gt;proxy_ip;
    voip_sip_cfg.serv_com_port            =  midware_sip_cfg-&gt;proxy_port;
    voip_sip_cfg.back_server_ip           =  midware_sip_cfg-&gt;backup_proxy_ip;
    voip_sip_cfg.back_serv_com_port       =  midware_sip_cfg-&gt;backup_proxy_port;
    voip_sip_cfg.active_proxy_server      =  midware_sip_cfg-&gt;active_proxy;
    voip_sip_cfg.reg_server_ip            =  midware_sip_cfg-&gt;reg_ip;
    voip_sip_cfg.reg_serv_com_port        =  midware_sip_cfg-&gt;reg_port;
    voip_sip_cfg.back_reg_server_ip       =  midware_sip_cfg-&gt;backup_reg_ip;
    voip_sip_cfg.back_reg_serv_com_port   =  midware_sip_cfg-&gt;backup_reg_port;
    voip_sip_cfg.outbound_server_ip       =  midware_sip_cfg-&gt;outband_ip;
    voip_sip_cfg.outbound_serv_com_port   =  midware_sip_cfg-&gt;outband_port;
    voip_sip_cfg.reg_interval             =  midware_sip_cfg-&gt;reg_interval;
    voip_sip_cfg.heart_beat_switch        =  midware_sip_cfg-&gt;heartbeat_switch;
    voip_sip_cfg.heart_beat_cycle         =  midware_sip_cfg-&gt;heartbeat_cycle;
    voip_sip_cfg.heart_beat_count         =  midware_sip_cfg-&gt;heartbeat_count;

    rc = VOIP_setSipParamConfig_F(&amp;voip_sip_cfg);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_setSipParamConfig_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return MDW_CB_RET_SET_HW_OK;
}


ONU_STATUS midware_table_sip_user_info_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_SIP_USER_T     sip_user_info;
    MIDWARE_TABLE_INFO *table_info;
    UINT32 i;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_SIP_USER_INFO))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;sip_user_info, 0, sizeof(sip_user_info));

    table_info = midware_get_table_info(MIDWARE_TABLE_SIP_USER_INFO);
    for(i = 1; i &lt;= 2; i++)
    {
        sip_user_info.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;sip_user_info);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_SIP_USER_INFO  \n");
            return ONU_FAIL;
        }
    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_sip_user_info_get(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_SIP_USER_T   *midware_sip_user;
    VOIP_ST_SIP_USER_PARAMETER_CONFIG voip_sip_user;

    midware_sip_user = (MIDWARE_TABLE_SIP_USER_T *)entry;

    rc = VOIP_getSipUserParamConfig_F(midware_sip_user-&gt;port_id, &amp;voip_sip_user);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_GetSipUserParamConfig_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    memcpy(midware_sip_user-&gt;user_account, voip_sip_user.sip_port_num, sizeof(midware_sip_user-&gt;user_account));
    memcpy(midware_sip_user-&gt;user_name, voip_sip_user.user_name, sizeof(midware_sip_user-&gt;user_name));
    memcpy(midware_sip_user-&gt;user_pwd, voip_sip_user.passwd, sizeof(midware_sip_user-&gt;user_pwd));

     return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_sip_user_info_set(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_SIP_USER_T   *midware_sip_user;
    VOIP_ST_SIP_USER_PARAMETER_CONFIG voip_sip_user;

    midware_sip_user = (MIDWARE_TABLE_SIP_USER_T *)entry;

    memcpy(voip_sip_user.sip_port_num, midware_sip_user-&gt;user_account, sizeof(voip_sip_user.sip_port_num));
    memcpy(voip_sip_user.user_name, midware_sip_user-&gt;user_name, sizeof(voip_sip_user.user_name));
    memcpy(voip_sip_user.passwd, midware_sip_user-&gt;user_pwd, sizeof(voip_sip_user.passwd));

    rc = VOIP_setSipUserParamConfig_F(midware_sip_user-&gt;port_id, &amp;voip_sip_user);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_SetSipUserParamConfig_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_sip_digitmap_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_DIGITMAP_T     midware_sip_digitmap;
    MIDWARE_TABLE_INFO *table_info;

    //init the default entries

    table_info = midware_get_table_info(MIDWARE_TABLE_SIP_DIGITMAP);
    memset(&amp;midware_sip_digitmap, 0, sizeof(midware_sip_digitmap));

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;midware_sip_digitmap);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_SIP_USER_INFO  \n");
        return ONU_FAIL;
    }

    return ONU_OK;

}


MIDWARE_CALLBACK_RET midware_table_sip_digitmap_set(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_DIGITMAP_T *midware_sip_digitmap;
    VOIP_ST_SIP_DIGITAL_MAP  voip_sip_digitmap;

    midware_sip_digitmap = (MIDWARE_TABLE_DIGITMAP_T *)entry;

    memcpy(voip_sip_digitmap.sip_unit, midware_sip_digitmap-&gt;digitmap, sizeof(voip_sip_digitmap.sip_unit));

    rc = VOIP_setSipDigitmap_F(&amp;voip_sip_digitmap);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_SetSipDigitmap_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_fax_cfg_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_FAX_T    fax_cfg;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_FAX_CFG))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;fax_cfg, 0, sizeof(fax_cfg));
    fax_cfg.t38_en = MIDWARE_SFU_DISABLE;
    fax_cfg.fax_ctrl = MIDWARE_SFU_FAX_CTRL_NEG;

    table_info = midware_get_table_info(MIDWARE_TABLE_FAX_CFG);
    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;fax_cfg);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_FAX_CFG  \n");
        return ONU_FAIL;
    }
    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_fax_cfg_get(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_FAX_T   *midware_fax_cfg;
    VOIP_ST_FAX_MODEM_CONFIG voip_fax_cfg;

    midware_fax_cfg = (MIDWARE_TABLE_FAX_T *)entry;

    rc = VOIP_getFaxModemConfig_F(&amp;voip_fax_cfg);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_GetFaxModemConfig_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    midware_fax_cfg-&gt;t38_en=  voip_fax_cfg.t38_enable;
    midware_fax_cfg-&gt;fax_ctrl=  voip_fax_cfg.fax_control;

     return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_fax_cfg_set(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_FAX_T   *midware_fax_cfg;
    VOIP_ST_FAX_MODEM_CONFIG voip_fax_cfg;

    midware_fax_cfg = (MIDWARE_TABLE_FAX_T *)entry;

    voip_fax_cfg.t38_enable = midware_fax_cfg-&gt;t38_en ;
    voip_fax_cfg.fax_control =  midware_fax_cfg-&gt;fax_ctrl;

    rc = VOIP_setFaxModemConfig_F(&amp;voip_fax_cfg);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_SetFaxModemConfig_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_iad_status_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_IAD_STATUS_T  iad_cfg;
    MIDWARE_TABLE_INFO *table_info;

    //init the default entries
    memset(&amp;iad_cfg, 0, sizeof(iad_cfg));

    table_info = midware_get_table_info(MIDWARE_TABLE_IAD_STATUS);
    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;iad_cfg);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_IAD_STATUS  \n");
        return ONU_FAIL;
    }
    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_iad_status_get(UINT32 bitmap, void *entry)
{
    INT32                        rc;
    MIDWARE_TABLE_IAD_STATUS_T   *midware_iad_cfg;
    VOIP_ST_H248_IAD_OPERATION_STATUS voip_iad_cfg;

    midware_iad_cfg = (MIDWARE_TABLE_IAD_STATUS_T *)entry;

    rc = VOIP_getH248IadOperStatus_F(&amp;voip_iad_cfg);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_GetH248IadOperStatus_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    midware_iad_cfg-&gt;status =  voip_iad_cfg;

     return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_pots_status_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_POTS_STATUS_T pots_cfg;
    MIDWARE_TABLE_INFO *table_info;
    UINT32 i;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_POTS_STATUS))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;pots_cfg, 0, sizeof(pots_cfg));

    table_info = midware_get_table_info(MIDWARE_TABLE_POTS_STATUS);
    for(i = 1; i &lt;= 2; i++)
    {
        pots_cfg.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;pots_cfg);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_POTS_STATUS  \n");
            return ONU_FAIL;
        }
    }

    return ONU_OK;
}

MIDWARE_CALLBACK_RET midware_table_pots_status_get(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_POTS_STATUS_T   *midware_pots_status;
    VOIP_ST_POTS_STATUS                         voip_pots_status;

    midware_pots_status = (MIDWARE_TABLE_POTS_STATUS_T *)entry;

    rc = VOIP_getPotsStatus_F(midware_pots_status-&gt;port_id, &amp;voip_pots_status);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_GetPotsStatus_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    midware_pots_status-&gt;port_status =  voip_pots_status.port_status;
    midware_pots_status-&gt;service_status =  voip_pots_status.service_status;
    midware_pots_status-&gt;codec =  voip_pots_status.codec_mode;

     return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_iad_operation_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_IAD_OPER_T        iad_operation;
    MIDWARE_TABLE_INFO *table_info;

    //init the default entries
    memset(&amp;iad_operation, 0, sizeof(iad_operation));

    table_info = midware_get_table_info(MIDWARE_TABLE_IAD_OPERATION);
    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;iad_operation);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_IAD_OPERATION  \n");
        return ONU_FAIL;
    }
    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_iad_operation_set(UINT32 bitmap, void *entry)
{
    INT32                                                            rc;
    MIDWARE_TABLE_IAD_OPER_T   *midware_iad_operation;
    VOIP_ST_IAD_OPERATION voip_iad_operation;

    midware_iad_operation = (MIDWARE_TABLE_IAD_OPER_T *)entry;

    voip_iad_operation = midware_iad_operation-&gt;operation ;

    rc = VOIP_setIadOperation_F(&amp;voip_iad_operation);
    if (OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to VOIP_SetIadOperation_F\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return MDW_CB_RET_SET_HW_OK;
}

#if 0
ONU_STATUS midware_table_alarm_init(void)
{
    ONU_STATUS      rc = ONU_OK;
    MIDWARE_TABLE_ALARM_T alarm;
    MIDWARE_TABLE_INFO *table_info;
    UINT32 i;
    MIDWARE_TABLE_ONU_INFO_T OnuInfo;
    OnuXvrThresholds_S      onuXvrThresholds;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_ALARM))
    {
        //already got entries in the table
        return ONU_OK;
    }

    memset(&amp;OnuInfo,0,sizeof(OnuInfo));
    table_info = midware_get_table_info(MIDWARE_TABLE_ONU_INFO);
    midware_sqlite3_get_select_sql_prepared(table_info,&amp;OnuInfo);

    //init the default entries
    memset(&amp;alarm, 0, sizeof(alarm));

    table_info = midware_get_table_info(MIDWARE_TABLE_ALARM);

    if(is_support_onu_xvr_I2c &gt; 0)
    {
        memset(&amp;onuXvrThresholds,0,sizeof(onuXvrThresholds));

        rc = localI2cApi_getOnuXvrThresholds(&amp;onuXvrThresholds);

        if (true != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to localI2cApi_getOnuXvrThresholds \r\n");
            //return MDW_CB_RET_SET_HW_FAIL;
        }
    }

    for(i = OAM_ALARM_EQUIPMENT; i &lt;= OAM_ALARM_PON_IF_SWITCH; i++)
    {
        alarm.alarm_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;alarm);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
            return ONU_FAIL;
        }
    }

    for(i = OAM_ALARM_PON_RX_POWER_HIGH; i &lt;= OAM_ALARM_PON_TEMP_LOW_WARN; i++)
    {
        alarm.alarm_id = i;

        if(is_support_onu_xvr_I2c &gt; 0)
        {
            switch(alarm.alarm_id)
            {
                case OAM_ALARM_PON_RX_POWER_HIGH:
                    alarm.threshold = onuXvrThresholds.rxReceivedPower_hi_alarm;
                    break;
                case OAM_ALARM_PON_RX_POWER_LOW:
                    alarm.threshold = onuXvrThresholds.rxReceivedPower_lo_alarm;
                    break;
                case OAM_ALARM_PON_TX_POWER_HIGH:
                    alarm.threshold = onuXvrThresholds.txOpticalPower_hi_alarm;
                    break;
                case OAM_ALARM_PON_TX_POWER_LOW:
                    alarm.threshold = onuXvrThresholds.txOpticalPower_lo_alarm;
                    break;
                case OAM_ALARM_PON_TX_BIAS_HIGH:
                    alarm.threshold = onuXvrThresholds.txBiasCurrent_hi_alarm;
                    break;
                case OAM_ALARM_PON_TX_BIAS_LOW:
                    alarm.threshold = onuXvrThresholds.txBiasCurrent_lo_alarm;
                    break;
                case OAM_ALARM_PON_VCC_HIGH:
                    alarm.threshold = onuXvrThresholds.supplyVoltage_hi_alarm;
                    break;
                case OAM_ALARM_PON_VCC_LOW:
                    alarm.threshold = onuXvrThresholds.supplyVoltage_lo_alarm;
                    break;
                case OAM_ALARM_PON_TEMP_HIGH:
                    alarm.threshold = onuXvrThresholds.temperature_hi_alarm;
                    break;
                case OAM_ALARM_PON_TEMP_LOW:
                    alarm.threshold = onuXvrThresholds.temperature_lo_alarm;
                    break;
                case OAM_ALARM_PON_RX_POWER_HIGH_WARN:
                    alarm.threshold = onuXvrThresholds.rxReceivedPower_hi_warning;
                    break;
                case OAM_ALARM_PON_RX_POWER_LOW_WARN:
                    alarm.threshold = onuXvrThresholds.rxReceivedPower_lo_warning;
                    break;
                case OAM_ALARM_PON_TX_POWER_HIGH_WARN:
                    alarm.threshold = onuXvrThresholds.txOpticalPower_hi_warning;
                    break;
                case OAM_ALARM_PON_TX_POWER_LOW_WARN:
                    alarm.threshold = onuXvrThresholds.txOpticalPower_lo_warning;
                    break;
                case OAM_ALARM_PON_TX_BIAS_HIGH_WARN:
                    alarm.threshold = onuXvrThresholds.txBiasCurrent_hi_warning;
                    break;
                case OAM_ALARM_PON_TX_BIAS_LOW_WARN:
                    alarm.threshold = onuXvrThresholds.txBiasCurrent_lo_warning;
                    break;
                case OAM_ALARM_PON_VCC_HIGH_WARN:
                    alarm.threshold = onuXvrThresholds.supplyVoltage_hi_warning;
                    break;
                case OAM_ALARM_PON_VCC_LOW_WARN:
                    alarm.threshold = onuXvrThresholds.supplyVoltage_lo_warning;
                    break;
                case OAM_ALARM_PON_TEMP_HIGH_WARN:
                    alarm.threshold = onuXvrThresholds.temperature_hi_warning;
                    break;
                case OAM_ALARM_PON_TEMP_LOW_WARN:
                    alarm.threshold = onuXvrThresholds.temperature_lo_warning;
                    break;
                default:
                    break;
            }
        }

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;alarm);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
            return ONU_FAIL;
        }
    }

    /*There is no frame failure alarm in CTC, so no initialize it*/
    #if 0
    alarm.alarm_id = OAM_ALARM_FRAME_FAILURE;

    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;alarm);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
        return ONU_FAIL;
    }
    #endif

    alarm.threshold = 0;
    alarm.alarm_id = OAM_ALARM_POTS_PORT_FAILURE;


    for(i=1;i&lt;=OnuInfo.pots_port_num;i++)
    {
        alarm.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;alarm);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
            return ONU_FAIL;
        }
    }

    #if 0
    alarm.alarm_id = OAM_ALARM_ADSL2_PORT_FAILURE;
    for(i=1;i&lt;=OnuInfo.pots_port_num;i++)
    {
        alarm.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;alarm);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
            return ONU_FAIL;
        }
    }
    #endif

    for(i = OAM_ALARM_CARD; i &lt;= OAM_ALARM_CARD_SELF_TEST_FAILURE; i++)
    {
        alarm.alarm_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;alarm);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
            return ONU_FAIL;
        }
    }

    for(alarm.alarm_id = OAM_ALARM_PORT_AUTONEG_FAILURE; alarm.alarm_id &lt;= OAM_ALARM_PORT_CONGESTION; alarm.alarm_id++)
    {
        for(i=TPM_SRC_PORT_UNI_0;i&lt;=TPM_SRC_PORT_UNI_3;i++)
        {
            alarm.port_id = i;

            rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;alarm);
            if(ONU_OK != rc)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
                return ONU_FAIL;
            }
        }
    }

    for(alarm.alarm_id = OAM_ALARM_E1_PORT_FAILURE; alarm.alarm_id &lt;= OAM_ALARM_E1_LOS; alarm.alarm_id++)
    {
        for(i=1;i&lt;=OnuInfo.e1_port_num;i++)
        {
            alarm.port_id = i;

            rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;alarm);
            if(ONU_OK != rc)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
                return ONU_FAIL;
            }
        }
    }

    return ONU_OK;
}

/*This func is not used yet*/
MIDWARE_CALLBACK_RET midware_table_alarm_get(UINT32 bitmap, void *entry)
{
    bool                   rc;
    MIDWARE_TABLE_ALARM_T   *midware_alarm;
    OnuXvrThresholds_S      onuXvrThresholds;

    midware_alarm = (MIDWARE_TABLE_ALARM_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_ALARM_THRESHOLD)// || bitmap &amp; MIDWARE_ENTRY_ALARM_CLEAR_THRESHOLD)
    {
        if(midware_alarm-&gt;alarm_id &gt;= OAM_ALARM_PON_RX_POWER_HIGH &amp;&amp; midware_alarm-&gt;alarm_id &lt;= OAM_ALARM_PON_TEMP_LOW_WARN)
        {
            if(is_support_onu_xvr_I2c &gt; 0)
            {
                memset(&amp;onuXvrThresholds,0,sizeof(onuXvrThresholds));

                rc = localI2cApi_getOnuXvrThresholds(&amp;onuXvrThresholds);

                if (true != rc)
                {
                    MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to localI2cApi_getOnuXvrThresholds for alarm_id %d port %d\r\n",midware_alarm-&gt;alarm_id,midware_alarm-&gt;port_id);
                    //return MDW_CB_RET_SET_HW_FAIL;
                }

                switch(midware_alarm-&gt;alarm_id)
                {
                    case OAM_ALARM_PON_RX_POWER_HIGH:
                        midware_alarm-&gt;threshold = onuXvrThresholds.rxReceivedPower_hi_alarm;
                        break;
                    case OAM_ALARM_PON_RX_POWER_LOW:
                        midware_alarm-&gt;threshold = onuXvrThresholds.rxReceivedPower_lo_alarm;
                        break;
                    case OAM_ALARM_PON_TX_POWER_HIGH:
                        midware_alarm-&gt;threshold = onuXvrThresholds.txOpticalPower_hi_alarm;
                        break;
                    case OAM_ALARM_PON_TX_POWER_LOW:
                        midware_alarm-&gt;threshold = onuXvrThresholds.txOpticalPower_lo_alarm;
                        break;
                    case OAM_ALARM_PON_TX_BIAS_HIGH:
                        midware_alarm-&gt;threshold = onuXvrThresholds.txBiasCurrent_hi_alarm;
                        break;
                    case OAM_ALARM_PON_TX_BIAS_LOW:
                        midware_alarm-&gt;threshold = onuXvrThresholds.txBiasCurrent_lo_alarm;
                        break;
                    case OAM_ALARM_PON_VCC_HIGH:
                        midware_alarm-&gt;threshold = onuXvrThresholds.supplyVoltage_hi_alarm;
                        break;
                    case OAM_ALARM_PON_VCC_LOW:
                        midware_alarm-&gt;threshold = onuXvrThresholds.supplyVoltage_lo_alarm;
                        break;
                    case OAM_ALARM_PON_TEMP_HIGH:
                        midware_alarm-&gt;threshold = onuXvrThresholds.temperature_hi_alarm;
                        break;
                    case OAM_ALARM_PON_TEMP_LOW:
                        midware_alarm-&gt;threshold = onuXvrThresholds.temperature_lo_alarm;
                        break;
                    case OAM_ALARM_PON_RX_POWER_HIGH_WARN:
                        midware_alarm-&gt;threshold = onuXvrThresholds.rxReceivedPower_hi_warning;
                        break;
                    case OAM_ALARM_PON_RX_POWER_LOW_WARN:
                        midware_alarm-&gt;threshold = onuXvrThresholds.rxReceivedPower_lo_warning;
                        break;
                    case OAM_ALARM_PON_TX_POWER_HIGH_WARN:
                        midware_alarm-&gt;threshold = onuXvrThresholds.txOpticalPower_hi_warning;
                        break;
                    case OAM_ALARM_PON_TX_POWER_LOW_WARN:
                        midware_alarm-&gt;threshold = onuXvrThresholds.txOpticalPower_lo_warning;
                        break;
                    case OAM_ALARM_PON_TX_BIAS_HIGH_WARN:
                        midware_alarm-&gt;threshold = onuXvrThresholds.txBiasCurrent_hi_warning;
                        break;
                    case OAM_ALARM_PON_TX_BIAS_LOW_WARN:
                        midware_alarm-&gt;threshold = onuXvrThresholds.txBiasCurrent_lo_warning;
                        break;
                    case OAM_ALARM_PON_VCC_HIGH_WARN:
                        midware_alarm-&gt;threshold = onuXvrThresholds.supplyVoltage_hi_warning;
                        break;
                    case OAM_ALARM_PON_VCC_LOW_WARN:
                        midware_alarm-&gt;threshold = onuXvrThresholds.supplyVoltage_lo_warning;
                        break;
                    case OAM_ALARM_PON_TEMP_HIGH_WARN:
                        midware_alarm-&gt;threshold = onuXvrThresholds.temperature_hi_warning;
                        break;
                    case OAM_ALARM_PON_TEMP_LOW_WARN:
                        midware_alarm-&gt;threshold = onuXvrThresholds.temperature_lo_warning;
                        break;
                    default:
                        break;
                }
            }
        }

    }

    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_alarm_set(UINT32 bitmap, void *entry)
{
    bool                   rc;
    MIDWARE_TABLE_ALARM_T   *midware_alarm;
    OnuXvrThresholds_S      onuXvrThresholds;

    midware_alarm = (MIDWARE_TABLE_ALARM_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_ALARM_ENABLE)
    {
        if (!apmSetAlarmAdminState(midware_alarm-&gt;alarm_id, midware_alarm-&gt;port_id, midware_alarm-&gt;enable))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apmSetAlarmAdminState for alarm id 0x%x\r\n",midware_alarm-&gt;alarm_id);
            return MDW_CB_RET_SET_HW_FAIL;
        }
    }
    if(bitmap &amp; MIDWARE_ENTRY_ALARM_THRESHOLD)
    {
        #if 0
        if(is_support_onu_xvr_I2c)
        {
            memset(&amp;onuXvrThresholds,0,sizeof(onuXvrThresholds));

            rc = localI2cApi_getOnuXvrThresholds(&amp;onuXvrThresholds);

            if (true != rc)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to localI2cApi_getOnuXvrThresholds for alarm_id %d port %d\r\n",midware_alarm-&gt;alarm_id,midware_alarm-&gt;port_id);
                //return MDW_CB_RET_SET_HW_FAIL;
            }

            switch(midware_alarm-&gt;alarm_id)
            {
                case OAM_ALARM_PON_RX_POWER_HIGH:
                    onuXvrThresholds.rxReceivedPower_hi_alarm = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_RX_POWER_LOW:
                    onuXvrThresholds.rxReceivedPower_lo_alarm = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_TX_POWER_HIGH:
                    onuXvrThresholds.txOpticalPower_hi_alarm = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_TX_POWER_LOW:
                    onuXvrThresholds.txOpticalPower_lo_alarm = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_TX_BIAS_HIGH:
                    onuXvrThresholds.txBiasCurrent_hi_alarm = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_TX_BIAS_LOW:
                    onuXvrThresholds.txBiasCurrent_lo_alarm = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_VCC_HIGH:
                    onuXvrThresholds.supplyVoltage_hi_alarm = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_VCC_LOW:
                    onuXvrThresholds.supplyVoltage_lo_alarm = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_TEMP_HIGH:
                    onuXvrThresholds.temperature_hi_alarm = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_TEMP_LOW:
                    onuXvrThresholds.temperature_lo_alarm = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_RX_POWER_HIGH_WARN:
                    onuXvrThresholds.rxReceivedPower_hi_warning = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_RX_POWER_LOW_WARN:
                    onuXvrThresholds.rxReceivedPower_lo_warning = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_TX_POWER_HIGH_WARN:
                    onuXvrThresholds.txOpticalPower_hi_warning = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_TX_POWER_LOW_WARN:
                    onuXvrThresholds.txOpticalPower_lo_warning = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_TX_BIAS_HIGH_WARN:
                    onuXvrThresholds.txBiasCurrent_hi_warning = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_TX_BIAS_LOW_WARN:
                    onuXvrThresholds.txBiasCurrent_lo_warning = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_VCC_HIGH_WARN:
                    onuXvrThresholds.supplyVoltage_hi_warning = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_VCC_LOW_WARN:
                    onuXvrThresholds.supplyVoltage_lo_warning = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_TEMP_HIGH_WARN:
                    onuXvrThresholds.temperature_hi_warning = midware_alarm-&gt;threshold;
                    break;
                case OAM_ALARM_PON_TEMP_LOW_WARN:
                    onuXvrThresholds.temperature_lo_warning = midware_alarm-&gt;threshold;
                    break;
                default:
                    break;
            }

            rc = localI2cApi_setOnuXvrThresholds(&amp;onuXvrThresholds);
            if (true != rc)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to localI2cApi_setOnuXvrThresholds for alarm_id %d port %d\r\n",midware_alarm-&gt;alarm_id,midware_alarm-&gt;port_id);
                //return MDW_CB_RET_SET_HW_FAIL;
            }
        }
        #endif
    }
    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_alarm_insert(UINT32 bitmap, void *entry)
{
     return midware_table_alarm_set(bitmap, entry);
}

MIDWARE_CALLBACK_RET midware_table_alarm_event_insert(UINT32 bitmap, void *entry)
{
    STATUS      eoam_rc;
    MIDWARE_TABLE_ALARM_EVENT_T   *midware_alarm_event;

    midware_alarm_event = (MIDWARE_TABLE_ALARM_EVENT_T *)entry;

    eoam_rc = oam_tl_alarm_generate(midware_alarm_event-&gt;alarm_id, 0, midware_alarm_event-&gt;port_id, OAM_ALARM_REPORT, midware_alarm_event-&gt;value);
    eoam_rc = OAM_EXIT_OK;
    printf("report alarm 0x%x port %d\n",midware_alarm_event-&gt;alarm_id,midware_alarm_event-&gt;port_id);
    if (OAM_EXIT_OK != eoam_rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to oam_tl_alarm_generate\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_alarm_event_remove(UINT32 bitmap, void *entry)
{
    STATUS      eoam_rc;
    MIDWARE_TABLE_ALARM_EVENT_T   *midware_alarm_event;

    midware_alarm_event = (MIDWARE_TABLE_ALARM_EVENT_T *)entry;

    eoam_rc = oam_tl_alarm_generate(midware_alarm_event-&gt;alarm_id, 0, midware_alarm_event-&gt;port_id, OAM_ALARM_CLEAR_REPORT, midware_alarm_event-&gt;value);
    eoam_rc = OAM_EXIT_OK;
    printf("clear alarm 0x%x port %d\n",midware_alarm_event-&gt;alarm_id,midware_alarm_event-&gt;port_id);

    if (OAM_EXIT_OK != eoam_rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to oam_tl_alarm_generate\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

     return MDW_CB_RET_SET_HW_OK;
}
#endif

ONU_STATUS midware_table_alarm_init(void)
{
    return ONU_OK;
}

/*This func is not used yet*/
MIDWARE_CALLBACK_RET midware_table_alarm_get(UINT32 bitmap, void *entry)
{
    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_alarm_set(UINT32 bitmap, void *entry)
{
    bool                    rc;
    MIDWARE_TABLE_ALARM_T   *midware_alarm;
    UINT32                  threshold;
    UINT32                  clear_threshold;
    MIDWARE_TABLE_ALARM_T   old_midware_alarm;
    OMCI_REPORT_ALARM_MSG_S omci_alarm_msg;

    midware_get_entry(MIDWARE_TABLE_ALARM, 0xffffffff, &amp;old_midware_alarm, sizeof(old_midware_alarm));

    midware_alarm = (MIDWARE_TABLE_ALARM_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_ALARM_ADMIN)
    {
        if (!apm_alarm_set_admin(midware_alarm-&gt;type, midware_alarm-&gt;param1, midware_alarm-&gt;admin))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apmSetAlarmAdminState for alarm type 0x%x\r\n",midware_alarm-&gt;type);
            return MDW_CB_RET_SET_HW_FAIL;
        }


        if((old_midware_alarm.alarm_class == MIDWARE_TCA) &amp;&amp; (old_midware_alarm.admin == MIDWARE_ADMIN_DISABLE)
            &amp;&amp; (midware_alarm-&gt;admin == MIDWARE_ADMIN_ENABLE) &amp;&amp; (old_midware_alarm.state == MIDWARE_STATE_ON))
        {
            old_midware_alarm.state = MIDWARE_STATE_OFF;
            midware_update_entry_without_callback(MIDWARE_TABLE_ALARM, 0xffffffff, &amp;old_midware_alarm);
        }
    }

    if(bitmap &amp; MIDWARE_ENTRY_ALARM_THRESHOLD || bitmap &amp; MIDWARE_ENTRY_ALARM_CLEAR_THRESHOLD)
    {
        if (!apm_alarm_set_threshold(midware_alarm-&gt;type, midware_alarm-&gt;param1, midware_alarm-&gt;threshold, midware_alarm-&gt;clear_threshold))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apmSetAlarmThreshold for alarm id 0x%x\r\n",midware_alarm-&gt;type);
            return MDW_CB_RET_SET_HW_FAIL;
        }
    }

    /*MIDWARE_ENTRY_ALARM_STATE set from apm alarm report*/
    if(bitmap &amp; MIDWARE_ENTRY_ALARM_STATE)
    {
        if(TPM_EPON == wanTech)
        {
            if(midware_alarm-&gt;state)
            {
                oam_tl_alarm_generate(midware_alarm-&gt;type, midware_alarm-&gt;param1, midware_alarm-&gt;param2,
                OAM_ALARM_REPORT, midware_alarm-&gt;info);
            }
            else
            {
                oam_tl_alarm_generate(midware_alarm-&gt;type, midware_alarm-&gt;param1, midware_alarm-&gt;param2,
                OAM_ALARM_CLEAR_REPORT, midware_alarm-&gt;info);
            }

        }
        else if(TPM_GPON == wanTech)
        {
            omci_alarm_msg.alarm_type   = midware_alarm-&gt;type;
            omci_alarm_msg.param1       = midware_alarm-&gt;param1;
            omci_alarm_msg.param2       = midware_alarm-&gt;param2;
            omci_alarm_msg.alarm_class  = midware_alarm-&gt;alarm_class;
            omci_alarm_msg.state        = midware_alarm-&gt;state;
            omci_report_alarm(&amp;omci_alarm_msg);
        }
    }

    #if 0
    /*MIDWARE_ENTRY_ALARM_STATE set from apm alarm report*/
    if(bitmap &amp; MIDWARE_ENTRY_ALARM_INFO)
    {
        if(TPM_GPON == wanTech)
        {
            omci_report_alarm(midware_alarm-&gt;type, midware_alarm-&gt;param1, midware_alarm-&gt;param2, \
                midware_alarm-&gt;state, old_midware_alarm-&gt;alarm_class, midware_alarm-&gt;info);
        }
    }
    #endif

    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_alarm_insert(UINT32 bitmap, void *entry)
{
    bool                    callback_ret;
    MIDWARE_TABLE_ALARM_T   *midware_alarm = (MIDWARE_TABLE_ALARM_T *)entry;

    callback_ret = apm_alarm_create_entity(midware_alarm-&gt;type, midware_alarm-&gt;param1, midware_alarm-&gt;param2,
        midware_alarm-&gt;alarm_class, midware_alarm-&gt;admin, midware_alarm-&gt;threshold, midware_alarm-&gt;clear_threshold);
    if(!callback_ret)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apm_alarm_create_entity\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_alarm_remove(UINT32 bitmap, void *entry)
{
    bool                    callback_ret;
    MIDWARE_TABLE_ALARM_T   *midware_alarm = (MIDWARE_TABLE_ALARM_T *)entry;

    callback_ret = apm_alarm_delete_entity(midware_alarm-&gt;type, midware_alarm-&gt;param1);
    if (!callback_ret)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apmDeleteAlarmEntity\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }
     return MDW_CB_RET_SET_HW_OK;
}

static void  midware_clean_pm_data()
{
    MIDWARE_TABLE_INFO      *table_info;
    ONU_STATUS              rc;
    MIDWARE_TABLE_ALARM_T   midware_alarm;
    MIDWARE_TABLE_PM_T      midware_pm;
    UINT32                  bitmap;

    /*clean PM data*/
    table_info = midware_get_table_info(MIDWARE_TABLE_PM);
    bitmap = MIDWARE_ENTRY_PM_COUNTERS;
    rc = midware_sqlite3_get_first_sql_prepared(table_info, (void *)(&amp;midware_pm));
    if( ONU_FAIL == rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get first entry for pm: %d\n", rc);
        return;
    }

    do
    {
        if(midware_pm.accumulation_mode == MIDWARE_ACCUMULATION_15_MIN)
        {
            memset(&amp;midware_pm.counter0, 0, PM_COUNTERS_MAX_NUM*sizeof(UINT32));
            midware_sqlite3_get_update_sql_prepared(table_info, bitmap, &amp;midware_pm);
        }
        rc = midware_sqlite3_get_next_sql_prepared(table_info, (void *)(&amp;midware_pm));

    }while( ONU_FAIL != rc );

    /*clean PM history data*/
    table_info = midware_get_table_info(MIDWARE_TABLE_PM_HISTORY);
    bitmap = MIDWARE_ENTRY_PM_COUNTERS;
    rc = midware_sqlite3_get_first_sql_prepared(table_info, (void *)(&amp;midware_pm));
    if( ONU_FAIL == rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get first entry for pm history: %d\n", rc);
        return;
    }

    do
    {
        if(midware_pm.accumulation_mode == MIDWARE_ACCUMULATION_15_MIN)
        {
            memset(&amp;midware_pm.counter0, 0, PM_COUNTERS_MAX_NUM*sizeof(UINT32));
            midware_sqlite3_get_update_sql_prepared(table_info, bitmap, &amp;midware_pm);
        }
        rc = midware_sqlite3_get_next_sql_prepared(table_info, (void *)(&amp;midware_pm));

    }while( ONU_FAIL != rc );

    return;

}

static void  midware_Synchronize_TCA()
{
    MIDWARE_TABLE_INFO      *table_info;
    ONU_STATUS              rc;
    MIDWARE_TABLE_ALARM_T   midware_alarm;
    MIDWARE_TABLE_PM_T      midware_pm;
    UINT32                  bitmap;  

    /*clean PM data*/
    table_info = midware_get_table_info(MIDWARE_TABLE_PM);
    bitmap = MIDWARE_ENTRY_PM_COUNTERS;
    rc = midware_sqlite3_get_first_sql_prepared(table_info, (void *)(&amp;midware_pm));
    if( ONU_FAIL == rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get first entry for pm: %d\n", rc);
        return;
    }   
    
    do    
    {
        if(midware_pm.accumulation_mode == MIDWARE_ACCUMULATION_15_MIN)
        {
            memset(&amp;midware_pm.counter0, 0, PM_COUNTERS_MAX_NUM*sizeof(UINT32));
            midware_sqlite3_get_update_sql_prepared(table_info, bitmap, &amp;midware_pm);
        }
        rc = midware_sqlite3_get_next_sql_prepared(table_info, (void *)(&amp;midware_pm));
            
    }while( ONU_FAIL != rc );

    /*clean TCA*/
    table_info = midware_get_table_info(MIDWARE_TABLE_ALARM);
    bitmap = MIDWARE_ENTRY_ALARM_STATE;
    rc = midware_sqlite3_get_first_sql_prepared(table_info, (void *)(&amp;midware_alarm));
    if( ONU_FAIL == rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get first entry for alarm: %d\n", rc);
        return;
    }

    do
    {
        if( midware_alarm.alarm_class == MIDWARE_TCA &amp;&amp; midware_alarm.admin == MIDWARE_ADMIN_ENABLE
            &amp;&amp; midware_alarm.state == MIDWARE_STATE_ON)
        {
            midware_alarm.state = MIDWARE_STATE_OFF;
            midware_sqlite3_get_update_sql_prepared(table_info, bitmap, &amp;midware_alarm);
        }
        rc = midware_sqlite3_get_next_sql_prepared(table_info, (void *)(&amp;midware_alarm));
             
    }while( ONU_FAIL != rc );

    /*clean PM history data*/
    table_info = midware_get_table_info(MIDWARE_TABLE_PM_HISTORY);
    bitmap = MIDWARE_ENTRY_PM_COUNTERS;
    rc = midware_sqlite3_get_first_sql_prepared(table_info, (void *)(&amp;midware_pm));
    if( ONU_FAIL == rc )
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get first entry for pm history: %d\n", rc);
        return;
    }

    do
    {
        if(midware_pm.accumulation_mode == MIDWARE_ACCUMULATION_15_MIN)
        {
            memset(&amp;midware_pm.counter0, 0, PM_COUNTERS_MAX_NUM*sizeof(UINT32));
            midware_sqlite3_get_update_sql_prepared(table_info, bitmap, &amp;midware_pm);
        }
        rc = midware_sqlite3_get_next_sql_prepared(table_info, (void *)(&amp;midware_pm));

    }while( ONU_FAIL != rc );

    return;

}

void  midware_clear_Pm_Related_TCA(MIDWARE_TABLE_PM_T   *midware_pm)
{
    MIDWARE_TABLE_INFO              *table_info;
    ONU_STATUS                      rc;
    MIDWARE_TABLE_ALARM_T           midware_alarm;
    APM_PM_RELATED_ALARM_TYPES_T    pm_related_alarm_types;
    UINT32                          bitmap  = MIDWARE_ENTRY_ALARM_STATE;
    int                             i       = 0;


    if(!apm_pm_get_related_alarm_types(midware_pm-&gt;type, &amp;pm_related_alarm_types))
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_INFO,"Can't get related alarm type for pm type %d\n", midware_pm-&gt;type);
        return;
    }

    table_info = midware_get_table_info(MIDWARE_TABLE_ALARM);

    for(i=0; i&lt;APM_EXT_PM_BLOCK_SIZE; i++)
    {
        if(pm_related_alarm_types.pm_related_alarm_types[i]!=0)
        {
            midware_alarm.type      = pm_related_alarm_types.pm_related_alarm_types[i];
            midware_alarm.param1    = midware_pm-&gt;param1;
            rc                      = midware_sqlite3_get_select_sql_prepared(table_info, (void *)(&amp;midware_alarm));
            if( ONU_FAIL == rc )
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't get alarm entry type %d param1 %d\n", midware_alarm.type, midware_alarm.param1);
                return;
            }
            midware_alarm.state = MIDWARE_STATE_OFF;
            midware_sqlite3_get_update_sql_prepared(table_info, bitmap, &amp;midware_alarm);
        }
    }

    return;
}


ONU_STATUS midware_table_pm_init(void)
{
    return ONU_OK;
}

/*This func is not used yet*/
MIDWARE_CALLBACK_RET midware_table_pm_get(UINT32 bitmap, void *entry)
{
    bool                    rc;
    MIDWARE_TABLE_PM_T      *midware_pm;


    midware_pm = (MIDWARE_TABLE_PM_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_PM_COUNTERS)
    {
        if (!apm_pm_get_data(midware_pm-&gt;type, midware_pm-&gt;param1, (APM_PM_DATA_T *)&amp;midware_pm-&gt;counter0))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apmGetPmData for pm type 0x%x param1 %d\r\n",
                midware_pm-&gt;type, midware_pm-&gt;param1);
            return MDW_CB_RET_SET_HW_FAIL;
        }
    }

    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_pm_set(UINT32 bitmap, void *entry)
{
    bool                    rc;
    MIDWARE_TABLE_PM_T      *midware_pm;

    midware_pm = (MIDWARE_TABLE_PM_T *)entry;
    OMCI_REPORT_PM_MSG_S pmMsg;

    if(bitmap &amp; MIDWARE_ENTRY_PM_ADMIN_BITS)
    {
        if (!apm_pm_set_admin(midware_pm-&gt;type, midware_pm-&gt;param1, midware_pm-&gt;admin_bits))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apmSetPmAdmin for pm type 0x%x\r\n",midware_pm-&gt;type);
            return MDW_CB_RET_SET_HW_FAIL;
        }
    }

    if(bitmap &amp; MIDWARE_ENTRY_PM_COUNTERS)
    {
        if(TPM_GPON == wanTech)
        {
            midware_clear_Pm_Related_TCA(midware_pm);

            pmMsg.pm_type   = midware_pm-&gt;type;
            pmMsg.param1    = midware_pm-&gt;param1;
            pmMsg.param2    = midware_pm-&gt;param2;
            memmove(pmMsg.pmData, &amp;midware_pm-&gt;counter0, sizeof(UINT32)*PM_COUNTERS_MAX_NUM);

            omci_report_pm(&amp;pmMsg);
        }
    }

    if(bitmap &amp; MIDWARE_ENTRY_PM_ACCUMULATION_MODE)
    {
        if (!apm_pm_set_accumulation_mode(midware_pm-&gt;type, midware_pm-&gt;param1, midware_pm-&gt;accumulation_mode))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apmSetPmAccumulationMode for type id 0x%x\r\n",midware_pm-&gt;type);
            return MDW_CB_RET_SET_HW_FAIL;
        }
        midware_clear_Pm_Related_TCA(midware_pm);
    }

    if(bitmap &amp; MIDWARE_ENTRY_PM_GLOBAL_CLEAR)
    {
        if(PM_GLOBAL_CLEAR == midware_pm-&gt;global_clear)
        {
            if (!apm_pm_set_global_clear(midware_pm-&gt;type, midware_pm-&gt;param1))
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apmSetPmGlobalClear for pm type 0x%x\r\n",midware_pm-&gt;type);
                return MDW_CB_RET_SET_HW_FAIL;
            }
            midware_clear_Pm_Related_TCA(midware_pm);
        }

        /*clean current PM and HISTORY PM midware data */
        midware_clean_pm_data();

    }

    if(bitmap &amp; MIDWARE_ENTRY_PM_INTERVAL_PERIOD)
    {
		if(!apm_pm_set_interval(midware_pm-&gt;type, midware_pm-&gt;param1, midware_pm-&gt;interval))
	    {
	        return MDW_CB_RET_SET_HW_FAIL;
	    }

    }
    
    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_pm_insert(UINT32 bitmap, void *entry)
{
    bool                    callback_ret;
    MIDWARE_TABLE_PM_T      *midware_pm = (MIDWARE_TABLE_PM_T *)entry;


    callback_ret = apm_pm_create_entity(midware_pm-&gt;type, midware_pm-&gt;param1, midware_pm-&gt;param2, midware_pm-&gt;admin_bits, midware_pm-&gt;accumulation_mode, midware_pm-&gt;interval);
    if(!callback_ret)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apm_pm_create_entity\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_pm_remove(UINT32 bitmap, void *entry)
{
    bool                    callback_ret;
    MIDWARE_TABLE_PM_T      *midware_pm = (MIDWARE_TABLE_PM_T *)entry;

    callback_ret = apm_pm_delete_entity(midware_pm-&gt;type, midware_pm-&gt;param1);
    if (!callback_ret)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apmDeletePmEntity\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }
    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_pm_history_set(UINT32 bitmap, void *entry)
{
    bool                    rc;
    MIDWARE_TABLE_PM_T      *midware_pm;
    
    midware_pm = (MIDWARE_TABLE_PM_T *)entry;
    OMCI_REPORT_PM_MSG_S pmMsg;

    if(bitmap &amp; MIDWARE_ENTRY_PM_COUNTERS)
    {
        if(TPM_GPON == wanTech)
        {
            midware_clear_Pm_Related_TCA(midware_pm);

            pmMsg.pm_type   = midware_pm-&gt;type;
            pmMsg.param1    = midware_pm-&gt;param1;
            pmMsg.param2    = midware_pm-&gt;param2;
            memmove(pmMsg.pmData, &amp;midware_pm-&gt;counter0, sizeof(UINT32)*PM_COUNTERS_MAX_NUM);
            
            omci_report_pm(&amp;pmMsg);
        }
    }
    
    return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_avc_init(void)
{
    return ONU_OK;
}

/*This func is not used yet*/
MIDWARE_CALLBACK_RET midware_table_avc_get(UINT32 bitmap, void *entry)
{
    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_avc_set(UINT32 bitmap, void *entry)
{
    bool                   rc;
    MIDWARE_TABLE_AVC_T   *midware_avc;
    OMCI_REPORT_AVC_MSG_S omci_avc_msg;

    midware_avc = (MIDWARE_TABLE_AVC_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_AVC_ADMIN)
    {
        if (!apm_avc_set_admin(midware_avc-&gt;type, midware_avc-&gt;param1, midware_avc-&gt;admin))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apmSetAVCAdminState for avc type 0x%x\r\n",midware_avc-&gt;type);
            return MDW_CB_RET_SET_HW_FAIL;
        }
    }

    if(bitmap &amp; MIDWARE_ENTRY_AVC_PARAM2)
    {
        if (!apm_avc_set_param2(midware_avc-&gt;type, midware_avc-&gt;param1, midware_avc-&gt;param2))
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apmSetAVCAdminState for avc type 0x%x\r\n",midware_avc-&gt;type);
            return MDW_CB_RET_SET_HW_FAIL;
        }
    }

    /*MIDWARE_ENTRY_AVC_STATE set from apm avc report*/
    if(bitmap &amp; MIDWARE_ENTRY_AVC_VALUE)
    {
        if(TPM_EPON == wanTech)
        {
            oam_tl_avc_generate(midware_avc-&gt;type, midware_avc-&gt;param1, midware_avc-&gt;param2, *(UINT32 *)midware_avc-&gt;value);
        }
        else if(TPM_GPON == wanTech)
        {
            omci_avc_msg.avc_type   = midware_avc-&gt;type;
            omci_avc_msg.param1     = midware_avc-&gt;param1;
            omci_avc_msg.param2     = midware_avc-&gt;param2;
            memmove(omci_avc_msg.value, midware_avc-&gt;value, MIDWARE_AVC_VALUE_LENGTH*sizeof(UINT8));
            omci_report_avc(&amp;omci_avc_msg);
        }
    }

    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_avc_insert(UINT32 bitmap, void *entry)
{
    bool                    callback_ret;
    MIDWARE_TABLE_AVC_T     *midware_avc = (MIDWARE_TABLE_AVC_T *)entry;

    callback_ret = apm_avc_create_entity(midware_avc-&gt;type, midware_avc-&gt;param1, midware_avc-&gt;param2, midware_avc-&gt;admin);
    if (!callback_ret)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apm_avc_create_entity\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }

    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_avc_remove(UINT32 bitmap, void *entry)
{
    bool                    callback_ret;
    MIDWARE_TABLE_AVC_T     *midware_avc = (MIDWARE_TABLE_AVC_T *)entry;

    callback_ret = apm_avc_delete_entity(midware_avc-&gt;type, midware_avc-&gt;param1);
    if (!callback_ret)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to apmDeleteAVCEntity\r\n");
        return MDW_CB_RET_SET_HW_FAIL;
    }
    return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_vlan_port_init(void)
{
    ONU_STATUS rc = ONU_OK;
    MIDWARE_TABLE_VLAN_PORT_T vlan_cfg;
    MIDWARE_TABLE_INFO *table_info;
    UINT32 i;

#if 1 /* Need not to restore*/
    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_VLAN_PORT))
    {
        //already got entries in the table, restore
        /*
        rc = midware_table_restore(MIDWARE_TABLE_VLAN_PORT);
        if (ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to restore MIDWARE_TABLE_VLAN_PORT\r\n");
            return ONU_FAIL;
        }
        */
        return ONU_OK;
    }
#endif

    //init the default entries
    memset(&amp;vlan_cfg, 0, sizeof(vlan_cfg));
    vlan_cfg.vlan_mode = MIDWARE_VLAN_MODE_TRANSPARENT; /*VLAN transparent mode*/

    table_info = midware_get_table_info(MIDWARE_TABLE_VLAN_PORT);
    for(i = TPM_SRC_PORT_UNI_0; i &lt;= TPM_SRC_PORT_UNI_3; i++)
    {
        vlan_cfg.port_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;vlan_cfg);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for port: %ld\n", i);
            return ONU_FAIL;
        }
    }

    return ONU_OK;
}


MIDWARE_CALLBACK_RET midware_table_vlan_port_set(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_VLAN_PORT_T *vlan_cfg;
    tpm_error_code_t          rc = ERR_GENERAL;
    MIDWARE_CALLBACK_RET      callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    tpm_src_port_type_t       port_id;
    UINT32                    default_vid;

    vlan_cfg = (MIDWARE_TABLE_VLAN_PORT_T *)entry;

    //here maybe we need to adapt the midware portid to tpm portid
    port_id = vlan_cfg-&gt;port_id;

    if(bitmap &amp; MIDWARE_ENTRY_DEFAULT_VLAN)
    {
      default_vid = vlan_cfg-&gt;default_vlan;
    }
    else
    {
      default_vid = 0;
    }
    return callback_ret;
}

ONU_STATUS midware_table_ethernet_uni_pm_init(void)
{
    ONU_STATUS      rc = ONU_OK;
    MIDWARE_TABLE_STATISTICS_T     ethernet_uni_pm;
    UINT32             i;
    MIDWARE_TABLE_INFO *table_info;



    //init the default entries
    memset(&amp;ethernet_uni_pm, 0, sizeof(ethernet_uni_pm));
    ethernet_uni_pm.enable = 1;

    table_info = midware_get_table_info(MIDWARE_TABLE_ETH_UNI_PM);
    for(i = TPM_SRC_PORT_UNI_0; i &lt;= TPM_SRC_PORT_UNI_3; i++)
    {
        ethernet_uni_pm.port_id = i;
        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;ethernet_uni_pm);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for port: %ld\n", i);
            return ONU_FAIL;
        }

    }

    return ONU_OK;

}


MIDWARE_CALLBACK_RET midware_table_ethernet_uni_pm_get(UINT32 bitmap, void *entry)
{
    INT32                           rc;
    MIDWARE_TABLE_STATISTICS_T      *midware_ethernet_uni_pm;
    tpm_swport_pm_3_all_t           tpm_swport_pm_3;

    midware_ethernet_uni_pm = (MIDWARE_TABLE_STATISTICS_T *)entry;

    if(0 == midware_ethernet_uni_pm-&gt;enable)
    {
        return MDW_CB_RET_SET_HW_FAIL;
    }

    rc = tpm_sw_pm_3_read(0, midware_ethernet_uni_pm-&gt;port_id, &amp;tpm_swport_pm_3);
    if (TPM_RC_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Failed to tpm_sw_pm_3_read for port_id %d \r\n",midware_ethernet_uni_pm-&gt;port_id);
        return MDW_CB_RET_SET_HW_FAIL;
    }

    midware_ethernet_uni_pm-&gt;packet_rx              = tpm_swport_pm_3.InUnicasts+tpm_swport_pm_3.InMulticasts+tpm_swport_pm_3.InBroadcasts;
    midware_ethernet_uni_pm-&gt;unicast_packet_rx      = tpm_swport_pm_3.InUnicasts;
    midware_ethernet_uni_pm-&gt;multicast_packet_rx    = tpm_swport_pm_3.InMulticasts;
    midware_ethernet_uni_pm-&gt;broadcast_packet_rx    = tpm_swport_pm_3.InBroadcasts;

    midware_ethernet_uni_pm-&gt;packet_tx              = 0;//tpm_swport_pm_1.OutUnicasts+tpm_swport_pm_1.OutMulticasts+tpm_swport_pm_1.OutBroadcasts;
    midware_ethernet_uni_pm-&gt;unicast_packet_tx      = 0;//tpm_swport_pm_1.OutUnicasts;
    midware_ethernet_uni_pm-&gt;multicast_packet_tx    = 0;//tpm_swport_pm_1.OutMulticasts;
    midware_ethernet_uni_pm-&gt;broadcast_packet_tx    = 0;//tpm_swport_pm_1.OutBroadcasts;
    /* Whether the following items are tx or rx depends Histogram Counters Mode.
    The Histogram mode bits control how the
    Histogram counters work as follows:
    00 = Reserved
    01 = Count received frames only
    10 = Count transmitted frames only
    11 = Count receive and transmitted frames
    */
    #if 0
    midware_ethernet_uni_pm-&gt;packet_64B_rx          = tpm_swport_pm_1.packets_64Octets;
    midware_ethernet_uni_pm-&gt;packet_65_127B_rx      = tpm_swport_pm_1.packets_65_127Octets;
    midware_ethernet_uni_pm-&gt;packet_128_255B_rx     = tpm_swport_pm_1.packets_128_255Octets;
    midware_ethernet_uni_pm-&gt;packet_256_511B_rx     = tpm_swport_pm_1.packets_256_511Octets;
    midware_ethernet_uni_pm-&gt;packet_512_1023B_rx    = tpm_swport_pm_1.packets_512_1023Octets;
    midware_ethernet_uni_pm-&gt;packet_1024_1518B_rx   = tpm_swport_pm_1.packets_1024_1518Octets;
    midware_ethernet_uni_pm-&gt;packet_1519B_rx        = tpm_swport_pm_1.jabbers;
    #endif

    return MDW_CB_RET_SET_HW_OK;
}

ONU_STATUS midware_table_epon_init(void)
{
    ONU_STATUS      rc;
    MIDWARE_TABLE_EPON_T    epon_cfg;
    MIDWARE_TABLE_INFO *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_EPON))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;epon_cfg, 0, sizeof(epon_cfg));
    epon_cfg.fec= MIDWARE_PON_FEC_MODE_DISABLED;
    epon_cfg.multi_llid = 1;
    epon_cfg.holdover_cfg = MIDWARE_HOLDOVER_STATE_DEACTIVE;
    epon_cfg.holdover_time = 200;
    epon_cfg.register_status = MIDWARE_SFU_OAM_STACK_DEREG;

    MvExtOamGetMac(epon_cfg.base_pon_mac);

    table_info = midware_get_table_info(MIDWARE_TABLE_EPON);
    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;epon_cfg);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_EPON  \n");
        return ONU_FAIL;
    }
    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_epon_get(UINT32 bitmap, void *entry)
{
    INT32    rc;

    // todo

    return MDW_CB_RET_SET_HW_OK;
}

MIDWARE_CALLBACK_RET midware_table_epon_set(UINT32 bitmap, void *entry)
{

    MIDWARE_TABLE_EPON_T              *EponCfg;
    MIDWARE_CALLBACK_RET      callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    //to do

    EponCfg = (MIDWARE_TABLE_EPON_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_EPON_MAC)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_EPON_MULTI_LLID)
    {

        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_EPON_FEC)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }


    if(bitmap &amp; MIDWARE_ENTRY_HOLDOVER_CFG)
    {

    }

    if(bitmap &amp; MIDWARE_ENTRY_HOLDOVER_TIME)
    {

    }
#if 0
    if(bitmap &amp; MIDWARE_ENTRY_END_EPON)
    {

    }
#endif
    if(bitmap &amp; MIDWARE_ENTRY_ONU_REGISTER_STATUS)
    {

    }

    if(bitmap &amp; MIDWARE_ENTRY_ONU_LLID_NUM)
    {

    }

     return callback_ret;
}

ONU_STATUS midware_table_v_cfg_init(void)
{
    ONU_STATUS              rc;
    MIDWARE_TABLE_V_CFG_T   v_cfg;
    MIDWARE_TABLE_INFO     *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_V_CFG))
    {
        //already got entries in the table
        return ONU_OK;
    }
    UINT8      available_proto;

    //init the default entries
    memset(&amp;v_cfg, 0, sizeof(v_cfg));
    v_cfg.index            = 0;
    v_cfg.available_proto  = MIDWARE_V_PROTO_BM_SIP|MIDWARE_V_PROTO_BM_H248;
    v_cfg.used_proto       = MIDWARE_V_PROTO_TYPE_SIP;
    v_cfg.available_method = MIDWARE_V_METHOD_BM_OMCI|MIDWARE_V_METHOD_BM_TR69;
    v_cfg.used_method      = MIDWARE_V_METHOD_TYPE_OMCI;
    v_cfg.config_state     = MIDWARE_V_CONFGI_STATE_INITIAL;
    v_cfg.retrieve_profile = MIDWARE_DEFAULT_ZERO_VAL;
#if 0
    v_cfg.profile_version;
    v_cfg.mac_addr;
    v_cfg.sw_ver;
    v_cfg.sw_time;
#endif
    v_cfg.pots_num         = MIDWARE_SFU_POTS_PORT_NUM;
    v_cfg.ip_mode          = MIDWARE_SFU_VOICE_IP_MODE_STATIC;
    v_cfg.ip_addr          = MIDWARE_DEFAULT_ZERO_VAL;
    v_cfg.net_mask         = MIDWARE_DEFAULT_ZERO_VAL;
    v_cfg.def_gw           = MIDWARE_DEFAULT_ZERO_VAL;
    v_cfg.pppoe_mode       = MIDWARE_SFU_VOICE_IP_MODE_STATIC;
#if 0
    v_cfg.pppoe_user;
    v_cfg.pppoe_pwd;
#endif
    v_cfg.tag_flag         = MIDWARE_DEFAULT_ZERO_VAL;
    v_cfg.cvlan            = MIDWARE_DEFAULT_ZERO_VAL;
    v_cfg.svlan            = MIDWARE_DEFAULT_ZERO_VAL;
    v_cfg.pbits            = MIDWARE_DEFAULT_ZERO_VAL;
    v_cfg.iad_operate      = MIDWARE_DEFAULT_ZERO_VAL;

    table_info = midware_get_table_info(MIDWARE_TABLE_V_CFG);
    rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;v_cfg);
    if(ONU_OK != rc)
    {
        MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for MIDWARE_TABLE_V_CFG  \n");
        return ONU_FAIL;
    }
    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_v_cfg_get(UINT32 bitmap, void *entry)
{

    MIDWARE_TABLE_V_CFG_T   *v_cfg;
    MIDWARE_CALLBACK_RET     callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    //to do

    v_cfg = (MIDWARE_TABLE_V_CFG_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_V_SUPPORT_PROTO)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_USED_PROTO)
    {

        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_SUPPORT_METHOD)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_USED_METHOD)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_CONFIG_STATE)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_RTRL_PROFILE)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_PROFILE_VER)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_MAC_ADDR)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_SW_VER)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_SW_TIME)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_POTS_NUM)
    {

      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_IP_MODE)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_IP_ADDR)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_NET_MASK)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_DEFAULT_GW)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_PPPOE_MODE)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_PPPOE_USER)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_PPPOE_USER)
    {
    callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_PPPOE_PWD)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_TAG_FLAG)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_VOICE_CVID)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_VOICE_SVID)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_VOICE_PBIT)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_IAD_OPER)
    {
      callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_v_cfg_set(UINT32 bitmap, void *entry)
{

    MIDWARE_TABLE_V_CFG_T   *v_cfg;
    MIDWARE_CALLBACK_RET     callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    INT32                    rc;

    v_cfg = (MIDWARE_TABLE_V_CFG_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_V_USED_PROTO)
    {

        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_USED_METHOD)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_CONFIG_STATE)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_RTRL_PROFILE)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_IP_MODE)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if((bitmap &amp; MIDWARE_ENTRY_V_IP_ADDR)  ||
       (bitmap &amp; MIDWARE_ENTRY_V_NET_MASK) ||
       (bitmap &amp; MIDWARE_ENTRY_V_DEFAULT_GW))
    {
        rc = VOIP_updateHostIpAddr_F(v_cfg-&gt;ip_addr, v_cfg-&gt;net_mask, v_cfg-&gt;def_gw);

        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG, "Failed to call VOIP_updateHostIpAddr_F\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_PPPOE_MODE)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_PPPOE_USER)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_PPPOE_USER)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_PPPOE_PWD)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if((bitmap &amp; MIDWARE_ENTRY_V_TAG_FLAG)   ||
       (bitmap &amp; MIDWARE_ENTRY_V_VOICE_CVID) ||
       (bitmap &amp; MIDWARE_ENTRY_V_VOICE_SVID) ||
       (bitmap &amp; MIDWARE_ENTRY_V_VOICE_PBIT))
    {
        rc = VOIP_updateHostVidPbits_F(v_cfg-&gt;cvlan, v_cfg-&gt;pbits);

        if (OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG, "Failed to call VOIP_updateHostVidPbits_F\r\n");
            return MDW_CB_RET_SET_HW_FAIL;
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_IAD_OPER)
    {
        if (MIDWARE_V_IAD_OPERATION_RESET == v_cfg-&gt;iad_operate)
        {
            midware_restart_mmp_app();
        }
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    return callback_ret;
}

ONU_STATUS midware_table_v_port_cfg_init(void)
{
    ONU_STATUS                  rc=ONU_OK;
    MIDWARE_TABLE_V_PORT_CFG_T  v_port_cfg;
    UINT32                      i;
    MIDWARE_TABLE_INFO         *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_V_PORT_CFG))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;v_port_cfg, 0, sizeof(v_port_cfg));

    v_port_cfg.admin_state     = MIDWARE_OMCI_UNLOCK_STATE;
    v_port_cfg.impedence       = MIDWARE_DEFAULT_ZERO_VAL;
    v_port_cfg.tx_path         = MIDWARE_DEFAULT_ZERO_VAL;
    v_port_cfg.rx_gain         = MIDWARE_DEFAULT_ZERO_VAL;
    v_port_cfg.tx_gain         = MIDWARE_DEFAULT_ZERO_VAL;
    v_port_cfg.operation_state = MIDWARE_OMCI_UNLOCK_STATE;
    v_port_cfg.hook_state      = MIDWARE_V_OFF_HOOK_STATE;
    v_port_cfg.holdover_time   = MIDWARE_DEFAULT_ZERO_VAL;
    v_port_cfg.signal_code     = MIDWARE_DEFAULT_ZERO_VAL;

    table_info = midware_get_table_info(MIDWARE_TABLE_V_PORT_CFG);
    for(i = 0; i &lt; MIDWARE_SFU_POTS_PORT_NUM; i++)
    {
        v_port_cfg.line_id = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;v_port_cfg);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for port: %ld\n", i);
            return ONU_FAIL;
        }

    }

    return ONU_OK;

}

MIDWARE_CALLBACK_RET midware_table_v_port_cfg_get(UINT32 bitmap, void *entry)
{

    MIDWARE_TABLE_V_PORT_CFG_T  *v_port_cfg;
    MIDWARE_CALLBACK_RET         callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    //to do

    v_port_cfg = (MIDWARE_TABLE_V_PORT_CFG_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_V_ADMIN_STATE)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_IMPEDANCE)
    {

        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_TX_PATH)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_RX_GAIN)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_TX_GAIN)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_OPER_STATE)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_HOOK_STATE)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_HOLDOVER_TIME)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_SIGNAL_CODE)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_v_port_cfg_set(UINT32 bitmap, void *entry)
{

    MIDWARE_TABLE_V_PORT_CFG_T  *v_port_cfg;
    MIDWARE_CALLBACK_RET         callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    //to do

    v_port_cfg = (MIDWARE_TABLE_V_PORT_CFG_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_V_ADMIN_STATE)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_IMPEDANCE)
    {

        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_TX_PATH)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_RX_GAIN)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_TX_GAIN)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_HOLDOVER_TIME)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_SIGNAL_CODE)
    {
        callback_ret = MDW_CB_RET_SET_HW_OK;
    }

    return callback_ret;
}

ONU_STATUS midware_table_v_sip_agent_init(void)
{
    ONU_STATUS                   rc = ONU_OK;
    MIDWARE_TABLE_V_SIP_AGENT_T  v_sip_agent;
    UINT32                       i;
    UINT32                       j;
    MIDWARE_TABLE_INFO          *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_V_SIP_AGENT))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;v_sip_agent, 0, sizeof(v_sip_agent));

#if 0
    v_sip_agent.proxy_serv_addr
    v_sip_agent.backup_proxy_serv_addr
    v_sip_agent.outbound_proxy_addr
    v_sip_agent.host_part_url
    v_sip_agent.reg_user
    v_sip_agent.reg_pwd
    v_sip_agent.reg_realm
    v_sip_agent.reg_addr
    v_sip_agent.backup_reg_addr
    v_sip_agent.response_code
    v_sip_agent.response_tone
    v_sip_agent.response_text
#endif

    v_sip_agent.reg_scheme          = MIDWARE_V_VALIDATE_SCHEME_NONE;
    v_sip_agent.primary_dns         = MIDWARE_DEFAULT_ZERO_VAL;
    v_sip_agent.second_dns          = MIDWARE_DEFAULT_ZERO_VAL;
    v_sip_agent.l4_type             = MIDWARE_DEFAULT_ZERO_VAL;
    v_sip_agent.l4_port             = MIDWARE_DEFAULT_ZERO_VAL;
    v_sip_agent.dscp_val            = MIDWARE_DEFAULT_ZERO_VAL;
    v_sip_agent.reg_expire_time     = MIDWARE_V_DEFT_REG_EXP_TIME;
    v_sip_agent.reg_head_start_time = MIDWARE_V_REREG_HEAD_START_TIME;
    v_sip_agent.soft_switch         = MIDWARE_DEFAULT_ZERO_VAL;
    v_sip_agent.optical_tx_ctrl     = MIDWARE_DEFAULT_ZERO_VAL;
    v_sip_agent.url_format          = MIDWARE_V_URL_FORMAT_SIP;
    v_sip_agent.status              = MIDWARE_V_SIP_STATUS_OK_INIT;
    v_sip_agent.heartbeat_switch    = MIDWARE_SFU_SIP_HEARTBEAT_SWITCH_OPEN;
    v_sip_agent.heartbeat_cycle     = MIDWARE_SFU_HEARTBEAT_CYCLE;
    v_sip_agent.heartbeat_count     = MIDWARE_SFU_HEARTBEAT_HEARTBEAT_COUNT;

    table_info = midware_get_table_info(MIDWARE_TABLE_V_SIP_AGENT);
    for(i = 0; i &lt; MIDWARE_SFU_POTS_PORT_NUM; i++)
    {
        for(j = 0; j &lt; MIDWARE_V_SIP_AGENT_NUM; j++)
        {
            v_sip_agent.line_id  = i;
            v_sip_agent.agent_id = j;

            rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;v_sip_agent);
            if(ONU_OK != rc)
            {
                MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for port: %ld %ld \n", i, j);
                return ONU_FAIL;
            }
        }

    }

    return ONU_OK;
}

MIDWARE_CALLBACK_RET midware_table_v_sip_agent_get(UINT32 bitmap, void *entry)
{
  MIDWARE_TABLE_V_SIP_AGENT_T *v_sip_agent;
  MIDWARE_CALLBACK_RET         callback_ret = MDW_CB_RET_SET_HW_NO_NEED;

  v_sip_agent = (MIDWARE_TABLE_V_SIP_AGENT_T *)entry;

  //TBD

   return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_v_sip_agent_set(UINT32 bitmap, void *entry)
{
  MIDWARE_TABLE_V_SIP_AGENT_T  *v_sip_agent;
  MIDWARE_CALLBACK_RET          callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
  INT32                         rc;

  v_sip_agent = (MIDWARE_TABLE_V_SIP_AGENT_T *)entry;

  if(bitmap &amp; MIDWARE_ENTRY_V_PROXY_SERV_ADDR)
  {
      rc = VOIP_updateSipServerAddr_F(v_sip_agent-&gt;line_id, v_sip_agent-&gt;proxy_serv_addr);

      if (OK != rc)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG, "Failed to VOIP_updateSipServerAddr_F\r\n");
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;
  }

   return callback_ret;
}

ONU_STATUS midware_table_v_sip_user_init(void)
{
    ONU_STATUS                   rc = ONU_OK;
    MIDWARE_TABLE_V_SIP_USER_T   v_sip_user;
    UINT32                       i;
    MIDWARE_TABLE_INFO          *table_info;

    if(0 != midware_sqlite3_get_entry_count(MIDWARE_TABLE_V_SIP_USER))
    {
        //already got entries in the table
        return ONU_OK;
    }

    //init the default entries
    memset(&amp;v_sip_user, 0, sizeof(v_sip_user));
#if 0
    v_sip_user.user_aor
    v_sip_user.display_name
    v_sip_user.auth_user
    v_sip_user.auth_pwd
    v_sip_user.auth_realm
    v_sip_user.auth_addr
    v_sip_user.voicemail_addr
#endif

    v_sip_user.auth_scheme          = MIDWARE_V_VALIDATE_SCHEME_NONE;
    v_sip_user.voicemail_exp_time   = MIDWARE_V_DEFT_REG_EXP_TIME;
    v_sip_user.release_timer        = MIDWARE_V_DEFT_RELEASE_TIME;
    v_sip_user.roh_timer            = MIDWARE_V_DEFT_ROH_TIME;

    table_info = midware_get_table_info(MIDWARE_TABLE_V_SIP_USER);
    for(i = 0; i &lt; MIDWARE_SFU_POTS_PORT_NUM; i++)
    {
        v_sip_user.line_id  = i;

        rc = midware_sqlite3_get_insert_sql_prepared(table_info, &amp;v_sip_user);
        if(ONU_OK != rc)
        {
            MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG,"Can't insert entries for port: %ld \n", i);
            return ONU_FAIL;
        }
    }

    return ONU_OK;
}

MIDWARE_CALLBACK_RET midware_table_v_sip_user_get(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_V_SIP_USER_T  *v_sip_user;
    MIDWARE_CALLBACK_RET         callback_ret = MDW_CB_RET_SET_HW_NO_NEED;

    v_sip_user = (MIDWARE_TABLE_V_SIP_USER_T *)entry;

  //TBD

   return callback_ret;
}

MIDWARE_CALLBACK_RET midware_table_v_sip_user_set(UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_V_SIP_USER_T  *v_sip_user;
    MIDWARE_CALLBACK_RET         callback_ret = MDW_CB_RET_SET_HW_NO_NEED;
    INT32                        rc;
    UINT8                        *pauth_user = 0;
    UINT8                        *pauth_pwd = 0;

    v_sip_user = (MIDWARE_TABLE_V_SIP_USER_T *)entry;

    if(bitmap &amp; MIDWARE_ENTRY_V_AUTH_USER)
    {
        pauth_user = v_sip_user-&gt;auth_user;
    }
    if(bitmap &amp; MIDWARE_ENTRY_V_AUTH_PWD)
    {
        pauth_pwd = v_sip_user-&gt;auth_pwd;
    }

    if(bitmap &amp; MIDWARE_ENTRY_V_USER_AOR)
    {
      rc = VOIP_updateSipAccountData_F(v_sip_user-&gt;line_id, pauth_user, pauth_pwd, v_sip_user-&gt;user_aor);

      if (OK != rc)
      {
          MDW_DEBUG(MIDWARE_TRACE_LEVEL_DEBUG, "Failed to VOIP_updateSipAccountData_F\r\n");
          return MDW_CB_RET_SET_HW_FAIL;
      }
      callback_ret = MDW_CB_RET_SET_HW_OK;

    }

    return callback_ret;
}

MIDWARE_TABLE_CALLBACK_INFO    g_midware_table_callback[] =
{
  /* table id,                      get, update, insert, remove, init  */
  {MIDWARE_TABLE_ONU_INFO        , midware_table_onu_info_get, NULL, NULL, NULL, midware_table_onu_info_init, NULL},
  {MIDWARE_TABLE_ONU_CFG         , NULL, midware_table_onu_cfg_set, NULL, NULL, midware_table_onu_cfg_init, NULL},
  {MIDWARE_TABLE_ONU_IP          , midware_table_onu_ip_get, midware_table_onu_ip_set, midware_table_onu_ip_set, NULL, midware_table_onu_ip_init, NULL},
  {MIDWARE_TABLE_UNI_CFG         , midware_table_uni_cfg_get, midware_table_uni_cfg_set, NULL, NULL, midware_table_uni_cfg_init, NULL},
  {MIDWARE_TABLE_UNI_QOS         , midware_table_uni_qos_get, midware_table_uni_qos_set, NULL, NULL, midware_table_uni_qos_init, NULL},
  {MIDWARE_TABLE_VLAN            , NULL, midware_table_vlan_set, midware_table_vlan_insert, midware_table_vlan_remove, NULL, NULL},
  {MIDWARE_TABLE_FLOW            , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_FLOW_MOD_VLAN   , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_FLOW_MOD_MAC    , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_FLOW_MOD_PPPOE  , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_FLOW_MOD_IPV4   , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_FLOW_MOD_IPV6   , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_FLOW_KEY_L2     , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_FLOW_KEY_IPV4   , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_FLOW_KEY_IPV6   , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_MC_CFG          , NULL, midware_table_mc_cfg_set, NULL, NULL, midware_table_mc_cfg_init, NULL},
  {MIDWARE_TABLE_MC_PORT_CFG     , NULL, midware_table_mc_port_set, NULL, NULL, midware_table_mc_port_init, NULL},
  {MIDWARE_TABLE_MC_PORT_STATUS  , midware_table_mc_port_status_get, NULL, NULL, NULL, midware_table_mc_port_status_init, NULL},
  {MIDWARE_TABLE_MC_ACTIVE_GROUP , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_MC_PORT_CONTROL , NULL, midware_table_mc_port_acl_set, NULL, NULL, midware_table_mc_port_acl_init, NULL},
  {MIDWARE_TABLE_MC_PORT_SERV    , NULL, midware_table_mc_port_serv_set, NULL, NULL, midware_table_mc_port_serv_init, NULL},
  {MIDWARE_TABLE_MC_PORT_PREVIEW , NULL, midware_table_mc_port_preview_set, NULL, NULL, midware_table_mc_port_preview_init, NULL},
  {MIDWARE_TABLE_MC_DS_VLAN_TRANS, NULL, midware_table_mc_ds_vlan_set, midware_table_mc_ds_vlan_insert, midware_table_mc_ds_vlan_remove, NULL, NULL},
  {MIDWARE_TABLE_MC_US_VLAN_TRANS, NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_MC_LEARN        , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_MC_STREAM       , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_WAN_QOS         , NULL, midware_table_wan_qos_set, NULL, NULL, midware_table_wan_qos_init, NULL},
  {MIDWARE_TABLE_EPON            , midware_table_epon_get, midware_table_epon_set, NULL, NULL, midware_table_epon_init, NULL},
  {MIDWARE_TABLE_DBA             , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_SW_IMAGE        , midware_table_sw_image_get, midware_table_sw_image_set, NULL, NULL, midware_table_sw_image_init, NULL},
  {MIDWARE_TABLE_OPT_TRANSCEIVER , midware_table_opt_transceiver_get, NULL, NULL, NULL, midware_table_opt_transceiver_init, NULL},
  {MIDWARE_TABLE_ALARM           , NULL, midware_table_alarm_set, midware_table_alarm_insert, midware_table_alarm_remove, NULL, NULL},
  {MIDWARE_TABLE_PM              , midware_table_pm_get, midware_table_pm_set, midware_table_pm_insert, midware_table_pm_remove, NULL, NULL},
  {MIDWARE_TABLE_PM_HISTORY      , NULL, midware_table_pm_history_set, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_EPON_AUTH       , NULL, NULL, NULL, NULL, midware_table_epon_auth_init, NULL},
  {MIDWARE_TABLE_WEB_ACCOUNT     , NULL, NULL, NULL, NULL, midware_table_web_account_init, NULL},
  {MIDWARE_TABLE_IAD_PORT_ADMIN  , NULL, midware_table_iad_port_admin_set, NULL, NULL, midware_table_iad_port_admin_init, NULL},
  {MIDWARE_TABLE_IAD_INFO        , midware_table_iad_info_get, NULL, NULL, NULL, midware_table_iad_info_init, NULL},
  {MIDWARE_TABLE_IAD_CFG         , midware_table_iad_cfg_get, midware_table_iad_cfg_set, NULL, NULL, midware_table_iad_cfg_init, NULL},
  {MIDWARE_TABLE_H248_CFG        , NULL, midware_table_h248_cfg_set, NULL, NULL, midware_table_h248_cfg_init, NULL},
  {MIDWARE_TABLE_H248_USER_INFO  , NULL, midware_table_h248_user_info_set, NULL, NULL, midware_table_h248_user_info_init, NULL},
  {MIDWARE_TABLE_H248_RTP_CFG    , NULL, midware_table_h248_rtp_cfg_set, NULL, NULL, midware_table_h248_rtp_cfg_init, NULL},
  {MIDWARE_TABLE_H248_RTP_INFO   , midware_table_h248_rtp_info_get, NULL, NULL, NULL, midware_table_h248_rtp_info_init, NULL},
  {MIDWARE_TABLE_SIP_CFG         , NULL, midware_table_sip_cfg_set, NULL, NULL, midware_table_sip_cfg_init, NULL},
  {MIDWARE_TABLE_SIP_USER_INFO   , NULL, midware_table_sip_user_info_set, NULL, NULL, midware_table_sip_user_info_init, NULL},
  {MIDWARE_TABLE_FAX_CFG         , NULL, midware_table_fax_cfg_set, NULL, NULL, midware_table_fax_cfg_init, NULL},
  {MIDWARE_TABLE_IAD_STATUS      , midware_table_iad_status_get, NULL, NULL, NULL, midware_table_iad_status_init, NULL},
  {MIDWARE_TABLE_POTS_STATUS     , midware_table_pots_status_get, NULL, NULL, NULL, midware_table_pots_status_init, NULL},
  {MIDWARE_TABLE_IAD_OPERATION   , NULL, midware_table_iad_operation_set, NULL, NULL, midware_table_iad_operation_init, NULL},
  {MIDWARE_TABLE_SIP_DIGITMAP    , NULL, midware_table_sip_digitmap_set, NULL, NULL, midware_table_sip_digitmap_init, NULL},
  {MIDWARE_TABLE_RSTP            , midware_table_rstp_get, midware_table_rstp_set, NULL, NULL, midware_table_rstp_init, NULL},
  {MIDWARE_TABLE_RSTP_PORT       , midware_table_rstp_port_get, midware_table_rstp_port_set, NULL, NULL, midware_table_rstp_port_init, NULL},
  {MIDWARE_TABLE_SW_MAC          , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_VLAN_PORT       , NULL, midware_table_vlan_port_set, NULL, NULL, midware_table_vlan_port_init, NULL},
  {MIDWARE_TABLE_ETH_UNI_PM      , midware_table_ethernet_uni_pm_get, NULL, NULL, NULL, midware_table_ethernet_uni_pm_init, NULL},
  {MIDWARE_TABLE_V_CFG           , midware_table_v_cfg_get, midware_table_v_cfg_set, NULL, NULL, midware_table_v_cfg_init, NULL},
  {MIDWARE_TABLE_V_PORT_CFG      , midware_table_v_port_cfg_get, midware_table_v_port_cfg_set, NULL, NULL, midware_table_v_port_cfg_init, NULL},
  {MIDWARE_TABLE_V_SIP_AGENT     , midware_table_v_sip_agent_get, midware_table_v_sip_agent_set, NULL, NULL, midware_table_v_sip_agent_init, NULL},
  {MIDWARE_TABLE_V_SIP_USER      , midware_table_v_sip_user_get, midware_table_v_sip_user_set, NULL, NULL, midware_table_v_sip_user_init, NULL},
  {MIDWARE_TABLE_V_APP_PROFILE   , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_V_FEATURE_NODE  , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_V_NET_DIAL_PLAN , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_V_MEDIA_PROFILE , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_V_SERV_PROFILE  , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_V_TONE_PATTERN  , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_V_TONE_EVENT    , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_V_RING_PATTERN  , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_V_RING_EVENT    , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_V_RTP_PROFILE   , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_V_LINE_STATUS   , NULL, NULL, NULL, NULL, NULL, NULL},
  {MIDWARE_TABLE_AVC             , NULL, midware_table_avc_set, midware_table_avc_insert, midware_table_avc_remove, NULL, NULL},

};

MIDWARE_TABLE_CALLBACK_INFO *midware_get_table_callback_info(MIDWARE_TABLE_ID_E table_id)
{
    int i = 0;
    int table_num = sizeof(g_midware_table_callback) / sizeof(MIDWARE_TABLE_CALLBACK_INFO);

    for(i = 0; i &lt; table_num; i ++)
    {
        if(table_id == g_midware_table_callback[i].table_id)
        {
            return &amp;g_midware_table_callback[i];
        }
    }

    return 0;
}



///////////////////////////////////////////////
//MIDWARE_TABLE_ONU_INFO
///////////////////////////////////////////////

MIDWARE_CALLBACK_RET midware_make_insert_callback(MIDWARE_TABLE_ID_E table_id, void *entry)
{
    MIDWARE_TABLE_CALLBACK_INFO *callback;

    callback = midware_get_table_callback_info(table_id);
    if(NULL == callback)
    {
        return MDW_CB_RET_SET_HW_FAIL;
    }

    if(NULL == callback-&gt;callback_insert)
    {
        return MDW_CB_RET_SET_HW_NO_NEED;
    }

    //MAKE CALLBACK

    return callback-&gt;callback_insert(0, entry);
}

MIDWARE_CALLBACK_RET midware_make_init_callback(MIDWARE_TABLE_ID_E table_id, void *entry)
{
    MIDWARE_TABLE_CALLBACK_INFO *callback;
    ONU_STATUS  rc;

    callback = midware_get_table_callback_info(table_id);
    if(NULL == callback)
    {
        return MDW_CB_RET_SET_HW_FAIL;
    }

    if(NULL == callback-&gt;table_init_fun)
    {
        return MDW_CB_RET_SET_HW_NO_NEED;
    }

    //MAKE CALLBACK
    rc = callback-&gt;table_init_fun();
    if(ONU_OK == rc)
    {
        return MDW_CB_RET_SET_HW_OK;
    }

    return MDW_CB_RET_SET_HW_FAIL;
}

MIDWARE_CALLBACK_RET midware_make_remove_callback(MIDWARE_TABLE_ID_E table_id, void *entry)
{
    MIDWARE_TABLE_CALLBACK_INFO *callback;

    callback = midware_get_table_callback_info(table_id);

    if(NULL == callback)
    {
        return MDW_CB_RET_SET_HW_FAIL;
    }

    //MAKE CALLBACK
    if(NULL == callback-&gt;callback_remove)
    {
        return MDW_CB_RET_SET_HW_NO_NEED;
    }

    return callback-&gt;callback_remove(0, entry);
}

MIDWARE_CALLBACK_RET midware_make_update_callback(MIDWARE_TABLE_ID_E table_id, UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_CALLBACK_INFO *callback;

    callback = midware_get_table_callback_info(table_id);

    if(NULL == callback)
    {
        return MDW_CB_RET_SET_HW_NO_NEED;
    }

    //MAKE CALLBACK
    if(NULL == callback-&gt;callback_update)
    {
        return MDW_CB_RET_SET_HW_NO_NEED;
    }

    return callback-&gt;callback_update(bitmap, entry);
}


MIDWARE_CALLBACK_RET midware_make_insert_group_callback(MIDWARE_TABLE_ID_E table_id, UINT32 entry_num, void *entry)
{
    MIDWARE_TABLE_CALLBACK_INFO *callback;

    callback = midware_get_table_callback_info(table_id);

    if(NULL == callback)
    {
        return MDW_CB_RET_SET_HW_NO_NEED;
    }

    //MAKE CALLBACK
    if(NULL == callback-&gt;callback_insert_group)
    {
        return MDW_CB_RET_SET_HW_NO_NEED;
    }

    return callback-&gt;callback_insert_group(0, entry);
}

MIDWARE_CALLBACK_RET midware_make_get_callback(MIDWARE_TABLE_ID_E table_id, UINT32 bitmap, void *entry)
{
    MIDWARE_TABLE_CALLBACK_INFO *callback;

    midware_sqlite3_print_entry(table_id, entry);

    callback = midware_get_table_callback_info(table_id);

    if(NULL == callback)
    {
        return MDW_CB_RET_SET_HW_FAIL;
    }
    if(NULL == callback-&gt;callback_get)
    {
        return MDW_CB_RET_SET_HW_NO_NEED;
    }

    //MAKE CALLBACK

    return callback-&gt;callback_get(bitmap, entry);
}


</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2013/06/10" Time="18:55:36000">
<Copy StartSeek="0" EndSeek="4106"/>
<Insert>    MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"oam_avc_generate avc type 0x%x param1 0x%x param2 0x%x value %d\r\n", avc_type, param1, param2, avc_val);
</Insert>
<Copy StartSeek="4253" EndSeek="5845"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't malloc mem for size: %ld\n", entry_num * entry_size);
</Insert>
<Copy StartSeek="5950" EndSeek="6061"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't malloc mem for size: %ld\n", entry_num * sizeof(UINT32));
</Insert>
<Copy StartSeek="6170" EndSeek="6692"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't get all entries for table: %d\n", table_id);
</Insert>
<Copy StartSeek="6788" EndSeek="7020"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't update all entries for table: %d\n", table_id);
</Insert>
<Copy StartSeek="7119" EndSeek="9987"/>
<Insert>         MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entry\n");
</Insert>
<Copy StartSeek="10057" EndSeek="11412"/>
<Insert>         MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entry\n");
</Insert>
<Copy StartSeek="11482" EndSeek="12123"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get MAC aging time\r\n");
</Insert>
<Copy StartSeek="12208" EndSeek="12925"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set MAC aging time\r\n");
</Insert>
<Copy StartSeek="13010" EndSeek="13317"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set Switch MTU size\r\n");
</Insert>
<Copy StartSeek="13403" EndSeek="13577"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set GMAC0 MTU size\r\n");
</Insert>
<Copy StartSeek="13662" EndSeek="13835"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set PON MAC MTU size\r\n");
</Insert>
<Copy StartSeek="13922" EndSeek="22078"/>
<Insert>         MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entry\n");
</Insert>
<Copy StartSeek="22148" EndSeek="22752"/>
<Insert>     MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entry\n");
</Insert>
<Copy StartSeek="22818" EndSeek="23407"/>
<Insert>     MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entry\n");
</Insert>
<Copy StartSeek="23473" EndSeek="24153"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to midware_mv_ext_get_if_mac\r\n");
</Insert>
<Copy StartSeek="24245" EndSeek="24509"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to midware_mv_ext_get_if_addr\r\n");
</Insert>
<Copy StartSeek="24602" EndSeek="24876"/>
<Insert>         MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to midware_mv_ext_get_if_mask\r\n");
</Insert>
<Copy StartSeek="24966" EndSeek="25240"/>
<Insert>         MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to midware_mv_ext_get_if_gateway\r\n");
</Insert>
<Copy StartSeek="25333" EndSeek="26160"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to midware_mv_ext_set_if_addr\r\n");
</Insert>
<Copy StartSeek="26253" EndSeek="26520"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to midware_mv_ext_set_if_mask\r\n");
</Insert>
<Copy StartSeek="26613" EndSeek="27917"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to midware_mv_ext_set_if_gateway\r\n");
</Insert>
<Copy StartSeek="28017" EndSeek="28701"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to restore MIDWARE_TABLE_UNI_CFG\r\n");
</Insert>
<Copy StartSeek="28797" EndSeek="30867"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for port: %ld\n", i);
</Insert>
<Copy StartSeek="30959" EndSeek="32075"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_admin_state, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="32179" EndSeek="32588"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_link_state, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="32691" EndSeek="33239"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_admin_state, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="33343" EndSeek="33659"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_admin_state, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="33763" EndSeek="34056"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_admin_state, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="34160" EndSeek="34462"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_admin_state, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="34566" EndSeek="34975"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_admin_state, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="35079" EndSeek="35503"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_loopback, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="35604" EndSeek="36007"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_loopback, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="36108" EndSeek="36434"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_flooding, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="36535" EndSeek="36920"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get mac_learn, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="37017" EndSeek="37734"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_mirror, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="37833" EndSeek="38554"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_mirror, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="38653" EndSeek="39644"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to Set port_admin_state, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="39748" EndSeek="40042"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to Set MIDWARE_ENTRY_PORT_AUTONEG_CFG, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="40160" EndSeek="40449"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to Set MIDWARE_ENTRY_PORT_AUTONEG_MODE, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="40568" EndSeek="40886"/>
<Insert>              MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to Set MIDWARE_ENTRY_PORT_RESET_AUTONEG, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="41010" EndSeek="41354"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set port speed, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="41452" EndSeek="41769"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set port duplex mode, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="41873" EndSeek="42771"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set port_loopback, port: %d, mode: %d\r\n", port_id, uni_cfg-&gt;loopback);
</Insert>
<Copy StartSeek="42901" EndSeek="43188"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set port_isolate, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="43288" EndSeek="43600"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_flooding, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="43701" EndSeek="43977"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get mac_learn, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="44074" EndSeek="44341"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set port_tagged, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="44440" EndSeek="44713"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set port_untagged, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="44814" EndSeek="45076"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set vid_filter, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="45174" EndSeek="45781"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set port_mirror, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="45880" EndSeek="46500"/>
<Insert>           MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_mirror, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="46600" EndSeek="46892"/>
<Insert>           MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set port STP state, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="46995" EndSeek="47523"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to restore MIDWARE_TABLE_UNI_QOS\r\n");
</Insert>
<Copy StartSeek="47619" EndSeek="48746"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for port: %ld\n", i);
</Insert>
<Copy StartSeek="48838" EndSeek="49575"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_flow_control_support, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="49688" EndSeek="50012"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get port_flow_control_state, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="50123" EndSeek="50829"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get uni_ingr_police_rate, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="50937" EndSeek="51418"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to get uni_egr_rate_limit, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="51524" EndSeek="52453"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set port_flow_control_support, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="52566" EndSeek="53197"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set uni_ingr_police_rate, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="53305" EndSeek="53785"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set uni_egr_rate_limit, port: %d\r\n", port_id);
</Insert>
<Copy StartSeek="53891" EndSeek="55183"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to Set tpm_sw_set_port_vid_egress_mode, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
</Insert>
<Copy StartSeek="55342" EndSeek="55985"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to Set tpm_sw_set_port_vid_egress_mode, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
</Insert>
<Copy StartSeek="56144" EndSeek="56599"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to Set tpm_sw_port_del_vid, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
</Insert>
<Copy StartSeek="56746" EndSeek="57155"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to Set tpm_sw_port_add_vid, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
</Insert>
<Copy StartSeek="57302" EndSeek="57534"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to Set tpm_sw_set_port_vid_egress_mode, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
</Insert>
<Copy StartSeek="57693" EndSeek="58133"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to Set tpm_sw_port_del_vid, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
</Insert>
<Copy StartSeek="58280" EndSeek="58693"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to Set tpm_sw_port_add_vid, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
</Insert>
<Copy StartSeek="58840" EndSeek="59074"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to Set tpm_sw_set_port_vid_egress_mode, vlan: %ld, port: %d\r\n", vlan_current-&gt;vlan_id, port_id);
</Insert>
<Copy StartSeek="59233" EndSeek="59812"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set midware_table_vlan_cmp_set_hw, vlan: %ld\r\n", vlan_new-&gt;vlan_id);
</Insert>
<Copy StartSeek="59938" EndSeek="60556"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't get entry for vlan: %ld\n", vlan_new-&gt;vlan_id);
</Insert>
<Copy StartSeek="60655" EndSeek="60825"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set midware_table_vlan_cmp_set_hw, vlan: %ld\r\n", vlan_new-&gt;vlan_id);
</Insert>
<Copy StartSeek="60951" EndSeek="61572"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't get entry for vlan: %ld\n", vlan_new-&gt;vlan_id);
</Insert>
<Copy StartSeek="61671" EndSeek="61912"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set midware_table_vlan_cmp_set_hw, vlan: %ld\r\n", vlan_new-&gt;vlan_id);
</Insert>
<Copy StartSeek="62038" EndSeek="62807"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for llid: %ld, queue_id: %ld\n", i, queue_id);
</Insert>
<Copy StartSeek="62928" EndSeek="63724"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set tpm_tm_set_wan_egr_queue_sched, queue_id: %d\r\n", qos_cfg-&gt;queue_id);
</Insert>
<Copy StartSeek="63856" EndSeek="64293"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to set tpm_tm_set_wan_queue_egr_rate_lim\r\n");
</Insert>
<Copy StartSeek="64395" EndSeek="77002"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"%s: \"%s\" FAILED.\n", __FUNCTION__, line);
</Insert>
<Copy StartSeek="77095" EndSeek="77657"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"%s: \"%s\" FAILED.\n", __FUNCTION__, line);
</Insert>
<Copy StartSeek="77750" EndSeek="78521"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entry\n");
</Insert>
<Copy StartSeek="78590" EndSeek="79348"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entry\n");
</Insert>
<Copy StartSeek="79417" EndSeek="79659"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"%s: \"%s\" FAILED.\n", __FUNCTION__, line);
</Insert>
<Copy StartSeek="79752" EndSeek="79902"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"%s: \"%s\" FAILED.\n", __FUNCTION__, line);
</Insert>
<Copy StartSeek="79995" EndSeek="85078"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entriy for MIDWARE_TABLE_OPT_TRANSCEIVER\n");
</Insert>
<Copy StartSeek="85182" EndSeek="85797"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to localI2cApi_getOnuXvrA2dValues\r\n");
</Insert>
<Copy StartSeek="85894" EndSeek="87319"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_EPON_AUTH\n");
</Insert>
<Copy StartSeek="87418" EndSeek="87962"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to restore MIDWARE_TABLE_WEB_ACCOUNT\r\n");
</Insert>
<Copy StartSeek="88062" EndSeek="88487"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_WEB_ACCOUNT\n");
</Insert>
<Copy StartSeek="88588" EndSeek="89357"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entriy for MIDWARE_TABLE_RSTP\n");
</Insert>
<Copy StartSeek="89450" EndSeek="90009"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to RSTP_get_enable\r\n");
</Insert>
<Copy StartSeek="90091" EndSeek="90402"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to RSTP_get_bridge_priority\r\n");
</Insert>
<Copy StartSeek="90493" EndSeek="90881"/>
<Insert>             MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to RSTP_get_time\r\n");
</Insert>
<Copy StartSeek="90962" EndSeek="91576"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to RSTP_set_enable\r\n");
</Insert>
<Copy StartSeek="91658" EndSeek="91905"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to RSTP_set_time\r\n");
</Insert>
<Copy StartSeek="91985" EndSeek="92370"/>
<Insert>             MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to RSTP_set_time\r\n");
</Insert>
<Copy StartSeek="92451" EndSeek="93324"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for port: %ld\n", i);
</Insert>
<Copy StartSeek="93416" EndSeek="94030"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to RSTP_port_get_enable\r\n");
</Insert>
<Copy StartSeek="94117" EndSeek="94432"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to RSTP_get_bridge_priority\r\n");
</Insert>
<Copy StartSeek="94523" EndSeek="95929"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_set_multicast_tag_strip\r\n");
</Insert>
<Copy StartSeek="96024" EndSeek="96228"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't malloc mem for MIDWARE_TABLE_MC_DS_VLAN_TRANS_T entry for num: %ld\n", mc_vlan_num);
</Insert>
<Copy StartSeek="96364" EndSeek="96552"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't get all_entry for MIDWARE_TABLE_MC_DS_VLAN_TRANS for port: %ld\n", mc_port-&gt;port_id);
</Insert>
<Copy StartSeek="96689" EndSeek="97362"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_set_multicast_tag_strip\r\n");
</Insert>
<Copy StartSeek="97453" EndSeek="98491"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't get MIDWARE_TABLE_MC_PORT_CFG entry for port: %ld\n", port_id);
</Insert>
<Copy StartSeek="98606" EndSeek="99343"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_set_multicast_tag_strip\r\n");
</Insert>
<Copy StartSeek="99438" EndSeek="99642"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't malloc mem for MIDWARE_TABLE_MC_DS_VLAN_TRANS_T entry for num: %ld\n", mc_vlan_num);
</Insert>
<Copy StartSeek="99778" EndSeek="99966"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't get all_entry for MIDWARE_TABLE_MC_DS_VLAN_TRANS for port: %ld\n", port_id);
</Insert>
<Copy StartSeek="100094" EndSeek="101454"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_set_multicast_tag_strip\r\n");
</Insert>
<Copy StartSeek="101545" EndSeek="101742"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't update MIDWARE_ENTRY_MC_DS_TAG_DEF_TCI entry for port: %ld\n", port_id);
</Insert>
<Copy StartSeek="101866" EndSeek="102451"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to RSTP_port_set_enable\r\n");
</Insert>
<Copy StartSeek="102538" EndSeek="102790"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to RSTP_set_bridge_priority\r\n");
</Insert>
<Copy StartSeek="102881" EndSeek="103911"/>
<Insert>         MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entry\n");
</Insert>
<Copy StartSeek="103981" EndSeek="104808"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_get_multicast_switch\r\n");
</Insert>
<Copy StartSeek="104900" EndSeek="105195"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_get_multicast_control\r\n");
</Insert>
<Copy StartSeek="105288" EndSeek="105603"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_get_multicast_switch\r\n");
</Insert>
<Copy StartSeek="105695" EndSeek="107045"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_get_multicast_switch\r\n");
</Insert>
<Copy StartSeek="107137" EndSeek="108019"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_set_multicast_switch\r\n");
</Insert>
<Copy StartSeek="108111" EndSeek="108422"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_set_multicast_switch\r\n");
</Insert>
<Copy StartSeek="108514" EndSeek="108758"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_get_multicast_control\r\n");
</Insert>
<Copy StartSeek="108851" EndSeek="109071"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_get_multicast_control\r\n");
</Insert>
<Copy StartSeek="109164" EndSeek="109515"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_set_fast_leave_admin_control\r\n");
</Insert>
<Copy StartSeek="109615" EndSeek="111152"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_MC_PORT_CFG port: %ld\n", i);
</Insert>
<Copy StartSeek="111270" EndSeek="111878"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_get_multicast_group_num\r\n");
</Insert>
<Copy StartSeek="111973" EndSeek="112234"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_get_multicast_tag_strip\r\n");
</Insert>
<Copy StartSeek="112329" EndSeek="112643"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_get_multicast_tag_strip\r\n");
</Insert>
<Copy StartSeek="112738" EndSeek="113611"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't get MIDWARE_TABLE_MC_PORT_CFG entry for port: %ld\n", p_mc_port_cfg-&gt;port_id);
</Insert>
<Copy StartSeek="113741" EndSeek="113967"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to IGMP_set_multicast_group_num\r\n");
</Insert>
<Copy StartSeek="114062" EndSeek="114943"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to midware_table_mc_vlan_set\r\n");
</Insert>
<Copy StartSeek="115035" EndSeek="116099"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_MC_PORT_STATUS port: %ld\n", i);
</Insert>
<Copy StartSeek="116220" EndSeek="118559"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_MC_PORT_CONTROL port: %ld\n", i);
</Insert>
<Copy StartSeek="118681" EndSeek="119440"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't get MIDWARE_TABLE_MC_PORT_CONTROL entry for port: %ld\n", p_mc_port_acl-&gt;port_id);
</Insert>
<Copy StartSeek="119574" EndSeek="121828"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to call IGMP_set_acl_rule\r\n");
</Insert>
<Copy StartSeek="121913" EndSeek="123058"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_MC_PORT_SERV port: %ld\n", i);
</Insert>
<Copy StartSeek="123177" EndSeek="123940"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't get MIDWARE_TABLE_MC_PORT_SERV entry for port: %ld\n", p_mc_port_serv-&gt;port_id);
</Insert>
<Copy StartSeek="124072" EndSeek="124795"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to call IGMP_set_serv_rule\r\n");
</Insert>
<Copy StartSeek="124881" EndSeek="126128"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_MC_PORT_PREVIEW port: %ld\n", i);
</Insert>
<Copy StartSeek="126250" EndSeek="127058"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't get MIDWARE_TABLE_MC_PORT_PREVIEW entry for port: %ld\n", p_mc_port_preview-&gt;port_id);
</Insert>
<Copy StartSeek="127196" EndSeek="128289"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to call IGMP_set_preview_rule\r\n");
</Insert>
<Copy StartSeek="128378" EndSeek="128861"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to midware_table_mc_ds_vlan_set_to_igmp\r\n");
</Insert>
<Copy StartSeek="128960" EndSeek="129446"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to midware_table_mc_ds_vlan_set_to_igmp\r\n");
</Insert>
<Copy StartSeek="129545" EndSeek="130031"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to midware_table_mc_ds_vlan_set_to_igmp\r\n");
</Insert>
<Copy StartSeek="130130" EndSeek="131267"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_IAD_PORT_ADMIN port: %ld\n", i);
</Insert>
<Copy StartSeek="131388" EndSeek="131853"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_GetPortActiveState_F\r\n");
</Insert>
<Copy StartSeek="131941" EndSeek="132763"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_SetPortActiveState_F\r\n");
</Insert>
<Copy StartSeek="132851" EndSeek="133484"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_IAD_INFO \n");
</Insert>
<Copy StartSeek="133583" EndSeek="134002"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_GetIadInfo_F\r\n");
</Insert>
<Copy StartSeek="134082" EndSeek="135173"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_IAD_CFG  \n");
</Insert>
<Copy StartSeek="135272" EndSeek="135776"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_GetIadInfo_F\r\n");
</Insert>
<Copy StartSeek="135856" EndSeek="137687"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_SetGlobalParam_F\r\n");
</Insert>
<Copy StartSeek="137771" EndSeek="138646"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_H248_CFG  \n");
</Insert>
<Copy StartSeek="138746" EndSeek="139186"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_GetH248ParamConfig_F\r\n");
</Insert>
<Copy StartSeek="139274" EndSeek="141204"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_SetH248ParamConfig_F\r\n");
</Insert>
<Copy StartSeek="141292" EndSeek="142060"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_H248_USER_INFO  \n");
</Insert>
<Copy StartSeek="142170" EndSeek="142696"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_GetH248ParamConfig_F\r\n");
</Insert>
<Copy StartSeek="142784" EndSeek="143576"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_GetH248ParamConfig_F\r\n");
</Insert>
<Copy StartSeek="143664" EndSeek="144319"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_H248_RTP_CFG  \n");
</Insert>
<Copy StartSeek="144423" EndSeek="144890"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_GetH248RtpTIDConfig_F\r\n");
</Insert>
<Copy StartSeek="144979" EndSeek="146438"/>
<Insert>         MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_SetH248RtpTIDConfig_F\r\n");
</Insert>
<Copy StartSeek="146528" EndSeek="147041"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_H248_RTP_INFO  \n");
</Insert>
<Copy StartSeek="147146" EndSeek="147638"/>
<Insert>         MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_SetH248RtpTIDConfig_F\r\n");
</Insert>
<Copy StartSeek="147728" EndSeek="148860"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_SIP_CFG  \n");
</Insert>
<Copy StartSeek="148959" EndSeek="149390"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_GetSipParamConfig_F\r\n");
</Insert>
<Copy StartSeek="149477" EndSeek="152349"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_setSipParamConfig_F\r\n");
</Insert>
<Copy StartSeek="152436" EndSeek="153191"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_SIP_USER_INFO  \n");
</Insert>
<Copy StartSeek="153300" EndSeek="153794"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_GetSipUserParamConfig_F\r\n");
</Insert>
<Copy StartSeek="153885" EndSeek="155007"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_SetSipUserParamConfig_F\r\n");
</Insert>
<Copy StartSeek="155098" EndSeek="155630"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_SIP_USER_INFO  \n");
</Insert>
<Copy StartSeek="155735" EndSeek="156295"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_SetSipDigitmap_F\r\n");
</Insert>
<Copy StartSeek="156379" EndSeek="157080"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_FAX_CFG  \n");
</Insert>
<Copy StartSeek="157179" EndSeek="157598"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_GetFaxModemConfig_F\r\n");
</Insert>
<Copy StartSeek="157685" EndSeek="158363"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_SetFaxModemConfig_F\r\n");
</Insert>
<Copy StartSeek="158450" EndSeek="158924"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_IAD_STATUS  \n");
</Insert>
<Copy StartSeek="159026" EndSeek="159438"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_GetH248IadOperStatus_F\r\n");
</Insert>
<Copy StartSeek="159528" EndSeek="160296"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_POTS_STATUS  \n");
</Insert>
<Copy StartSeek="160403" EndSeek="160917"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_GetPotsStatus_F\r\n");
</Insert>
<Copy StartSeek="161000" EndSeek="161718"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_IAD_OPERATION  \n");
</Insert>
<Copy StartSeek="161823" EndSeek="162338"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to VOIP_SetIadOperation_F\r\n");
</Insert>
<Copy StartSeek="162423" EndSeek="163411"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to localI2cApi_getOnuXvrThresholds \r\n");
</Insert>
<Copy StartSeek="163510" EndSeek="163784"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
</Insert>
<Copy StartSeek="163885" EndSeek="167474"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
</Insert>
<Copy StartSeek="167575" EndSeek="167843"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
</Insert>
<Copy StartSeek="167940" EndSeek="168245"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
</Insert>
<Copy StartSeek="168346" EndSeek="168638"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
</Insert>
<Copy StartSeek="168739" EndSeek="169012"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
</Insert>
<Copy StartSeek="169113" EndSeek="169508"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
</Insert>
<Copy StartSeek="169613" EndSeek="169996"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_ALARM  \n");
</Insert>
<Copy StartSeek="170101" EndSeek="170958"/>
<Insert>                    MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to localI2cApi_getOnuXvrThresholds for alarm_id %d port %d\r\n",midware_alarm-&gt;alarm_id,midware_alarm-&gt;port_id);
</Insert>
<Copy StartSeek="171135" EndSeek="175401"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apmSetAlarmAdminState for alarm id 0x%x\r\n",midware_alarm-&gt;alarm_id);
</Insert>
<Copy StartSeek="175531" EndSeek="175881"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to localI2cApi_getOnuXvrThresholds for alarm_id %d port %d\r\n",midware_alarm-&gt;alarm_id,midware_alarm-&gt;port_id);
</Insert>
<Copy StartSeek="176054" EndSeek="179678"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to localI2cApi_setOnuXvrThresholds for alarm_id %d port %d\r\n",midware_alarm-&gt;alarm_id,midware_alarm-&gt;port_id);
</Insert>
<Copy StartSeek="179851" EndSeek="180659"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to oam_tl_alarm_generate\r\n");
</Insert>
<Copy StartSeek="180743" EndSeek="181377"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to oam_tl_alarm_generate\r\n");
</Insert>
<Copy StartSeek="181461" EndSeek="182401"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apmSetAlarmAdminState for alarm type 0x%x\r\n",midware_alarm-&gt;type);
</Insert>
<Copy StartSeek="182529" EndSeek="183247"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apmSetAlarmThreshold for alarm id 0x%x\r\n",midware_alarm-&gt;type);
</Insert>
<Copy StartSeek="183372" EndSeek="185339"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apm_alarm_create_entity\r\n");
</Insert>
<Copy StartSeek="185425" EndSeek="185822"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apmDeleteAlarmEntity\r\n");
</Insert>
<Copy StartSeek="185905" EndSeek="192244"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apmGetPmData for pm type 0x%x param1 %d\r\n",
</Insert>
<Copy StartSeek="192349" EndSeek="192879"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apmSetPmAdmin for pm type 0x%x\r\n",midware_pm-&gt;type);
</Insert>
<Copy StartSeek="192993" EndSeek="193675"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apmSetPmAccumulationMode for type id 0x%x\r\n",midware_pm-&gt;type);
</Insert>
<Copy StartSeek="193800" EndSeek="194123"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apmSetPmGlobalClear for pm type 0x%x\r\n",midware_pm-&gt;type);
</Insert>
<Copy StartSeek="194247" EndSeek="195111"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apm_pm_create_entity\r\n");
</Insert>
<Copy StartSeek="195194" EndSeek="195573"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apmDeletePmEntity\r\n");
</Insert>
<Copy StartSeek="195653" EndSeek="197051"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apmSetAVCAdminState for avc type 0x%x\r\n",midware_avc-&gt;type);
</Insert>
<Copy StartSeek="197173" EndSeek="197385"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apmSetAVCAdminState for avc type 0x%x\r\n",midware_avc-&gt;type);
</Insert>
<Copy StartSeek="197507" EndSeek="198611"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apm_avc_create_entity\r\n");
</Insert>
<Copy StartSeek="198695" EndSeek="199080"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to apmDeleteAVCEntity\r\n");
</Insert>
<Copy StartSeek="199161" EndSeek="199676"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to restore MIDWARE_TABLE_VLAN_PORT\r\n");
</Insert>
<Copy StartSeek="199774" EndSeek="200296"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for port: %ld\n", i);
</Insert>
<Copy StartSeek="200388" EndSeek="201722"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for port: %ld\n", i);
</Insert>
<Copy StartSeek="201814" EndSeek="202404"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Failed to tpm_sw_pm_3_read for port_id %d \r\n",midware_ethernet_uni_pm-&gt;port_id);
</Insert>
<Copy StartSeek="202532" EndSeek="205184"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_EPON  \n");
</Insert>
<Copy StartSeek="205280" EndSeek="208116"/>
<Insert>        MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for MIDWARE_TABLE_V_CFG  \n");
</Insert>
<Copy StartSeek="208213" EndSeek="211981"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR, "Failed to call VOIP_updateHostIpAddr_F\r\n");
</Insert>
<Copy StartSeek="212077" EndSeek="212886"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR, "Failed to call VOIP_updateHostVidPbits_F\r\n");
</Insert>
<Copy StartSeek="212984" EndSeek="214592"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for port: %ld\n", i);
</Insert>
<Copy StartSeek="214684" EndSeek="219240"/>
<Insert>                MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for port: %ld %ld \n", i, j);
</Insert>
<Copy StartSeek="219344" EndSeek="220184"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR, "Failed to VOIP_updateSipServerAddr_F\r\n");
</Insert>
<Copy StartSeek="220276" EndSeek="221587"/>
<Insert>            MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR,"Can't insert entries for port: %ld \n", i);
</Insert>
<Copy StartSeek="221680" EndSeek="222811"/>
<Insert>          MDW_DEBUG(MIDWARE_TRACE_LEVEL_ERROR, "Failed to VOIP_updateSipAccountData_F\r\n");
</Insert>
<Copy StartSeek="222904" EndSeek="234157"/>
</Delta>
</DeltaFile>
