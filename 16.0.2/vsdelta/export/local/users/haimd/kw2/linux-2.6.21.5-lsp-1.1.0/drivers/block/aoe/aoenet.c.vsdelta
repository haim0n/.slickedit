<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="1" Comment="" Date="2012/04/19" Time="12:56:14000" NL="\10" Encoding="text">
<Insert>/* Copyright (c) 2006 Coraid, Inc.  See COPYING for GPL terms. */
/*
 * aoenet.c
 * Ethernet portion of AoE driver
 */

#include &lt;linux/hdreg.h&gt;
#include &lt;linux/blkdev.h&gt;
#include &lt;linux/netdevice.h&gt;
#include &lt;linux/moduleparam.h&gt;
#include &lt;asm/unaligned.h&gt;
#include "aoe.h"

#define NECODES 5

static char *aoe_errlist[] =
{
	"no such error",
	"unrecognized command code",
	"bad argument parameter",
	"device unavailable",
	"config string present",
	"unsupported version"
};

static char sym[64];
module_param_string(sym, sym, IFLISTSZ, 0600);
MODULE_PARM_DESC(sym, "sym=\"sym_to_lookup\"\n");

#ifndef MODULE
static int __init sym_setup(char *str)
{
	strncpy(sym, str, IFLISTSZ);
	sym[IFLISTSZ - 1] = '\0';
	return 1;
}

__setup("sym=", sym_setup);
#endif

int
is_aoe_netif(struct net_device *ifp)
{
	register char *p, *q;
	register int len;

	if (sym[0] == '\0')
		return 1;

	p = sym + strspn(sym, WHITESPACE);
	for (; *p; p = q + strspn(q, WHITESPACE)) {
		q = p + strcspn(p, WHITESPACE);
		if (q != p)
			len = q - p;
		else
			len = strlen(p); /* last token in sym */

		if (strlen(ifp-&gt;name) == len &amp;&amp; !strncmp(ifp-&gt;name, p, len))
			return 1;
		if (q == p)
			break;
	}

	return 0;
}

int
set_sym(const char __user *user_str, size_t size)
{
	if (size &gt;= IFLISTSZ)
		return -EINVAL;

	if (copy_from_user(sym, user_str, size)) {
		printk(KERN_INFO "aoe: copy from user failed\n");
		return -EFAULT;
	}
	sym[size] = 0x00;
	return 0;
}

u64
mac_addr(char addr[6])
{
	__be64 n = 0;
	char *p = (char *) &amp;n;

	memcpy(p + 2, addr, 6);	/* (sizeof addr != 6) */

	return __be64_to_cpu(n);
}

void
aoenet_xmit(struct sk_buff *sl)
{
	struct sk_buff *skb;

	while ((skb = sl)) {
		sl = sl-&gt;next;
		skb-&gt;next = skb-&gt;prev = NULL;
		dev_queue_xmit(skb);
	}
}

/* 
 * (1) len doesn't include the header by default.  I want this. 
 */
static int
aoenet_rcv(struct sk_buff *skb, struct net_device *ifp, struct packet_type *pt, struct net_device *orig_dev)
{
	struct aoe_hdr *h;
	u32 n;

	skb = skb_share_check(skb, GFP_ATOMIC);
	if (skb == NULL)
		return 0;
	if (skb_linearize(skb))
		goto exit;
	if (!is_aoe_netif(ifp))
		goto exit;
	skb_push(skb, ETH_HLEN);	/* (1) */

	h = (struct aoe_hdr *) skb-&gt;mac.raw;
	n = be32_to_cpu(get_unaligned(&amp;h-&gt;tag));
	if ((h-&gt;verfl &amp; AOEFL_RSP) == 0 || (n &amp; 1&lt;&lt;31))
		goto exit;

	if (h-&gt;verfl &amp; AOEFL_ERR) {
		n = h-&gt;err;
		if (n &gt; NECODES)
			n = 0;
		if (net_ratelimit())
			printk(KERN_ERR "aoe: error packet from %d.%d; ecode=%d '%s'\n",
			       be16_to_cpu(get_unaligned(&amp;h-&gt;major)), h-&gt;minor,
			       h-&gt;err, aoe_errlist[n]);
		goto exit;
	}

	switch (h-&gt;cmd) {
	case AOECMD_ATA:
		aoecmd_ata_rsp(skb);
		break;
	case AOECMD_CFG:
		aoecmd_cfg_rsp(skb);
		break;
	default:
		printk(KERN_INFO "aoe: unknown cmd %d\n", h-&gt;cmd);
	}
exit:
	dev_kfree_skb(skb);
	return 0;
}

static struct packet_type aoe_pt = {
	.type = __constant_htons(ETH_P_AOE),
	.func = aoenet_rcv,
};

int __init
aoenet_init(void)
{
	dev_add_pack(&amp;aoe_pt);
	return 0;
}

void
aoenet_exit(void)
{
	dev_remove_pack(&amp;aoe_pt);
}

</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2007/04/26" Time="06:08:32000">
<Copy StartSeek="0" EndSeek="477"/>
<Insert>enum {
	IFLISTSZ = 1024,
};
</Insert>
<Copy StartSeek="595" EndSeek="596"/>
<Insert>static char aoe_iflist[IFLISTSZ];
module_param_string(aoe_iflist, aoe_iflist, IFLISTSZ, 0600);
MODULE_PARM_DESC(aoe_iflist, "aoe_iflist=\"dev1 [dev2 ...]\"\n");

</Insert>
<Copy StartSeek="596" EndSeek="611"/>
<Insert>static int __init aoe_iflist_setup(char *str)
</Insert>
<Copy StartSeek="650" EndSeek="652"/>
<Insert>	strncpy(aoe_iflist, str, IFLISTSZ);
	aoe_iflist[IFLISTSZ - 1] = '\0';
</Insert>
<Copy StartSeek="709" EndSeek="723"/>
<Insert>__setup("aoe_iflist=", aoe_iflist_setup);
</Insert>
<Copy StartSeek="751" EndSeek="845"/>
<Insert>	if (aoe_iflist[0] == '\0')
</Insert>
<Copy StartSeek="866" EndSeek="879"/>
<Insert>	p = aoe_iflist + strspn(aoe_iflist, WHITESPACE);
</Insert>
<Copy StartSeek="915" EndSeek="1031"/>
<Insert>			len = strlen(p); /* last token in aoe_iflist */
</Insert>
<Copy StartSeek="1075" EndSeek="1198"/>
<Insert>set_aoe_iflist(const char __user *user_str, size_t size)
</Insert>
<Copy StartSeek="1248" EndSeek="1292"/>
<Insert>	if (copy_from_user(aoe_iflist, user_str, size)) {
</Insert>
<Copy StartSeek="1336" EndSeek="1409"/>
<Insert>	aoe_iflist[size] = 0x00;
</Insert>
<Copy StartSeek="1428" EndSeek="3028"/>
</Delta>
</DeltaFile>
