<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="15" Comment="" Date="2012/04/16" Time="15:21:8000" NL="\10" Encoding="text">
<Insert>/*
 *	Marvell Kernel Learning Agent
 * 
 *      Authors:
 *	Haim Daniel
 *
 *	This program is free software; you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License
 *	as published by the Free Software Foundation; either version
 *	2 of the License, or (at your option) any later version.
 */

#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include "klna_nl.h"
#include "klna_nc.h"

#undef pr_fmt
#define pr_fmt(fmt)	"klna: " fmt

static int __init klna_init(void)
{
	int err = 0;

	pr_info("init\n");
	err = klna_nl_open();
	if (err) {
		printk(KERN_ERR "nl failed\n");
		return err;
	}
	err = klna_nc_init();
	if (err) {
		printk(KERN_ERR "nc failed\n");
		klna_nl_close();
		return err;
	}

	return err;
}

static void __exit klna_exit(void)
{
	pr_info("exit\n");
	klna_nl_close();
	klna_nc_exit();
}

module_init(klna_init)
module_exit(klna_exit)
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Haim Daniel &lt;haimd@marvell.com&gt;");
</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:10:31000">
<Copy StartSeek="0" EndSeek="779"/>
<Copy StartSeek="800" EndSeek="6338"/>
</Delta>
<Delta Version="1" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:11:39000">
<Copy StartSeek="0" EndSeek="6141"/>
<Copy StartSeek="6164" EndSeek="6361"/>
</Delta>
<Delta Version="2" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:12:4000">
<Copy StartSeek="0" EndSeek="6164"/>
<Copy StartSeek="6180" EndSeek="6377"/>
</Delta>
<Delta Version="3" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:12:22000">
<Copy StartSeek="0" EndSeek="6176"/>
<Insert>
	}
</Insert>
<Copy StartSeek="6218" EndSeek="6415"/>
</Delta>
<Delta Version="4" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:12:43000">
<Copy StartSeek="0" EndSeek="6140"/>
<Insert>
</Insert>
<Copy StartSeek="6160" EndSeek="6237"/>
<Insert>	pr_info("init\n");
</Insert>
<Copy StartSeek="6239" EndSeek="6416"/>
</Delta>
<Delta Version="5" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:12:56000">
<Copy StartSeek="0" EndSeek="6140"/>
<Copy StartSeek="6141" EndSeek="6417"/>
</Delta>
<Delta Version="6" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:13:0000">
<Copy StartSeek="0" EndSeek="384"/>
<Insert>#include &lt;linux/netdevice.h&gt;
#include &lt;linux/notifier.h&gt;
#include &lt;net/netevent.h&gt;
#include &lt;net/neighbour.h&gt;
#include &lt;vlan.h&gt;
#include &lt;br_private.h&gt;
#include &lt;linux/if_arp.h&gt;
#include &lt;net/netfilter/nf_conntrack.h&gt;
#include &lt;net/netfilter/nf_conntrack_ecache.h&gt;
#include &lt;net/netfilter/nf_conntrack_l3proto.h&gt;
#include &lt;net/netfilter/nf_conntrack_l4proto.h&gt;
//#include &lt;linux/etherdevice.h&gt;

</Insert>
<Copy StartSeek="384" EndSeek="405"/>
<Copy StartSeek="406" EndSeek="454"/>
<Insert>static char notify[256];
module_param_string(notify, notify, sizeof(notify), 0644);
MODULE_PARM_DESC(notify, "event type: arp, vlan, bridge, nf_ct");

//static struct sock *dpanl = NULL;

static enum NOTIFICATION_HOOK {
	NOTIF_ARP	= 1,
	NOTIF_VLAN 	= 2,
	NOTIF_BRIDGE	= 4,
	NOTIF_ETH	= 8,
	NOTIF_NFCT	= 16,
} notif_mask;

#ifdef CONFIG_NF_CONNTRACK_EVENTS
static void dpa_print_conntrack_tuple(struct nf_conn *ct)
{
	const struct nf_conntrack_l3proto *l3proto;
	const struct nf_conntrack_l4proto *l4proto;

	struct nf_conntrack_tuple *tuple = 
		&amp;ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple;

	l3proto = __nf_ct_l3proto_find(nf_ct_l3num(ct));
	NF_CT_ASSERT(l3proto);
	l4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
	NF_CT_ASSERT(l4proto);

	pr_info("[%s] %pI4:%u -&gt; %pI4:%u\n",
		l4proto-&gt;name,
		&amp;tuple-&gt;src.u3.ip, ntohs(tuple-&gt;src.u.all),
		&amp;tuple-&gt;dst.u3.ip, ntohs(tuple-&gt;dst.u.all));
}

static int klna_nf_ct_event(unsigned int events, struct nf_ct_event *item)
{
	struct nf_conn *ct = item-&gt;ct;

	/* ignore our fake conntrack entry */
	if (ct == &amp;nf_conntrack_untracked)
		return 0;

	if (events &amp; IPCT_DESTROY) {
		pr_info("destroyed ct \n");
		dpa_print_conntrack_tuple(ct);
	} else  if (events &amp; IPCT_NEW) {
		pr_info("new ct\n");
		dpa_print_conntrack_tuple(ct);
	} else if (events &amp; IPCT_RELATED) {
		pr_info("related ct\n");
		dpa_print_conntrack_tuple(ct);
	}

	return 0;
}

static struct nf_ct_event_notifier dpa_ct_notifier = {
	.fcn = klna_nf_ct_event
};
#endif

static int __klna_br_if_event(struct notifier_block *unused, unsigned long event, 
			      void *ptr)
{
	struct net_device *dev = ptr;
	struct net_bridge *br = dev-&gt;br_port-&gt;br;

	switch (event) {

	case NETDEV_REGISTER:
		pr_info("if %s up at br [%s]\n", dev-&gt;name, br-&gt;dev-&gt;name);
		break;

	case NETDEV_UNREGISTER:
		pr_info("if %s down at br [%s]\n", dev-&gt;name, br-&gt;dev-&gt;name);
		break;
	}
	return NOTIFY_DONE;
}

static int __klna_br_dev_event(struct notifier_block *unused, unsigned long event, 
			      void *ptr)
{
	struct net_device *dev = ptr;
	struct net_bridge *br;

	br = netdev_priv(dev);

	switch (event) {

	case NETDEV_REGISTER:
		pr_info("br up [%s]\n", dev-&gt;name);
		break;

	case NETDEV_UNREGISTER:
		pr_info("br unreg [%s]\n", dev-&gt;name);
		break;
	}

	return NOTIFY_DONE;
}

static int 
__klna_eth_dev_event(struct notifier_block *unused, unsigned long event,
			     void *ptr)
{
	struct net_device *dev = ptr;

	switch (event) {
	case NETDEV_REGISTER:
		pr_info("eth dev register %s\n", dev-&gt;name);
		break;
	case NETDEV_UNREGISTER:
		pr_info("eth dev unregister %s\n", dev-&gt;name);
		break;
	case NETDEV_UP:
		pr_info("eth dev %s up\n", dev-&gt;name);
	case NETDEV_DOWN:
		pr_info("eth dev %s down\n", dev-&gt;name);

	}

	return NOTIFY_DONE;
}

static int 
__klna_vlan_dev_event(struct notifier_block *unused, unsigned long event,
			     void *ptr)
{
	struct net_device *dev = ptr;
	struct vlan_dev_info *dev_info = vlan_dev_info(dev);

	switch (event) {
	case NETDEV_REGISTER:
		pr_info("vlan register %s vid %u\n", dev-&gt;name, dev_info-&gt;vlan_id);
		break;
	case NETDEV_UNREGISTER:
		pr_info("vlan unreg %s vid %u\n", dev-&gt;name, dev_info-&gt;vlan_id);
		break;
	case NETDEV_UP:
		pr_info("vlan %s up vid %u\n", dev-&gt;name, dev_info-&gt;vlan_id);
	case NETDEV_DOWN:
		pr_info("vlan %s down vid %u\n", dev-&gt;name, dev_info-&gt;vlan_id);

	}

	return NOTIFY_DONE;
}

/* main dispatcher for netdev events */
static int klna_netdev_event(struct notifier_block *unused, unsigned long event,
			   void *ptr)
{
	struct net_device *dev = ptr;
	
//      pr_info("dpa_netdev_dev %s event %lu, dev_type: %#x\n",dev-&gt;name, event,
//      	dev-&gt;type);

	if ((notif_mask &amp; NOTIF_VLAN) &amp;&amp; is_vlan_dev(dev)) {
		return __klna_vlan_dev_event(unused, event, ptr);
	} 
	if (notif_mask &amp; NOTIF_BRIDGE) {
		if (dev-&gt;priv_flags &amp; IFF_EBRIDGE) {
			return __klna_br_dev_event(unused,event,ptr);
		} else if (dev-&gt;br_port) {
			return __klna_br_if_event(unused,event,ptr);
		}
	}
	if (dev-&gt;type == ARPHRD_ETHER) {
		return __klna_eth_dev_event(unused,event,ptr);
	}

	return NOTIFY_DONE;
}

static struct notifier_block dpa_netdev_notifier __read_mostly = {
	.notifier_call = klna_netdev_event,
};

static void klna_neigh_update(struct neighbour *neigh)
{
	
	struct net_device *nd = neigh-&gt;dev;
	u32 addr = *(u32 *) neigh-&gt;primary_key;
	u8 *ha = neigh-&gt;ha;
	
	if (!ha) {
		pr_err("null ha!\n");
		return;
	}

	pr_info("[arp] %s:  %x:%x:%x:%x:%x:%x	  " NIPQUAD_FMT "\n", 
		(nd ? nd-&gt;name : "NULL dev"),
		ha[0],ha[1],ha[2],ha[3],ha[4],ha[5],
		NIPQUAD(addr));
	/* HAIM FIXME : implement __dpa_arp_find query,
	   since there's not separate notification for arp del/add.
	   consider search overhead ??? */
//      if (!__dpa_arp_find(arp_entry_t arp)
//      	dpa_arp_add(dpa_arp_entry_t *arp);
//      else
//      	dpa_arp_del(dpa_arp_entry_t *arp);
	return;
}

static int klna_neigh_callback(struct notifier_block *self, unsigned long event,
		       void *ctx)
{
	printk(KERN_ERR "(%s:%d) event %lu\n", __func__, __LINE__, event);

	switch (event) {
	case (NETEVENT_NEIGH_UPDATE): {
		klna_neigh_update((struct neighbour *)ctx);
		break;
	}
	default:
		break;
	}
	return 0;
}

static struct notifier_block nb = {
	.notifier_call = klna_neigh_callback
};

</Insert>
<Copy StartSeek="454" EndSeek="781"/>
</Delta>
<Delta Version="7" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:13:39000">
<Copy StartSeek="0" EndSeek="602"/>
<Insert>	

</Insert>
<Copy StartSeek="603" EndSeek="779"/>
</Delta>
<Delta Version="8" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:13:50000">
<Copy StartSeek="0" EndSeek="656"/>
<Insert>
</Insert>
<Copy StartSeek="674" EndSeek="796"/>
</Delta>
<Delta Version="9" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:14:32000">
<Copy StartSeek="0" EndSeek="656"/>
<Copy StartSeek="676" EndSeek="816"/>
</Delta>
<Delta Version="10" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:14:39000">
<Copy StartSeek="0" EndSeek="602"/>
<Copy StartSeek="698" EndSeek="912"/>
</Delta>
<Delta Version="11" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:21:42000">
<Copy StartSeek="0" EndSeek="405"/>
<Insert>
</Insert>
<Copy StartSeek="427" EndSeek="933"/>
</Delta>
<Delta Version="12" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:24:36000">
<Copy StartSeek="0" EndSeek="811"/>
<Insert>}

</Insert>
<Copy StartSeek="831" EndSeek="950"/>
</Delta>
<Delta Version="13" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="13:03:44000">
<Copy StartSeek="0" EndSeek="581"/>
<Insert>		pr_err("nl failed\n");
</Insert>
<Copy StartSeek="614" EndSeek="666"/>
<Insert>		pr_err("nc failed\n");
</Insert>
<Copy StartSeek="699" EndSeek="966"/>
</Delta>
<Delta Version="14" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="15:21:4000">
<Copy StartSeek="0" EndSeek="581"/>
<Insert>		printk(KERN_ERR"nl failed\n");
</Insert>
<Copy StartSeek="615" EndSeek="667"/>
<Insert>		printk(KERN_ERR"nc failed\n");
</Insert>
<Copy StartSeek="701" EndSeek="968"/>
</Delta>
</DeltaFile>
