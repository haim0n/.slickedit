<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="148" Comment="" Date="2012/04/23" Time="16:27:20000" NL="\10" Encoding="text">
<Insert>/*
 *	Marvell Kernel Learning Agent
 * 
 *      Authors:
 *	Haim Daniel
 *
 *	This program is free software; you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License
 *	as published by the Free Software Foundation; either version
 *	2 of the License, or (at your option) any later version.
 */

#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/netdevice.h&gt;
#include &lt;linux/notifier.h&gt;
#include &lt;asm/cacheflush.h&gt;
//#include &lt;linux/spinlock.h&gt;
#include &lt;net/netevent.h&gt;
#include &lt;net/neighbour.h&gt;
#include &lt;net/sock.h&gt;
#include &lt;vlan.h&gt;
#include &lt;br_private.h&gt;
#include &lt;linux/if_arp.h&gt;
#include &lt;net/netfilter/nf_conntrack.h&gt;
#include &lt;net/netfilter/nf_conntrack_ecache.h&gt;
#include &lt;net/netfilter/nf_conntrack_l3proto.h&gt;
#include &lt;net/netfilter/nf_conntrack_l4proto.h&gt;
#include &lt;linux/version.h&gt;

#undef pr_fmt
#define pr_fmt(fmt)	"klna_nc: " fmt

static int no_ct = 0;
module_param(no_ct, int, 0644);
MODULE_PARM_DESC(no_ct, "avoid reporting conntrack events");

DEFINE_SPINLOCK(klna_lock);
struct sock *(*org_sk_alloc)(int family, gfp_t priority,
		      struct proto *prot, int zero_it);
#ifdef CONFIG_NF_CONNTRACK_EVENTS

#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,26)
static inline u_int16_t nf_ct_l3num(const struct nf_conn *ct)
{
	return ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.l3num;
}
static inline u_int8_t nf_ct_protonum(const struct nf_conn *ct)
{
	return ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum;
}
#endif /* KERNEL_VERSION 2.6.26 */

#ifndef NIPQUAD
	#define NIPQUAD(addr) \
	((unsigned char *)&amp;addr)[0], \
	((unsigned char *)&amp;addr)[1], \
	((unsigned char *)&amp;addr)[2], \
	((unsigned char *)&amp;addr)[3]
	#define NIPQUAD_FMT "%u.%u.%u.%u"
#endif

static void klna_print_conntrack_tuple(struct nf_conn *ct)
{
	const struct nf_conntrack_l3proto *l3proto;
	const struct nf_conntrack_l4proto *l4proto;

	struct nf_conntrack_tuple *tuple = 
		&amp;ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple;

	l3proto = __nf_ct_l3proto_find(nf_ct_l3num(ct));
	NF_CT_ASSERT(l3proto);
	l4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
	NF_CT_ASSERT(l4proto);

	pr_info("[%s]" NIPQUAD_FMT ":%u -&gt; " NIPQUAD_FMT ":%u\n",
		l4proto-&gt;name,
		NIPQUAD(tuple-&gt;src.u3.ip), ntohs(tuple-&gt;src.u.all),
		NIPQUAD(tuple-&gt;dst.u3.ip), ntohs(tuple-&gt;dst.u.all));
}

#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,31)
static int klna_nc_ct_event(struct notifier_block *this,
				     unsigned long events, void *item)
{
	struct nf_conn *ct = (struct nf_conn *)item;

	/* ignore fake conntrack entry */
	if (ct == &amp;nf_conntrack_untracked)
		return 0;

	if (events &amp; IPCT_DESTROY) {
		pr_info("destroyed ct \n");
		klna_print_conntrack_tuple(ct);
	} else  if (events &amp; IPCT_NEW) {
		pr_info("new ct\n");
		klna_print_conntrack_tuple(ct);
	} else if (events &amp; IPCT_RELATED) {
		pr_info("related ct\n");
		klna_print_conntrack_tuple(ct);
	}

	return 0;

}
static struct notifier_block klna_ct_notifier = {
	.notifier_call	= klna_nc_ct_event,
};

#else
static int klna_nc_ct_event(unsigned int events, struct nf_ct_event *item)
{
	struct nf_conn *ct = item-&gt;ct;

	/* ignore fake conntrack entry */
	if (ct == &amp;nf_conntrack_untracked)
		return 0;

	if (events &amp; IPCT_DESTROY) {
		pr_info("destroyed ct \n");
		klna_print_conntrack_tuple(ct);
	} else  if (events &amp; IPCT_NEW) {
		pr_info("new ct\n");
		klna_print_conntrack_tuple(ct);
	} else if (events &amp; IPCT_RELATED) {
		pr_info("related ct\n");
		klna_print_conntrack_tuple(ct);
	}

	return 0;
}

static struct nf_ct_event_notifier klna_ct_notifier = {
	.fcn = klna_nc_ct_event
};
#endif /* KERNEL_VERSION 2.6.31 */

#endif /* CONFIG_NF_CONNTRACK_EVENTS */

static int klna_nc_br_if_event(struct notifier_block *unused, unsigned long event, 
			      void *ptr)
{
	struct net_device *dev = ptr;
	struct net_bridge *br = dev-&gt;br_port-&gt;br;

	switch (event) {

	case NETDEV_REGISTER:
		pr_info("if %s up at br [%s]\n", dev-&gt;name, br-&gt;dev-&gt;name);
		break;

	case NETDEV_UNREGISTER:
		pr_info("if %s down at br [%s]\n", dev-&gt;name, br-&gt;dev-&gt;name);
		break;
	}
	return NOTIFY_DONE;
}

static int klna_nc_br_dev_event(struct notifier_block *unused, unsigned long event, 
			      void *ptr)
{
	struct net_device *dev = ptr;
	struct net_bridge *br;

	br = netdev_priv(dev);

	switch (event) {

	case NETDEV_REGISTER:
		pr_info("br up [%s]\n", dev-&gt;name);
		break;

	case NETDEV_UNREGISTER:
		pr_info("br unreg [%s]\n", dev-&gt;name);
		break;
	}

	return NOTIFY_DONE;
}

static int 
klna_nc_eth_dev_event(struct notifier_block *unused, unsigned long event,
			     void *ptr)
{
	struct net_device *dev = ptr;

	printk(KERN_ERR "(%s:%d) eth dev %s event %lu\n", __func__, __LINE__,
	       dev-&gt;name, event);
	switch (event) {
	case NETDEV_REGISTER:
		pr_info("eth dev register %s\n", dev-&gt;name);
		break;
	case NETDEV_UNREGISTER:
		pr_info("eth dev unregister %s\n", dev-&gt;name);
		break;
	case NETDEV_UP:
		pr_info("eth dev %s up\n", dev-&gt;name);
	case NETDEV_DOWN:
		pr_info("eth dev %s down\n", dev-&gt;name);
	case NETDEV_CHANGE:
		pr_info("eth dev %s change\n",dev-&gt;name);

	}

	return NOTIFY_DONE;
}

//#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,26)
//static void klna_nc_pppox_get_sk(struct net_device *dev)
//{
//        int hash;
//
//        read_lock_bh(&amp;pppoe_hash_lock);
//        for (hash = 0; hash &lt; PPPOE_HASH_SIZE; hash++) {
//                struct pppox_sock *po = item_hash_table[hash];
//
//                while (po != NULL) {
//                        if (po-&gt;pppoe_dev == dev) {
//                                struct sock *sk = sk_pppox(po);
//
//                                sock_hold(sk);
//                                read_unlock_bh(&amp;pppoe_hash_lock);
//                                lock_sock(sk);
//
//                                if (sk-&gt;sk_state &amp;
//                                    (PPPOX_CONNECTED | PPPOX_BOUND)) {
//                                        pr_info("connected ch %d", ppp_channel_index(po-&gt;chan);
//                                }
//
//                                release_sock(sk);
//
//                                sock_put(sk);
//
//                                read_lock_bh(&amp;pppoe_hash_lock);
//
//                                /* Now restart from the beginning of this
//                                 * hash chain.  We always NULL out pppoe_dev
//                                 * so we are guaranteed to make forward
//                                 * progress.
//                                 */
//                                po = item_hash_table[hash];
//                                continue;
//                        }
//                        po = po-&gt;next;
//                }
//        }
//        read_unlock_bh(&amp;pppoe_hash_lock);
//}
//#else
//static void klna_nc_pppox_get_sk(struct net_device *dev)
//{
//        struct pppoe_net *pn;
//        int i;
//
//        pn = net_generic(dev_net(dev), pppoe_net_id);
//        if (!pn)
//                return;
//
//        write_lock_bh(&amp;pn-&gt;hash_lock);
//        for (i = 0; i &lt; PPPOE_HASH_SIZE; i++) {
//                struct pppox_sock *po = pn-&gt;hash_table[i];
//                struct sock *sk;
//
//                while (po) {
//                        while (po &amp;&amp; po-&gt;pppoe_dev != dev) {
//                                po = po-&gt;next;
//                        }
//
//                        if (!po)
//                                break;
//
//                        sk = sk_pppox(po);
//                        sock_hold(sk);
//                        lock_sock(sk);
//
//                        if (po-&gt;pppoe_dev == dev) {
//                                /* HAIM: matche, get the info !!! */
//                        }
//
//                        release_sock(sk);
//                        sock_put(sk);
//                }
//        }
//        write_unlock_bh(&amp;pn-&gt;hash_lock);
//
//}
//#endif /* KERNEL_VERSION 2.6.26 */
static int 
klna_nc_pppox_dev_event(struct notifier_block *unused, unsigned long event,
			     void *ptr)
{
	struct net_device *dev = ptr;

	printk(KERN_ERR "(%s:%d) pppox dev %s event %lu\n", __func__, __LINE__,
	       dev-&gt;name, event);
	switch (event) {
	case NETDEV_REGISTER:
		pr_info("dev register %s\n", dev-&gt;name);
		break;
	case NETDEV_UNREGISTER:
		pr_info("dev unregister %s\n", dev-&gt;name);
		break;
	case NETDEV_UP:
		pr_info("dev %s up\n", dev-&gt;name);
		break;
	case NETDEV_DOWN:
		pr_info("dev %s down\n", dev-&gt;name);
		break;
	}

	return NOTIFY_DONE;
}

static int 
klna_nc_vlan_dev_event(struct notifier_block *unused, unsigned long event,
			     void *ptr)
{
	struct net_device *dev = ptr;
	struct vlan_dev_info *dev_info = (struct vlan_dev_info *)netdev_priv(dev);

	switch (event) {
	case NETDEV_REGISTER:
		pr_info("vlan register %s vid %u\n", dev-&gt;name, dev_info-&gt;vlan_id);
		break;
	case NETDEV_UNREGISTER:
		pr_info("vlan unreg %s vid %u\n", dev-&gt;name, dev_info-&gt;vlan_id);
		break;
	case NETDEV_UP:
		pr_info("vlan %s up vid %u\n", dev-&gt;name, dev_info-&gt;vlan_id);
		break;
	case NETDEV_DOWN:
		pr_info("vlan %s down vid %u\n", dev-&gt;name, dev_info-&gt;vlan_id);
		break;
	}

	return NOTIFY_DONE;
}

/* main dispatcher for netdev events */
static int klna_nc_netdev_event(struct notifier_block *unused, unsigned long event,
			   void *ptr)
{
	struct net_device *dev = ptr;
	
//      pr_info("dpa_netdev_dev %s event %lu, dev_type: %#x, flags #%x\n",dev-&gt;name, event,
//      	dev-&gt;type, dev-&gt;priv_flags);

	if (dev-&gt;priv_flags &amp; IFF_802_1Q_VLAN) {
		return klna_nc_vlan_dev_event(unused, event, ptr);
	} 
	if (dev-&gt;priv_flags &amp; IFF_EBRIDGE) {
		return klna_nc_br_dev_event(unused,event,ptr);
	} else if (dev-&gt;br_port) {
		return klna_nc_br_if_event(unused,event,ptr);
	}
	if (dev-&gt;type == ARPHRD_ETHER) {
		return klna_nc_eth_dev_event(unused,event,ptr);
	}
	if (dev-&gt;type == ARPHRD_PPP) {
		return klna_nc_pppox_dev_event(unused,event,ptr);
	}

	return NOTIFY_DONE;
}

struct sock *klna_sk_alloc(int family, gfp_t priority,
		      struct proto *prot, int zero_it)
{
	struct sock *sk;
	if (family == PF_PPPOX) {
		printk(KERN_ERR "(%s:%d) request for pppox sock \n", __func__, __LINE__);
	}
	sk = org_sk_alloc(family, priority, prot,zero_it);
	return sk;
}

static void klna_restore_sk_alloc(void)
{
	spin_lock_irq(&amp;klna_lock);
	if (org_sk_alloc) {
		sk_alloc = org_sk_alloc;
	}
//      flush_icache_range((unsigned long)&amp;sk_alloc,
//      		   (unsigned long)&amp;sk_alloc + sizeof(*org_sk_alloc));
	spin_unlock_irq(&amp;klna_lock);
}

static int klna_steal_sk_alloc(void)
{
	spin_lock_irq(&amp;klna_lock);
	org_sk_alloc = &amp;sk_alloc;
	printk(KERN_ERR "(%s:%d) org_sk_alloc %p\n", __func__, __LINE__, org_sk_alloc);
	sk_alloc = klna_sk_alloc;
	spin_unlock_irq(&amp;klna_lock);
	return org_sk_alloc ? 0 : -ENOENT;
}

static struct notifier_block klna_netdev_notifier __read_mostly = {
	.notifier_call = klna_nc_netdev_event,
};

int klna_nc_init(void)
{
	int err = 0;

	pr_info("init\n");
	err = klna_steal_sk_alloc();
	if (err) {
		printk(KERN_ERR "couldn't register pppox monitor\n");
		return err;
	}
	err = register_netdevice_notifier(&amp;klna_netdev_notifier);
	if (err) {
		unregister_netdevice_notifier(&amp;klna_netdev_notifier);
	}
#ifdef CONFIG_NF_CONNTRACK_EVENTS
	if (!no_ct) {
		pr_info("reg nf_conntrack\n");
		err = nf_conntrack_register_notifier(&amp;klna_ct_notifier);
		if (err) {
			nf_conntrack_unregister_notifier(&amp;klna_ct_notifier);
		}
	}
#else
	#warning "CONFIG_NF_CONNTRACK_EVENTS undefined!"
#endif
	return err;
}

void klna_nc_exit(void)
{
	pr_info("exit\n");
	unregister_netdevice_notifier(&amp;klna_netdev_notifier);
#ifdef CONFIG_NF_CONNTRACK_EVENTS
	if (!no_ct) {
		pr_info("unreg nf_ct\n");
		nf_conntrack_unregister_notifier(&amp;klna_ct_notifier);
	}
#endif
}
</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:09:28000">
<Copy StartSeek="0" EndSeek="793"/>
<Insert>#define pr_fmt(fmt)	"klna: " fmt
</Insert>
<Copy StartSeek="829" EndSeek="8126"/>
</Delta>
<Delta Version="1" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:16:34000">
<Copy StartSeek="0" EndSeek="1739"/>
<Insert>static int dpa_klna_nf_ct_event(unsigned int events, struct nf_ct_event *item)
</Insert>
<Copy StartSeek="1817" EndSeek="2293"/>
<Insert>	.fcn = dpa_klna_nf_ct_event
</Insert>
<Copy StartSeek="2321" EndSeek="2332"/>
<Insert>static int __dpa_klna_br_if_event(struct notifier_block *unused, unsigned long event, 
</Insert>
<Copy StartSeek="2418" EndSeek="2754"/>
<Insert>static int __dpa_klna_br_dev_event(struct notifier_block *unused, unsigned long event, 
</Insert>
<Copy StartSeek="2841" EndSeek="3149"/>
<Insert>__dpa_klna_eth_dev_event(struct notifier_block *unused, unsigned long event,
</Insert>
<Copy StartSeek="3225" EndSeek="3619"/>
<Insert>__dpa_klna_vlan_dev_event(struct notifier_block *unused, unsigned long event,
</Insert>
<Copy StartSeek="3696" EndSeek="4259"/>
<Insert>static int dpa_klna_netdev_event(struct notifier_block *unused, unsigned long event,
</Insert>
<Copy StartSeek="4343" EndSeek="4552"/>
<Insert>		return __dpa_klna_vlan_dev_event(unused, event, ptr);
</Insert>
<Copy StartSeek="4607" EndSeek="4684"/>
<Insert>			return __dpa_klna_br_dev_event(unused,event,ptr);
</Insert>
<Copy StartSeek="4736" EndSeek="4765"/>
<Insert>			return __dpa_klna_br_if_event(unused,event,ptr);
</Insert>
<Copy StartSeek="4816" EndSeek="4857"/>
<Insert>		return __dpa_klna_eth_dev_event(unused,event,ptr);
</Insert>
<Copy StartSeek="4909" EndSeek="5004"/>
<Insert>	.notifier_call = dpa_klna_netdev_event,
</Insert>
<Copy StartSeek="5044" EndSeek="5048"/>
<Insert>static void dpa_klna_neigh_update(struct neighbour *neigh)
</Insert>
<Copy StartSeek="5106" EndSeek="5716"/>
<Insert>static int dpa_klna_neigh_callback(struct notifier_block *self, unsigned long event,
</Insert>
<Copy StartSeek="5800" EndSeek="5942"/>
<Insert>		dpa_klna_neigh_update((struct neighbour *)ctx);
</Insert>
<Copy StartSeek="5991" EndSeek="6075"/>
<Insert>	.notifier_call = dpa_klna_neigh_callback
</Insert>
<Copy StartSeek="6116" EndSeek="6204"/>
<Insert> static int __init dpa_klna_init(void)
</Insert>
<Copy StartSeek="6242" EndSeek="7523"/>
<Insert>static void __exit dpa_klna_exit(void)
</Insert>
<Copy StartSeek="7554" EndSeek="7974"/>
<Insert>module_init(dpa_klna_init)
module_exit(dpa_klna_exit)
</Insert>
<Copy StartSeek="8026" EndSeek="8099"/>
</Delta>
<Delta Version="2" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:17:59000">
<Copy StartSeek="0" EndSeek="1186"/>
<Insert>static void dpa_print_conntrack_tuple(struct nf_conn *ct)
</Insert>
<Copy StartSeek="1245" EndSeek="2001"/>
<Insert>		dpa_print_conntrack_tuple(ct);
</Insert>
<Copy StartSeek="2035" EndSeek="2092"/>
<Insert>		dpa_print_conntrack_tuple(ct);
</Insert>
<Copy StartSeek="2126" EndSeek="2190"/>
<Insert>		dpa_print_conntrack_tuple(ct);
</Insert>
<Copy StartSeek="2224" EndSeek="8103"/>
</Delta>
<Delta Version="3" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:18:22000">
<Copy StartSeek="0" EndSeek="1740"/>
<Insert>static int klna_nc_nf_ct_event(unsigned int events, struct nf_ct_event *item)
</Insert>
<Copy StartSeek="1815" EndSeek="2294"/>
<Insert>	.fcn = klna_nc_nf_ct_event
</Insert>
<Copy StartSeek="2319" EndSeek="8097"/>
</Delta>
<Delta Version="4" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:18:53000">
<Copy StartSeek="0" EndSeek="2330"/>
<Insert>static int __klna_nc_br_if_event(struct notifier_block *unused, unsigned long event, 
</Insert>
<Copy StartSeek="2414" EndSeek="2750"/>
<Insert>static int __klna_nc_br_dev_event(struct notifier_block *unused, unsigned long event, 
</Insert>
<Copy StartSeek="2835" EndSeek="3143"/>
<Insert>__klna_nc_eth_dev_event(struct notifier_block *unused, unsigned long event,
</Insert>
<Copy StartSeek="3217" EndSeek="3611"/>
<Insert>__klna_nc_vlan_dev_event(struct notifier_block *unused, unsigned long event,
</Insert>
<Copy StartSeek="3686" EndSeek="4542"/>
<Insert>		return __klna_nc_vlan_dev_event(unused, event, ptr);
</Insert>
<Copy StartSeek="4595" EndSeek="4672"/>
<Insert>			return __klna_nc_br_dev_event(unused,event,ptr);
</Insert>
<Copy StartSeek="4722" EndSeek="4751"/>
<Insert>			return __klna_nc_br_if_event(unused,event,ptr);
</Insert>
<Copy StartSeek="4800" EndSeek="4841"/>
<Insert>		return __klna_nc_eth_dev_event(unused,event,ptr);
</Insert>
<Copy StartSeek="4891" EndSeek="8081"/>
</Delta>
<Delta Version="5" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:19:11000">
<Copy StartSeek="0" EndSeek="7955"/>
<Insert>
module_init(klna_nc_init)
module_exit(klna_nc_exit)
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Haim Daniel &lt;haimd@marvell.com&gt;");
</Insert>
</Delta>
<Delta Version="6" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:19:48000">
<Copy StartSeek="0" EndSeek="6186"/>
<Insert> static int __init klna_nc_init(void)
</Insert>
<Copy StartSeek="6209" EndSeek="7940"/>
</Delta>
<Delta Version="7" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:19:57000">
<Copy StartSeek="0" EndSeek="7490"/>
<Insert>static void klna_nc_exit(void)
</Insert>
<Copy StartSeek="7514" EndSeek="7933"/>
</Delta>
<Delta Version="8" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:20:0000">
<Copy StartSeek="0" EndSeek="7223"/>
<Insert>//      dpanl = netlink_kernel_create(&amp;init_net, NETLINK_NETFILTER, NFNLGRP_MAX,
//      		      nfnetlink_rcv, NULL, THIS_MODULE);
//      if (!dpanl) {
//      	printk(KERN_ERR "cannot initialize dpanetlink!\n");
//      	return -ENOMEM;
//      }

</Insert>
<Copy StartSeek="7223" EndSeek="7682"/>
</Delta>
<Delta Version="9" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:22:25000">
<Copy StartSeek="0" EndSeek="4919"/>
<Insert>static struct notifier_block dpa_netdev_notifier __read_mostly = {
</Insert>
<Copy StartSeek="4987" EndSeek="6760"/>
<Insert>		err = register_netdevice_notifier(&amp;dpa_netdev_notifier);
</Insert>
<Copy StartSeek="6820" EndSeek="6833"/>
<Insert>			unregister_netdevice_notifier(&amp;dpa_netdev_notifier);
</Insert>
<Copy StartSeek="6890" EndSeek="7467"/>
<Insert>		unregister_netdevice_notifier(&amp;dpa_netdev_notifier);
</Insert>
<Copy StartSeek="7523" EndSeek="7686"/>
</Delta>
<Delta Version="10" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:29:22000">
<Copy StartSeek="0" EndSeek="2239"/>
<Insert>static struct nf_ct_event_notifier dpa_ct_notifier = {
</Insert>
<Copy StartSeek="2295" EndSeek="6996"/>
<Insert>		err = nf_conntrack_register_notifier(&amp;dpa_ct_notifier);
</Insert>
<Copy StartSeek="7055" EndSeek="7068"/>
<Insert>			nf_conntrack_unregister_notifier(&amp;dpa_ct_notifier);
</Insert>
<Copy StartSeek="7124" EndSeek="7623"/>
<Insert>		nf_conntrack_unregister_notifier(&amp;dpa_ct_notifier);
</Insert>
<Copy StartSeek="7678" EndSeek="7690"/>
</Delta>
<Delta Version="11" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:29:31000">
<Copy StartSeek="0" EndSeek="7291"/>
<Insert>	if (notif_mask &amp; NOTIF_ARP) {
		pr_info("unreg arp\n");
		unregister_netevent_notifier(&amp;nb);
	}
</Insert>
<Copy StartSeek="7416" EndSeek="7718"/>
</Delta>
<Delta Version="12" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:30:6000">
<Copy StartSeek="0" EndSeek="1050"/>
<Insert>	NOTIF_ARP	= 1,
	NOTIF_VLAN 	= 2,
	NOTIF_BRIDGE	= 4,
	NOTIF_ETH	= 8,
	NOTIF_NFCT	= 16,
</Insert>
<Copy StartSeek="1120" EndSeek="7701"/>
</Delta>
<Delta Version="13" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:30:34000">
<Copy StartSeek="0" EndSeek="5683"/>
<Insert>static int klna_nc_neigh_callback(struct notifier_block *self, unsigned long event,
		       void *ctx)
{
	printk(KERN_ERR "(%s:%d) event %lu\n", __func__, __LINE__, event);

	switch (event) {
	case (NETEVENT_NEIGH_UPDATE): {
		klna_nc_neigh_update((struct neighbour *)ctx);
		break;
	}
	default:
		break;
	}
	return 0;
}

static struct notifier_block nb = {
	.notifier_call = klna_nc_neigh_callback
};


</Insert>
<Copy StartSeek="5684" EndSeek="7297"/>
</Delta>
<Delta Version="14" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:31:4000">
<Copy StartSeek="0" EndSeek="5015"/>
<Insert>static void klna_nc_neigh_update(struct neighbour *neigh)
{
	
	struct net_device *nd = neigh-&gt;dev;
	u32 addr = *(u32 *) neigh-&gt;primary_key;
	u8 *ha = neigh-&gt;ha;
	
	if (!ha) {
		pr_err("null ha!\n");
		return;
	}

	pr_info("[arp] %s:  %x:%x:%x:%x:%x:%x	  " NIPQUAD_FMT "\n", 
		(nd ? nd-&gt;name : "NULL dev"),
		ha[0],ha[1],ha[2],ha[3],ha[4],ha[5],
		NIPQUAD(addr));
	/* HAIM FIXME : implement __dpa_arp_find query,
	   since there's not separate notification for arp del/add.
	   consider search overhead ??? */
//      if (!__dpa_arp_find(arp_entry_t arp)
//      	dpa_arp_add(dpa_arp_entry_t *arp);
//      else
//      	dpa_arp_del(dpa_arp_entry_t *arp);
	return;
}


</Insert>
<Copy StartSeek="5015" EndSeek="6628"/>
</Delta>
<Delta Version="15" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:31:9000">
<Copy StartSeek="0" EndSeek="6201"/>
<Insert>//      if (notif_mask &amp; NOTIF_ARP) {
//      	pr_info("unreg arp\n");
//      	unregister_netevent_notifier(&amp;nb);
//      }
</Insert>
<Copy StartSeek="6201" EndSeek="6503"/>
</Delta>
<Delta Version="16" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:31:15000">
<Copy StartSeek="0" EndSeek="5158"/>
<Insert>	if (strstr(notify,"arp")) {
		pr_info("reg arp\n");
		err = register_netevent_notifier(&amp;nb);
		if (err) {
			unregister_netevent_notifier(&amp;nb);
		} else 
			notif_mask |= NOTIF_ARP;
	}
</Insert>
<Copy StartSeek="5158" EndSeek="6317"/>
</Delta>
<Delta Version="17" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:31:50000">
<Copy StartSeek="0" EndSeek="830"/>
<Insert>static char notify[256];
module_param_string(notify, notify, sizeof(notify), 0644);
MODULE_PARM_DESC(notify, "event type: arp, vlan, bridge, nf_ct");

//static struct sock *dpanl = NULL;

static enum NOTIFICATION_HOOK {
	NOTIF_VLAN 	= 1,
	NOTIF_BRIDGE	= 2,
	NOTIF_ETH	= 4,
	NOTIF_NFCT	= 8,
} notif_mask;

</Insert>
<Copy StartSeek="830" EndSeek="6012"/>
</Delta>
<Delta Version="18" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:52:27000">
<Copy StartSeek="0" EndSeek="4853"/>
<Insert>	if (strstr(notify,"vlan")) {
		pr_info("reg vlan\n");
		notif_mask |= NOTIF_VLAN;
</Insert>
<Copy StartSeek="4980" EndSeek="4983"/>
<Insert>	if (strstr(notify,"bridge")) {
      		pr_info("reg bridge\n");
		notif_mask |= NOTIF_BRIDGE;
	}
	if (strstr(notify,"eth")) {
		pr_info("reg eth\n");
		notif_mask |= NOTIF_ETH;
	}
	if (notif_mask &amp; (NOTIF_VLAN | NOTIF_BRIDGE| NOTIF_ETH)) {
		err = register_netdevice_notifier(&amp;klna_netdev_notifier);
		if (err) {
			unregister_netdevice_notifier(&amp;klna_netdev_notifier);
		}
	}
</Insert>
<Copy StartSeek="4983" EndSeek="5678"/>
</Delta>
<Delta Version="19" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:53:10000">
<Copy StartSeek="0" EndSeek="830"/>
<Copy StartSeek="948" EndSeek="5796"/>
</Delta>
<Delta Version="20" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:55:10000">
<Copy StartSeek="0" EndSeek="5135"/>
<Insert>	if (strstr(notify,"nf_ct")) {
</Insert>
<Copy StartSeek="5150" EndSeek="5311"/>
<Insert>		} else
			notif_mask |= NOTIF_NFCT;
	}
</Insert>
<Copy StartSeek="5318" EndSeek="5746"/>
</Delta>
<Delta Version="21" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:56:10000">
<Copy StartSeek="0" EndSeek="5381"/>
<Insert>
</Insert>
<Copy StartSeek="5381" EndSeek="5745"/>
</Delta>
<Delta Version="22" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:56:27000">
<Copy StartSeek="0" EndSeek="5443"/>
<Insert>	if (notif_mask &amp; (NOTIF_VLAN | NOTIF_BRIDGE)) {
		pr_info("unreg dpa_netdev\n");
		unregister_netdevice_notifier(&amp;klna_netdev_notifier);
	}
</Insert>
<Copy StartSeek="5498" EndSeek="5532"/>
<Insert>	if (notif_mask &amp; NOTIF_NFCT) {
</Insert>
<Copy StartSeek="5547" EndSeek="5642"/>
</Delta>
<Delta Version="23" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:56:43000">
<Copy StartSeek="0" EndSeek="4285"/>
<Insert>	if ((notif_mask &amp; NOTIF_VLAN) &amp;&amp; is_vlan_dev(dev)) {
</Insert>
<Copy StartSeek="4310" EndSeek="4367"/>
<Insert>	if (notif_mask &amp; NOTIF_BRIDGE) {
		if (dev-&gt;priv_flags &amp; IFF_EBRIDGE) {
			return klna_nc_br_dev_event(unused,event,ptr);
		} else if (dev-&gt;br_port) {
			return klna_nc_br_if_event(unused,event,ptr);
		}
	}
</Insert>
<Copy StartSeek="4535" EndSeek="5573"/>
</Delta>
<Delta Version="24" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:57:42000">
<Copy StartSeek="0" EndSeek="4759"/>
<Insert>/* HAIM FIXME: need to unreg the notifiers according to the notif_mask bitfield */
</Insert>
<Copy StartSeek="4759" EndSeek="5490"/>
</Delta>
<Delta Version="25" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="12:57:57000">
<Copy StartSeek="0" EndSeek="745"/>
<Insert>//#include &lt;linux/etherdevice.h&gt;

</Insert>
<Copy StartSeek="746" EndSeek="5457"/>
</Delta>
<Delta Version="26" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="13:59:6000">
<Copy StartSeek="0" EndSeek="3034"/>
<Copy StartSeek="3131" EndSeek="5554"/>
</Delta>
<Delta Version="27" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="14:16:15000">
<Copy StartSeek="0" EndSeek="3034"/>
<Insert>	printk(KERN_ERR "(%s:%d) eth dev %s event %u\n", __func__, __LINE__,
</Insert>
<Copy StartSeek="3105" EndSeek="5555"/>
</Delta>
<Delta Version="28" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="14:16:31000">
<Copy StartSeek="0" EndSeek="797"/>
<Insert>static bool no_ct = 0;
module_param(no_ct, bool, 0644);
</Insert>
<Copy StartSeek="851" EndSeek="5553"/>
</Delta>
<Delta Version="29" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="15:16:45000">
<Copy StartSeek="0" EndSeek="3598"/>
<Insert>	struct vlan_dev_info *dev_info = vlan_dev_info(dev);
</Insert>
<Copy StartSeek="3674" EndSeek="5575"/>
</Delta>
<Delta Version="30" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="15:22:41000">
<Copy StartSeek="0" EndSeek="4370"/>
<Insert>	if (is_vlan_dev(dev)) {
</Insert>
<Copy StartSeek="4412" EndSeek="5592"/>
</Delta>
<Delta Version="31" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="15:23:51000">
<Copy StartSeek="0" EndSeek="4635"/>
<Insert>	
</Insert>
<Copy StartSeek="4635" EndSeek="5590"/>
</Delta>
<Delta Version="32" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="15:25:28000">
<Copy StartSeek="0" EndSeek="947"/>
<Copy StartSeek="1018" EndSeek="5661"/>
</Delta>
<Delta Version="33" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="15:50:47000">
<Copy StartSeek="0" EndSeek="997"/>
<Insert>...
#else
...
</Insert>
<Copy StartSeek="1122" EndSeek="5772"/>
</Delta>
<Delta Version="34" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="15:51:11000">
<Copy StartSeek="0" EndSeek="384"/>
<Copy StartSeek="411" EndSeek="5799"/>
</Delta>
<Delta Version="35" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="15:51:45000">
<Copy StartSeek="0" EndSeek="1149"/>
<Copy StartSeek="1279" EndSeek="5929"/>
</Delta>
<Delta Version="36" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="15:52:6000">
<Copy StartSeek="0" EndSeek="1286"/>
<Copy StartSeek="1287" EndSeek="5930"/>
</Delta>
<Delta Version="37" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="15:55:51000">
<Copy StartSeek="0" EndSeek="384"/>
<Insert>#include &lt;linux/version.h&gt;
</Insert>
<Copy StartSeek="384" EndSeek="947"/>
<Insert>
#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,26)
static inline u_int16_t nf_ct_l3num(const struct nf_conn *ct)
{
	return ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.l3num;
}
static inline u_int8_t nf_ct_protonum(const struct nf_conn *ct)
{
	return ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum;
}
#endif

</Insert>
<Copy StartSeek="947" EndSeek="5590"/>
</Delta>
<Delta Version="38" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:00:18000">
<Copy StartSeek="0" EndSeek="745"/>
<Insert>
</Insert>
<Copy StartSeek="771" EndSeek="5615"/>
</Delta>
<Delta Version="39" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:00:28000">
<Copy StartSeek="0" EndSeek="771"/>
<Copy StartSeek="772" EndSeek="5616"/>
</Delta>
<Delta Version="40" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:00:29000">
<Copy StartSeek="0" EndSeek="1637"/>
<Insert>	/* ignore our fake conntrack entry */
</Insert>
<Copy StartSeek="1672" EndSeek="5612"/>
</Delta>
<Delta Version="41" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:36:46000">
<Copy StartSeek="0" EndSeek="2106"/>
<Copy StartSeek="2107" EndSeek="5613"/>
</Delta>
<Delta Version="42" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:52:48000">
<Copy StartSeek="0" EndSeek="2107"/>
<Copy StartSeek="2203" EndSeek="5709"/>
</Delta>
<Delta Version="43" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:53:15000">
<Copy StartSeek="0" EndSeek="2022"/>
<Insert>static struct nf_ct_event_notifier klna_ct_notifier = {
	.fcn = klna_nc_ct_event
};

</Insert>
<Copy StartSeek="2071" EndSeek="2166"/>
<Insert>
</Insert>
<Copy StartSeek="2285" EndSeek="5791"/>
</Delta>
<Delta Version="44" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:54:14000">
<Copy StartSeek="0" EndSeek="2256"/>
<Insert>#endif /*KERNEL_VERSION  */
</Insert>
<Copy StartSeek="2285" EndSeek="5792"/>
</Delta>
<Delta Version="45" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:54:16000">
<Copy StartSeek="0" EndSeek="2022"/>
<Insert>#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,26)
</Insert>
<Copy StartSeek="2071" EndSeek="5792"/>
</Delta>
<Delta Version="46" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:55:25000">
<Copy StartSeek="0" EndSeek="2256"/>
<Insert>#endif /* KERNEL_VERSION  */
</Insert>
<Copy StartSeek="2291" EndSeek="5798"/>
</Delta>
<Delta Version="47" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:55:29000">
<Copy StartSeek="0" EndSeek="1526"/>
<Insert>
</Insert>
<Copy StartSeek="1628" EndSeek="5899"/>
</Delta>
<Delta Version="48" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:56:34000">
<Copy StartSeek="0" EndSeek="1583"/>
<Insert>				     unsigned long events, void *ptr)
</Insert>
<Copy StartSeek="1626" EndSeek="5900"/>
</Delta>
<Delta Version="49" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:56:55000">
<Copy StartSeek="0" EndSeek="1526"/>
<Copy StartSeek="1576" EndSeek="1679"/>
<Copy StartSeek="1688" EndSeek="2182"/>
<Insert>
</Insert>
<Copy StartSeek="2189" EndSeek="5965"/>
</Delta>
<Delta Version="50" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:59:4000">
<Copy StartSeek="0" EndSeek="2189"/>
<Copy StartSeek="2190" EndSeek="5966"/>
</Delta>
<Delta Version="51" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:59:5000">
<Copy StartSeek="0" EndSeek="1681"/>
<Copy StartSeek="1768" EndSeek="2326"/>
<Insert>static struct notifier_block ctnl_notifier = {
	.notifier_call	= ctnetlink_conntrack_event,
};
</Insert>
<Copy StartSeek="2326" EndSeek="5958"/>
</Delta>
<Delta Version="52" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:59:24000">
<Copy StartSeek="0" EndSeek="1767"/>
<Insert>
</Insert>
<Copy StartSeek="1767" EndSeek="5957"/>
</Delta>
<Delta Version="53" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:59:26000">
<Copy StartSeek="0" EndSeek="1767"/>
<Copy StartSeek="1768" EndSeek="1774"/>
<Insert>
</Insert>
<Copy StartSeek="1774" EndSeek="2268"/>
<Insert>#endif

#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,31)
#else
</Insert>
<Copy StartSeek="2268" EndSeek="2352"/>
<Copy StartSeek="2415" EndSeek="5957"/>
</Delta>
<Delta Version="54" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:59:35000">
<Copy StartSeek="0" EndSeek="2268"/>
<Copy StartSeek="2269" EndSeek="5958"/>
</Delta>
<Delta Version="55" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:59:36000">
<Copy StartSeek="0" EndSeek="2353"/>
<Insert>#endif

#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,31)
#else
</Insert>
<Copy StartSeek="2353" EndSeek="2389"/>
<Insert>#endif
</Insert>
<Copy StartSeek="2429" EndSeek="5928"/>
</Delta>
<Delta Version="56" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="16:59:57000">
<Copy StartSeek="0" EndSeek="1678"/>
<Insert>
}
</Insert>
<Copy StartSeek="2110" EndSeek="6357"/>
</Delta>
<Delta Version="57" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="17:00:37000">
<Copy StartSeek="0" EndSeek="2110"/>
<Insert>static struct notifier_block ctnl_notifier = {
</Insert>
<Copy StartSeek="2160" EndSeek="6360"/>
</Delta>
<Delta Version="58" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="17:01:7000">
<Copy StartSeek="0" EndSeek="973"/>
<Copy StartSeek="1314" EndSeek="6701"/>
</Delta>
<Delta Version="59" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="17:03:28000">
<Copy StartSeek="0" EndSeek="745"/>
<Insert>#include "klna_kcompat.h"

</Insert>
<Copy StartSeek="746" EndSeek="6675"/>
</Delta>
<Delta Version="60" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="17:03:54000">
<Copy StartSeek="0" EndSeek="745"/>
<Insert>
</Insert>
<Copy StartSeek="772" EndSeek="6701"/>
</Delta>
<Delta Version="61" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="17:04:19000">
<Copy StartSeek="0" EndSeek="772"/>
<Copy StartSeek="773" EndSeek="6702"/>
</Delta>
<Delta Version="62" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="17:04:20000">
<Copy StartSeek="0" EndSeek="1315"/>
<Copy StartSeek="1524" EndSeek="6911"/>
</Delta>
<Delta Version="63" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="17:14:54000">
<Copy StartSeek="0" EndSeek="1927"/>
<Insert>	pr_info("[%s] %pI4:%u -&gt; %pI4:%u\n",
</Insert>
<Copy StartSeek="1986" EndSeek="6932"/>
</Delta>
<Delta Version="64" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="17:17:8000">
<Copy StartSeek="0" EndSeek="2003"/>
<Insert>		&amp;tuple-&gt;src.u3.ip, ntohs(tuple-&gt;src.u.all),
		&amp;tuple-&gt;dst.u3.ip, ntohs(tuple-&gt;dst.u.all));
</Insert>
<Copy StartSeek="2112" EndSeek="6948"/>
</Delta>
<Delta Version="65" Comment="" NL="\10" Encoding="text" Date="2012/04/16" Time="17:17:34000">
<Copy StartSeek="0" EndSeek="5625"/>
<Insert>//      pr_info("dpa_netdev_dev %s event %lu, dev_type: %#x\n",dev-&gt;name, event,
//      	dev-&gt;type);
</Insert>
<Copy StartSeek="5713" EndSeek="6934"/>
</Delta>
<Delta Version="66" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="15:29:7000">
<Copy StartSeek="0" EndSeek="5625"/>
<Insert>	pr_info("dpa_netdev_dev %s event %lu, dev_type: %#x\n",dev-&gt;name, event,
		dev-&gt;type);
</Insert>
<Copy StartSeek="5741" EndSeek="6962"/>
</Delta>
<Delta Version="67" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="15:29:37000">
<Copy StartSeek="0" EndSeek="6094"/>
<Insert>
</Insert>
<Copy StartSeek="6132" EndSeek="6999"/>
</Delta>
<Delta Version="68" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="15:50:1000">
<Copy StartSeek="0" EndSeek="4829"/>
<Copy StartSeek="5397" EndSeek="6694"/>
<Insert>	
</Insert>
<Copy StartSeek="6746" EndSeek="7617"/>
</Delta>
<Delta Version="69" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="15:52:32000">
<Copy StartSeek="0" EndSeek="4958"/>
<Insert>	printk(KERN_ERR "(%s:%d) eth dev %s event %lu\n", __func__, __LINE__,
</Insert>
<Copy StartSeek="5031" EndSeek="7619"/>
</Delta>
<Delta Version="70" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="15:52:41000">
<Copy StartSeek="0" EndSeek="6195"/>
<Insert>	pr_info("dpa_netdev_dev %s event %lu, dev_type: %#x, flags #%x\n",dev-&gt;name, event,
		dev-&gt;type, dev-&gt;priv_flags);
</Insert>
<Copy StartSeek="6325" EndSeek="7633"/>
</Delta>
<Delta Version="71" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="15:55:33000">
<Copy StartSeek="0" EndSeek="5099"/>
<Insert>		pr_info("eth dev register %s\n", dev-&gt;name);
</Insert>
<Copy StartSeek="5142" EndSeek="5176"/>
<Insert>		pr_info("eth dev unregister %s\n", dev-&gt;name);
</Insert>
<Copy StartSeek="5221" EndSeek="5247"/>
<Insert>		pr_info("eth dev %s up\n", dev-&gt;name);
</Insert>
<Copy StartSeek="5284" EndSeek="5303"/>
<Insert>		pr_info("eth dev %s down\n", dev-&gt;name);
</Insert>
<Copy StartSeek="5342" EndSeek="7617"/>
</Delta>
<Delta Version="72" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="15:56:38000">
<Copy StartSeek="0" EndSeek="5284"/>
<Copy StartSeek="5293" EndSeek="5351"/>
<Insert>
	}

</Insert>
<Copy StartSeek="5365" EndSeek="7635"/>
</Delta>
<Delta Version="73" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="15:59:1000">
<Copy StartSeek="0" EndSeek="5360"/>
<Insert>
	}

</Insert>
<Copy StartSeek="5364" EndSeek="7634"/>
</Delta>
<Delta Version="74" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="15:59:3000">
<Copy StartSeek="0" EndSeek="5906"/>
<Copy StartSeek="5915" EndSeek="6000"/>
<Insert>
</Insert>
<Copy StartSeek="6009" EndSeek="7651"/>
</Delta>
<Delta Version="75" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="15:59:16000">
<Copy StartSeek="0" EndSeek="4817"/>
<Copy StartSeek="6204" EndSeek="9038"/>
</Delta>
<Delta Version="76" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="16:57:43000">
<Copy StartSeek="0" EndSeek="4942"/>
<Insert>	if (!pn) /* already freed */
</Insert>
<Copy StartSeek="4952" EndSeek="9018"/>
</Delta>
<Delta Version="77" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="16:57:47000">
<Copy StartSeek="0" EndSeek="5227"/>
<Insert>
			/* We always grab the socket lock, followed by the
			 * hash_lock, in that order.  Since we should hold the
			 * sock lock while doing any unbinding, we need to
			 * release the lock we're holding.  Hold a reference to
			 * the sock so it doesn't disappear as we're jumping
			 * between locks.
			 */

</Insert>
<Copy StartSeek="5227" EndSeek="8707"/>
</Delta>
<Delta Version="78" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="16:58:38000">
<Copy StartSeek="0" EndSeek="4817"/>
<Insert>static void klna_nc_pppox_get_sk(struct net_device *dev)
{
</Insert>
<Copy StartSeek="4891" EndSeek="8722"/>
</Delta>
<Delta Version="79" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="16:59:19000">
<Copy StartSeek="0" EndSeek="4817"/>
<Insert>static struct pppox_sock *
klna_nc_pppox_get_sk(struct net_device *dev)
{
</Insert>
<Copy StartSeek="4876" EndSeek="8707"/>
</Delta>
<Delta Version="80" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="16:59:37000">
<Copy StartSeek="0" EndSeek="5300"/>
<Insert>			if (po-&gt;pppoe_dev == dev
			    &amp;&amp; sk-&gt;sk_state &amp; (PPPOX_CONNECTED | PPPOX_BOUND)) {
				pppox_unbind_sock(sk);
				sk-&gt;sk_state = PPPOX_ZOMBIE;
				sk-&gt;sk_state_change(sk);
				po-&gt;pppoe_dev = NULL;
				dev_put(dev);
			}

</Insert>
<Copy StartSeek="5338" EndSeek="8518"/>
</Delta>
<Delta Version="81" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="17:00:7000">
<Copy StartSeek="0" EndSeek="4908"/>
<Insert>	pn = pppoe_pernet(dev_net(dev));
</Insert>
<Copy StartSeek="4955" EndSeek="8531"/>
</Delta>
<Delta Version="82" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="17:59:28000">
<Copy StartSeek="0" EndSeek="562"/>
<Copy StartSeek="591" EndSeek="8560"/>
</Delta>
<Delta Version="83" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="18:00:8000">
<Copy StartSeek="0" EndSeek="562"/>
<Insert>#include &lt;net/ns/ngeneric.h&gt;
</Insert>
<Copy StartSeek="594" EndSeek="8563"/>
</Delta>
<Delta Version="84" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="18:00:29000">
<Copy StartSeek="0" EndSeek="562"/>
<Insert>#include &lt;net/netns/ngeneric.h&gt;
</Insert>
<Copy StartSeek="593" EndSeek="8562"/>
</Delta>
<Delta Version="85" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="18:00:48000">
<Copy StartSeek="0" EndSeek="5375"/>
<Insert>
</Insert>
<Copy StartSeek="5416" EndSeek="8602"/>
</Delta>
<Delta Version="86" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="18:14:53000">
<Copy StartSeek="0" EndSeek="5289"/>
<Insert>			write_unlock_bh(&amp;pn-&gt;hash_lock);
</Insert>
<Copy StartSeek="5289" EndSeek="5424"/>
<Insert>
			/* Restart the process from the start of the current
			 * hash chain. We dropped locks so the world may have
			 * change from underneath us.
			 */

			BUG_ON(pppoe_pernet(dev_net(dev)) == NULL);
			write_lock_bh(&amp;pn-&gt;hash_lock);
			po = pn-&gt;hash_table[i];
		}
	}
</Insert>
<Copy StartSeek="5431" EndSeek="8303"/>
</Delta>
<Delta Version="87" Comment="" NL="\10" Encoding="text" Date="2012/04/18" Time="18:16:47000">
<Copy StartSeek="0" EndSeek="4848"/>
<Copy StartSeek="6012" EndSeek="9467"/>
</Delta>
<Delta Version="88" Comment="" NL="\10" Encoding="text" Date="2012/04/19" Time="11:56:49000">
<Copy StartSeek="0" EndSeek="6632"/>
<Insert>
</Insert>
<Copy StartSeek="6667" EndSeek="9501"/>
</Delta>
<Delta Version="89" Comment="" NL="\10" Encoding="text" Date="2012/04/19" Time="11:57:16000">
<Copy StartSeek="0" EndSeek="4968"/>
<Insert>	BUG_ON(dev == NULL);

</Insert>
<Copy StartSeek="4990" EndSeek="9500"/>
</Delta>
<Delta Version="90" Comment="" NL="\10" Encoding="text" Date="2012/04/19" Time="11:57:43000">
<Copy StartSeek="0" EndSeek="4968"/>
<Insert>	if (!dev)
		return;

</Insert>
<Copy StartSeek="4968" EndSeek="9478"/>
</Delta>
<Delta Version="91" Comment="" NL="\10" Encoding="text" Date="2012/04/19" Time="11:57:56000">
<Copy StartSeek="0" EndSeek="5211"/>
<Insert>				po-&gt;pppoe_dev = NULL;

				/* We hold a reference to SK, now drop the
				 * hash table lock so that we may attempt
				 * to lock the socket (which can sleep).
				 */
</Insert>
<Copy StartSeek="5211" EndSeek="5249"/>
<Insert>
</Insert>
<Copy StartSeek="5249" EndSeek="5335"/>
<Insert>					pppox_unbind_sock(sk);
					dev_put(dev);
					sk-&gt;sk_state = PPPOX_ZOMBIE;
					sk-&gt;sk_state_change(sk);
				}

</Insert>
<Copy StartSeek="5403" EndSeek="9254"/>
</Delta>
<Delta Version="92" Comment="" NL="\10" Encoding="text" Date="2012/04/19" Time="12:08:9000">
<Copy StartSeek="0" EndSeek="4848"/>
<Insert>#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,26)
static void klna_nc_pppox_get_sk(struct net_device *dev)
{
	int hash;

	read_lock_bh(&amp;pppoe_hash_lock);
	for (hash = 0; hash &lt; PPPOE_HASH_SIZE; hash++) {
		struct pppox_sock *po = item_hash_table[hash];

		while (po != NULL) {
			if (po-&gt;pppoe_dev == dev) {
				struct sock *sk = sk_pppox(po);

				sock_hold(sk);
				read_unlock_bh(&amp;pppoe_hash_lock);
				lock_sock(sk);

				if (sk-&gt;sk_state &amp;
				    (PPPOX_CONNECTED | PPPOX_BOUND)) {
					pr_info("connected ch %d", ppp_channel_index(po-&gt;chan);
				}

				release_sock(sk);

				sock_put(sk);

				read_lock_bh(&amp;pppoe_hash_lock);

				/* Now restart from the beginning of this
				 * hash chain.  We always NULL out pppoe_dev
				 * so we are guaranteed to make forward
				 * progress.
				 */
				po = item_hash_table[hash];
				continue;
			}
			po = po-&gt;next;
		}
	}
	read_unlock_bh(&amp;pppoe_hash_lock);
}
#else
static void klna_nc_pppox_get_sk(struct net_device *dev)
{
	struct pppoe_net *pn;
	int i;

	pn = net_generic(dev_net(dev), pppoe_net_id);
	if (!pn)
		return;

	write_lock_bh(&amp;pn-&gt;hash_lock);
	for (i = 0; i &lt; PPPOE_HASH_SIZE; i++) {
		struct pppox_sock *po = pn-&gt;hash_table[i];
		struct sock *sk;

		while (po) {
			while (po &amp;&amp; po-&gt;pppoe_dev != dev) {
				po = po-&gt;next;
			}

			if (!po)
				break;

			sk = sk_pppox(po);
			sock_hold(sk);
			lock_sock(sk);

			if (po-&gt;pppoe_dev == dev) {
				/* HAIM: matche, get the info !!! */
			}

			release_sock(sk);
			sock_put(sk);
		}
	}
	write_unlock_bh(&amp;pn-&gt;hash_lock);

}
#endif /* KERNEL_VERSION 2.6.26 */
</Insert>
<Copy StartSeek="7651" EndSeek="10485"/>
</Delta>
<Delta Version="93" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="09:48:55000">
<Copy StartSeek="0" EndSeek="562"/>
<Insert>#include &lt;net/netns/generic.h&gt;
</Insert>
<Copy StartSeek="562" EndSeek="10454"/>
</Delta>
<Delta Version="94" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="13:44:0000">
<Copy StartSeek="0" EndSeek="4788"/>
<Copy StartSeek="4853" EndSeek="4854"/>
<Insert>	}

</Insert>
<Copy StartSeek="4858" EndSeek="10519"/>
</Delta>
<Delta Version="95" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="13:45:5000">
<Copy StartSeek="0" EndSeek="9676"/>
<Copy StartSeek="9917" EndSeek="10760"/>
</Delta>
<Delta Version="96" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:23:0000">
<Copy StartSeek="0" EndSeek="940"/>
<Copy StartSeek="982" EndSeek="9856"/>
<Insert>	unsigned long *org_p = &amp;sk_alloc;
</Insert>
<Copy StartSeek="9858" EndSeek="10769"/>
</Delta>
<Delta Version="97" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:23:28000">
<Copy StartSeek="0" EndSeek="982"/>
<Copy StartSeek="983" EndSeek="10770"/>
</Delta>
<Delta Version="98" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:23:29000">
<Copy StartSeek="0" EndSeek="940"/>
<Insert>
</Insert>
<Copy StartSeek="968" EndSeek="10797"/>
</Delta>
<Delta Version="99" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:25:5000">
<Copy StartSeek="0" EndSeek="9884"/>
<Insert>	
</Insert>
<Copy StartSeek="9913" EndSeek="10824"/>
</Delta>
<Delta Version="100" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:25:46000">
<Copy StartSeek="0" EndSeek="9884"/>
<Insert>	org_sk_alloc = &amp;sk_alloc();
</Insert>
<Copy StartSeek="9911" EndSeek="10822"/>
</Delta>
<Delta Version="101" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:25:48000">
<Copy StartSeek="0" EndSeek="9884"/>
<Copy StartSeek="9908" EndSeek="10846"/>
</Delta>
<Delta Version="102" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:27:29000">
<Copy StartSeek="0" EndSeek="10000"/>
<Insert>}

</Insert>
<Copy StartSeek="10029" EndSeek="10872"/>
</Delta>
<Delta Version="103" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:27:46000">
<Copy StartSeek="0" EndSeek="9884"/>
<Insert>	spin_lock(&amp;klna_lock);
</Insert>
<Copy StartSeek="9912" EndSeek="10876"/>
</Delta>
<Delta Version="104" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:28:5000">
<Copy StartSeek="0" EndSeek="494"/>
<Copy StartSeek="516" EndSeek="10898"/>
</Delta>
<Delta Version="105" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:30:44000">
<Copy StartSeek="0" EndSeek="9866"/>
<Insert>
</Insert>
<Copy StartSeek="9921" EndSeek="10952"/>
</Delta>
<Delta Version="106" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:31:40000">
<Copy StartSeek="0" EndSeek="990"/>
<Insert>unsigned long *org_sk_alloc = &amp;sk_alloc;

</Insert>
<Copy StartSeek="1089" EndSeek="11009"/>
</Delta>
<Delta Version="107" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:33:53000">
<Copy StartSeek="0" EndSeek="990"/>
<Insert>struct sock *(org_sk_alloc)(int family, gfp_t priority,
</Insert>
<Copy StartSeek="1046" EndSeek="11009"/>
</Delta>
<Delta Version="108" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:34:17000">
<Copy StartSeek="0" EndSeek="990"/>
<Insert>struct sock (*org_sk_alloc)(int family, gfp_t priority,
</Insert>
<Copy StartSeek="1047" EndSeek="11010"/>
</Delta>
<Delta Version="109" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:34:24000">
<Copy StartSeek="0" EndSeek="9924"/>
<Insert>	return *org_sk_alloc(family, priority, prot,zero_it);
</Insert>
<Copy StartSeek="9978" EndSeek="11009"/>
</Delta>
<Delta Version="110" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:35:38000">
<Copy StartSeek="0" EndSeek="10072"/>
<Insert>	printk(KERN_ERR "(%s:%d) org %p\n", __func__, __LINE__, org_p);
</Insert>
<Copy StartSeek="10144" EndSeek="11016"/>
</Delta>
<Delta Version="111" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:35:48000">
<Copy StartSeek="0" EndSeek="10072"/>
<Insert>	printk(KERN_ERR "(%s:%d) org %p\n", __func__, __LINE__, org_sk_alloc);
</Insert>
<Copy StartSeek="10153" EndSeek="11025"/>
</Delta>
<Delta Version="112" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:35:50000">
<Copy StartSeek="0" EndSeek="10179"/>
<Insert>}

</Insert>
<Copy StartSeek="10218" EndSeek="11061"/>
</Delta>
<Delta Version="113" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:36:26000">
<Copy StartSeek="0" EndSeek="10179"/>
<Insert>	return org_sk_alloc ? 0 : -EINVAL;
</Insert>
<Copy StartSeek="10215" EndSeek="11061"/>
</Delta>
<Delta Version="114" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:36:44000">
<Copy StartSeek="0" EndSeek="10390"/>
<Copy StartSeek="10479" EndSeek="11150"/>
</Delta>
<Delta Version="115" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:37:45000">
<Copy StartSeek="0" EndSeek="10476"/>
<Insert>	}
</Insert>
<Copy StartSeek="10493" EndSeek="11164"/>
</Delta>
<Delta Version="116" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:37:58000">
<Copy StartSeek="0" EndSeek="10429"/>
<Insert>		pr_err("couldn't register pppox monitor\n");
</Insert>
<Copy StartSeek="10485" EndSeek="11173"/>
</Delta>
<Delta Version="117" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:38:17000">
<Copy StartSeek="0" EndSeek="9924"/>
<Insert>	return org_sk_alloc(family, priority, prot,zero_it);
}

</Insert>
<Copy StartSeek="10092" EndSeek="10264"/>
<Copy StartSeek="10265" EndSeek="11285"/>
</Delta>
<Delta Version="118" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:44:30000">
<Copy StartSeek="0" EndSeek="10025"/>
<Copy StartSeek="10026" EndSeek="11286"/>
</Delta>
<Delta Version="119" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:44:33000">
<Copy StartSeek="0" EndSeek="9969"/>
<Insert>		printk(KERN_ERR "(%s:%d) \n", __func__, __LINE__);
</Insert>
<Copy StartSeek="10045" EndSeek="11309"/>
</Delta>
<Delta Version="120" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:44:42000">
<Copy StartSeek="0" EndSeek="10048"/>
<Insert>
</Insert>
<Copy StartSeek="10048" EndSeek="11308"/>
</Delta>
<Delta Version="121" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:44:48000">
<Copy StartSeek="0" EndSeek="10287"/>
<Insert>
</Insert>
<Copy StartSeek="10314" EndSeek="11334"/>
</Delta>
<Delta Version="122" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:45:4000">
<Copy StartSeek="0" EndSeek="10115"/>
<Insert>static int replace_sk_alloc(void)
</Insert>
<Copy StartSeek="10152" EndSeek="10554"/>
<Insert>	err = replace_sk_alloc();
</Insert>
<Copy StartSeek="10584" EndSeek="11340"/>
</Delta>
<Delta Version="123" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:45:38000">
<Copy StartSeek="0" EndSeek="10115"/>
<Copy StartSeek="10265" EndSeek="11490"/>
</Delta>
<Delta Version="124" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:46:34000">
<Copy StartSeek="0" EndSeek="10157"/>
<Insert>	spin_lock_irq(&amp;klna_lock);
</Insert>
<Copy StartSeek="10189" EndSeek="10240"/>
<Insert>	spin_unlock(&amp;klna_lock);
</Insert>
<Copy StartSeek="10277" EndSeek="11505"/>
</Delta>
<Delta Version="125" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:47:47000">
<Copy StartSeek="0" EndSeek="10319"/>
<Insert>	spin_lock_irq(&amp;klna_lock);
</Insert>
<Copy StartSeek="10351" EndSeek="10486"/>
<Insert>	spin_unlock(&amp;klna_lock);
</Insert>
<Copy StartSeek="10523" EndSeek="11520"/>
</Delta>
<Delta Version="126" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:47:57000">
<Copy StartSeek="0" EndSeek="441"/>
<Copy StartSeek="469" EndSeek="11548"/>
</Delta>
<Delta Version="127" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:48:54000">
<Copy StartSeek="0" EndSeek="10185"/>
<Insert>	spin_lock_irqsave(&amp;klna_lock);
</Insert>
<Copy StartSeek="10212" EndSeek="11543"/>
</Delta>
<Delta Version="128" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:49:15000">
<Copy StartSeek="0" EndSeek="10263"/>
<Insert>	spin_unlock_irqrestore(&amp;klna_lock);
</Insert>
<Copy StartSeek="10292" EndSeek="11535"/>
</Delta>
<Delta Version="129" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:49:26000">
<Copy StartSeek="0" EndSeek="10334"/>
<Insert>	spin_lock_irqsave(&amp;klna_lock);
</Insert>
<Copy StartSeek="10361" EndSeek="10496"/>
<Insert>	spin_unlock_irqrestore(&amp;klna_lock);
</Insert>
<Copy StartSeek="10525" EndSeek="11522"/>
</Delta>
<Delta Version="130" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:49:35000">
<Copy StartSeek="0" EndSeek="441"/>
<Insert>#include &lt;linux/spinlock.h&gt;
</Insert>
<Copy StartSeek="471" EndSeek="11524"/>
</Delta>
<Delta Version="131" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:49:48000">
<Copy StartSeek="0" EndSeek="10265"/>
<Copy StartSeek="10368" EndSeek="11627"/>
</Delta>
<Delta Version="132" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:55:30000">
<Copy StartSeek="0" EndSeek="10574"/>
<Insert>	sk_alloc = klna_sk_alloc;
</Insert>
<Copy StartSeek="10618" EndSeek="11644"/>
</Delta>
<Delta Version="133" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:55:46000">
<Copy StartSeek="0" EndSeek="10235"/>
<Insert>		sk_alloc = org_sk_alloc;
</Insert>
<Copy StartSeek="10279" EndSeek="11661"/>
</Delta>
<Delta Version="134" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:56:3000">
<Copy StartSeek="0" EndSeek="10235"/>
<Insert>		(unsigned long *)sk_alloc = org_sk_alloc;
</Insert>
<Copy StartSeek="10280" EndSeek="11662"/>
</Delta>
<Delta Version="135" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:57:23000">
<Copy StartSeek="0" EndSeek="10235"/>
<Insert>		(unsigned long *)&amp;sk_alloc = org_sk_alloc;
</Insert>
<Copy StartSeek="10263" EndSeek="11645"/>
</Delta>
<Delta Version="136" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:57:41000">
<Copy StartSeek="0" EndSeek="10575"/>
<Insert>	(unsigned long *)sk_alloc = klna_sk_alloc;
</Insert>
<Copy StartSeek="10602" EndSeek="11628"/>
</Delta>
<Delta Version="137" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:57:47000">
<Copy StartSeek="0" EndSeek="10235"/>
<Insert>		&amp;sk_alloc = org_sk_alloc;
</Insert>
<Copy StartSeek="10262" EndSeek="11627"/>
</Delta>
<Delta Version="138" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:59:17000">
<Copy StartSeek="0" EndSeek="10235"/>
<Insert>		sk_alloc = org_sk_alloc;
</Insert>
<Copy StartSeek="10263" EndSeek="11628"/>
</Delta>
<Delta Version="139" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:59:27000">
<Copy StartSeek="0" EndSeek="10235"/>
<Insert>		sk_alloc = *org_sk_alloc;
</Insert>
<Copy StartSeek="10262" EndSeek="11627"/>
</Delta>
<Delta Version="140" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="14:59:35000">
<Copy StartSeek="0" EndSeek="10439"/>
<Insert>	spin_lock_bh(&amp;klna_lock);
</Insert>
<Copy StartSeek="10467" EndSeek="10602"/>
<Insert>	spin_unlock_bh(&amp;klna_lock);
</Insert>
<Copy StartSeek="10632" EndSeek="11629"/>
</Delta>
<Delta Version="141" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="15:01:37000">
<Copy StartSeek="0" EndSeek="10187"/>
<Insert>	spin_lock_bh(&amp;klna_lock);
</Insert>
<Copy StartSeek="10215" EndSeek="10369"/>
<Insert>	spin_unlock_bh(&amp;klna_lock);
</Insert>
<Copy StartSeek="10399" EndSeek="11631"/>
</Delta>
<Delta Version="142" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="15:01:46000">
<Copy StartSeek="0" EndSeek="441"/>
<Copy StartSeek="467" EndSeek="11657"/>
</Delta>
<Delta Version="143" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="15:02:18000">
<Copy StartSeek="0" EndSeek="441"/>
<Insert>#include &lt;asm/notifier.h&gt;
</Insert>
<Copy StartSeek="469" EndSeek="11659"/>
</Delta>
<Delta Version="144" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="15:02:30000">
<Copy StartSeek="0" EndSeek="1148"/>
<Copy StartSeek="1244" EndSeek="11755"/>
</Delta>
<Delta Version="145" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="15:10:57000">
<Copy StartSeek="0" EndSeek="1148"/>
<Insert>struct sock  *sk_alloc(int family, gfp_t priority, 
</Insert>
<Copy StartSeek="1204" EndSeek="11759"/>
</Delta>
<Delta Version="146" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="15:11:0000">
<Copy StartSeek="0" EndSeek="1147"/>
<Insert>
struct sock  *org_sk_alloc(int family, gfp_t priority, 
		       struct proto *prot, int zero_it);

</Insert>
<Copy StartSeek="1147" EndSeek="11658"/>
</Delta>
<Delta Version="147" Comment="" NL="\10" Encoding="text" Date="2012/04/23" Time="15:12:19000">
<Copy StartSeek="0" EndSeek="10293"/>
<Insert>	flush_icache_range((unsigned long)&amp;sk_alloc,
			   (unsigned long)&amp;sk_alloc + sizeof(*org_sk_alloc));
</Insert>
<Copy StartSeek="10410" EndSeek="11672"/>
</Delta>
</DeltaFile>
