<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="177" Comment="" Date="2012/03/26" Time="09:58:31000" NL="\10" Encoding="text">
<Insert>/************************************************************************
* Copyright (C) 2010, Marvell Technology Group Ltd.
* All Rights Reserved.
* 
* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
* the contents of this file may not be disclosed to third parties, copied
* or duplicated in any form, in whole or in part, without the prior
* written permission of Marvell Technology Group.
* 
* dpa_api.h
*
* Description:
*       Marvell Data Path Acceleration Engine API
*
*/

#ifndef _DPA_API_H_
#define _DPA_API_H_

#ifdef __cplusplus
extern "C" {
#endif

#include &lt;dpa_types.h&gt;


int32_t dpa_init(const uint8_t* dpa_config);
int32_t dpa_shutdown(void);
int32_t dpa_get_stats(dpa_stats_t* stats);
int32_t dpa_set_log_level(dpa_log_unit_t id, int32_t log_level);

/* enable/disable auto learning agent */
int32_t dpa_learn_set(bool en);

/* bind/unbind dpa interface */
int32_t dpa_if_add(uint32_t port);
int32_t dpa_if_del(uint32_t port);

#ifdef DPA_BRIDGE
int32_t dpa_bridge_if_add(int32_t bridge, int32_t port);
int32_t dpa_bridge_if_del(int32_t bridge, int32_t port);
void dpa_bridge_flush(void);

typedef enum {
	DPA_BR_RULE_DROP	= 1,
} DPA_BRIDGE_RULE_FLAGS;


typedef struct dpa_bridge_rule {
	uint8_t	da[MV_MAC_ADDR_SIZE];
	uint8_t	sa[MV_MAC_ADDR_SIZE];
	uint32_t iif;
	uint32_t oif;
	DPA_BRIDGE_RULE_FLAGS flags; /* bit field */
} dpa_bridge_rule_t;

/* Add/Del bridging rule */
int32_t dpa_bridge_rule_add(dpa_bridge_rule_t *rule);
int32_t dpa_bridge_rule_del(dpa_bridge_rule_t *rule);
#endif /* DPA_BRIDGE */

#ifdef DPA_VLAN
typedef enum {
	DPA_VLAN_RX_TRANSPARENT                = 0,
	DPA_VLAN_RX_DROP_UNTAGGED              = 1,
	DPA_VLAN_RX_DROP_TAGGED                = 2,
	DPA_VLAN_RX_DROP_UNKNOWN               = 3,
	DPA_VLAN_RX_DROP_UNTAGGED_AND_UNKNOWN  = 4,
} dpa_vlan_rx_mode;

typedef enum {
	DPA_VLAN_TX_TRANSPARENT = 0,
	DPA_VLAN_TX_UNTAGGED    = 1,
	DPA_VLAN_TX_TAGGED      = 2,
} dpa_vlan_tx_mode;

int32_t dpa_vlan_pvid_set(int32_t if_index, uint16_t pvid);
int32_t dpa_vlan_vid_set(int32_t if_index, uint16_t vid);
int32_t dpa_vlan_rx_mode_set(int32_t if_index, dpa_vlan_rx_mode mode);
int32_t dpa_vlan_tx_mode_set(int32_t if_index, dpa_vlan_tx_mode mode);
#endif /* DPA_VLAN */

#ifdef DPA_IPV4_FWD
typedef struct dpa_arp_entry {
	uint8_t dst_l3[MV_MAX_L3_ADDR_SIZE];
	uint8_t da_mac[MV_MAC_ADDR_SIZE];
	uint32_t family;
	uint32_t age;
} dpa_arp_entry_t;

uint32_t dpa_arp_add(dpa_arp_entry_t *arp);
uint32_t dpa_arp_del(dpa_arp_entry_t *arp);
uint32_t dpa_arp_flush(void);

typedef struct dpa_rt_rule {
	uint8_t	dst_l3[MV_MAX_L3_ADDR_SIZE];
	uint32_t dst_mask_len;
	uint8_t	dst_l3_gw[MV_MAX_L3_ADDR_SIZE];
	uint32_t family;
	uint32_t flags;
	uint32_t oif;
} dpa_rt_rule_t;

uint32_t dpa_rt_rule_add(dpa_rt_rule_t *rule);
uint32_t dpa_rt_rule_del(dpa_rt_rule_t *rule);
uint32_t dpa_rt_rule_flush(void);
#endif /* DPA_IPV4_FWD */

#ifdef DPA_CONNTRACK
typedef enum {
	DPA_CT_RULE_FLAG_SNAT          = 0X1
	DPA_CT_RULE_FLAG_DNAT          = 0X2,
	DPA_CT_RULE_FLAG_DROP          = 0X4,
	DPA_CT_RULE_FLAG_SET_DSCP      = 0X8,
	DPA_CT_RULE_FLAG_SET_VLAN_PRIO = 0X10,
	DPA_CT_RULE_FLAG_SET_TXQ       = 0X20,
	DPA_CT_RULE_FLAG_SET_TXP       = 0X40,
	DPA_CT_RULE_FLAG_SET_MH        = 0X80,
} dpa_ct_rule_flags;

typedef struct dpa_rule_ct {
	uint32_t family;
	uint8_t srcL3[MV_MAX_L3_ADDR_SIZE];
	uint8_t dstL3[MV_MAX_L3_ADDR_SIZE];
	uint16_t proto;
	uint16_t sport;
	uint16_t dport;
#ifdef DPA_NAT /* ipv4 only */
	uint32_t new_sip;
	uint32_t new_dip;
	uint16_t new_sport;
	uint16_t new_dport;
#endif /* DPA_NAT */
	dpa_ct_rule_flags flags;
	uint32_t age;
} dpa_rule_ct_t;

dpa_ct_rule_add(dpa_rule_ct *rule);
dpa_ct_rule_del(dpa_rule_ct *rule);
dpa_ct_rule_flush(void);
#endif /* DPA_CONNTRACK */

#ifdef __cplusplus
}
#endif

#endif /* _DPA_API_H_ */
</Insert>
</MostRecent>
<Delta Version="0" Comment="" NL="\10" Encoding="text" Date="2012/03/22" Time="09:48:2000">
<Copy StartSeek="0" EndSeek="507"/>
<Insert>#ifndef _MMP_API_H_
#define _MMP_API_H_
</Insert>
<Copy StartSeek="547" EndSeek="31699"/>
</Delta>
<Delta Version="1" Comment="" NL="\10" Encoding="text" Date="2012/03/22" Time="09:48:27000">
<Copy StartSeek="0" EndSeek="422"/>
<Insert>* mmp_api.h
</Insert>
<Copy StartSeek="434" EndSeek="588"/>
<Insert>#include &lt;mmp_types.h&gt;
</Insert>
<Copy StartSeek="611" EndSeek="616"/>
<Insert> * mmp_init
</Insert>
<Copy StartSeek="628" EndSeek="647"/>
<Insert> *       Initialize MMP engine.
</Insert>
<Copy StartSeek="679" EndSeek="697"/>
<Insert> *       mmp_config - MMP engine configuration profile in xml format
</Insert>
<Copy StartSeek="766" EndSeek="783"/>
<Insert> *        MMP_OK              - On success. 
 *        MMP_CONFIG_ERROR    - On configuration error.
 *        MMP_OUT_OF_MEMORY   - On out of memory error.
 *        MMP_TDM_INIT_FAILED - ON TDM unit initialization failure.
</Insert>
<Copy StartSeek="1008" EndSeek="1012"/>
<Insert>int32_t mmp_init(const char* mmp_config);
</Insert>
<Copy StartSeek="1054" EndSeek="1059"/>
<Insert> * mmp_shutdown
</Insert>
<Copy StartSeek="1075" EndSeek="1096"/>
<Insert> *       Shutdown MMP engine.
</Insert>
<Copy StartSeek="1126" EndSeek="1179"/>
<Insert> *       MMP_OK - The function always succeeds.
</Insert>
<Copy StartSeek="1227" EndSeek="1234"/>
<Insert>int32_t mmp_shutdown(void);
</Insert>
<Copy StartSeek="1262" EndSeek="1267"/>
<Insert> * mmp_open_phone_line
</Insert>
<Copy StartSeek="1290" EndSeek="1611"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="1655" EndSeek="1690"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
</Insert>
<Copy StartSeek="1765" EndSeek="1773"/>
<Insert>int32_t mmp_open_phone_line(int32_t line_id);
</Insert>
<Copy StartSeek="1819" EndSeek="1824"/>
<Insert> * mmp_open_ip_line
</Insert>
<Copy StartSeek="1844" EndSeek="2473"/>
<Insert> * On success, the function returns MMP_OK. 
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="2562" EndSeek="2569"/>
<Insert>int32_t mmp_open_ip_line(mmp_ipaddr_t  local_ip,
</Insert>
<Copy StartSeek="2618" EndSeek="2669"/>
<Insert>                         mmp_ipaddr_t  remote_ip,
</Insert>
<Copy StartSeek="2719" EndSeek="2825"/>
<Insert> * mmp_open_playback_line
</Insert>
<Copy StartSeek="2851" EndSeek="3146"/>
<Insert> * On success, the function returns MMP_OK. 
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="3235" EndSeek="3242"/>
<Insert>int32_t mmp_open_playback_line(mmp_codec_type_t codec, 
</Insert>
<Copy StartSeek="3298" EndSeek="3425"/>
<Insert> * mmp_set_ip_params
</Insert>
<Copy StartSeek="3446" EndSeek="3923"/>
<Insert> * On success, the function returns MMP_OK. 
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="4012" EndSeek="4019"/>
<Insert>int32_t mmp_set_ip_params(int32_t       line_id,
                          mmp_ipaddr_t  local_ip,
</Insert>
<Copy StartSeek="4118" EndSeek="4170"/>
<Insert>                          mmp_ipaddr_t  remote_ip,
</Insert>
<Copy StartSeek="4221" EndSeek="4280"/>
<Insert> *  mmp_bind_to_device - Bind IP line a network interface.
</Insert>
<Copy StartSeek="4339" EndSeek="4409"/>
<Insert>int32_t mmp_bind_to_device(int32_t line_id,
</Insert>
<Copy StartSeek="4453" EndSeek="4503"/>
<Insert> * mmp_get_tos
</Insert>
<Copy StartSeek="4518" EndSeek="4611"/>
<Insert> * with mmp_open_ip_line API. The existing IP lines are not affected.
</Insert>
<Copy StartSeek="4681" EndSeek="4754"/>
<Insert> * On success, the function returns MMP_OK. 
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="4843" EndSeek="4876"/>
<Insert>int32_t mmp_set_tos(uint8_t tos);
</Insert>
<Copy StartSeek="4910" EndSeek="4914"/>
<Insert> * mmp_set_tos
</Insert>
<Copy StartSeek="4929" EndSeek="5024"/>
<Insert> * with mmp_open_ip_line API.
</Insert>
<Copy StartSeek="5054" EndSeek="5147"/>
<Insert> * On success, the function returns MMP_OK. 
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="5236" EndSeek="5269"/>
<Insert>int32_t mmp_get_tos(uint8_t *tos);
</Insert>
<Copy StartSeek="5304" EndSeek="5308"/>
<Insert> * mmp_set_voip_mode
</Insert>
<Copy StartSeek="5329" EndSeek="6527"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="6571" EndSeek="6606"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INVALID_IP_ADDR
 *    MMP_BIND_ERROR
 *    MMP_INACTIVE_LINE
</Insert>
<Copy StartSeek="6752" EndSeek="6759"/>
<Insert>int32_t mmp_set_voip_mode(int32_t           line_id, 
                          mmp_codec_type_t  tx_codec,
</Insert>
<Copy StartSeek="6867" EndSeek="6988"/>
<Insert>                          mmp_codec_type_t  rx_codec,
</Insert>
<Copy StartSeek="7042" EndSeek="7108"/>
<Insert> * mmp_set_foip_mode
</Insert>
<Copy StartSeek="7129" EndSeek="7373"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="7417" EndSeek="7452"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
</Insert>
<Copy StartSeek="7527" EndSeek="7534"/>
<Insert>int32_t mmp_set_foip_mode(int32_t             line_id, 
                          mmp_foip_options_t* opt);
</Insert>
<Copy StartSeek="7642" EndSeek="7648"/>
<Insert> * mmp_set_vbd_mode
</Insert>
<Copy StartSeek="7668" EndSeek="7938"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="7982" EndSeek="8017"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INVALID_PARAM2
</Insert>
<Copy StartSeek="8117" EndSeek="8124"/>
<Insert>int32_t mmp_set_vbd_mode(int32_t            line_id,
                         mmp_vbd_params_t  *params);
</Insert>
<Copy StartSeek="8230" EndSeek="8235"/>
<Insert> * mmp_close_line
</Insert>
<Copy StartSeek="8253" EndSeek="8388"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="8432" EndSeek="8467"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INACTIVE_LINE
</Insert>
<Copy StartSeek="8566" EndSeek="8573"/>
<Insert>int32_t mmp_close_line(int32_t line_id);
</Insert>
<Copy StartSeek="8614" EndSeek="8618"/>
<Insert> * mmp_create_call
</Insert>
<Copy StartSeek="8637" EndSeek="8765"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="8853" EndSeek="8857"/>
<Insert>int32_t mmp_create_call(int32_t *call_id);
</Insert>
<Copy StartSeek="8900" EndSeek="8905"/>
<Insert> * mmp_join_call()
</Insert>
<Copy StartSeek="8924" EndSeek="9153"/>
<Insert> *       MMP_OK   - On success.
 *       MMP_FAIL - On error. 
</Insert>
<Copy StartSeek="9216" EndSeek="9223"/>
<Insert>int32_t mmp_join_call(int32_t call_id, 
</Insert>
<Copy StartSeek="9263" EndSeek="9308"/>
<Insert> * mmp_leave_call
</Insert>
<Copy StartSeek="9326" EndSeek="9490"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL. 
</Insert>
<Copy StartSeek="9579" EndSeek="9586"/>
<Insert>int32_t mmp_leave_call(int32_t call_id, 
</Insert>
<Copy StartSeek="9627" EndSeek="9673"/>
<Insert> * mmp_destroy_call
</Insert>
<Copy StartSeek="9693" EndSeek="9825"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL. 
</Insert>
<Copy StartSeek="9914" EndSeek="9921"/>
<Insert>int32_t mmp_destroy_call(int32_t call_id);
</Insert>
<Copy StartSeek="9964" EndSeek="9969"/>
<Insert> * mmp_tonegen_set_tone
</Insert>
<Copy StartSeek="9993" EndSeek="10363"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="10407" EndSeek="10442"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INACTIVE_LINE
 *    MMP_INVALID_PROF_ID
 *    MMP_INVALID_TONE_ID
 *    MMP_INVALID_PARAM3
</Insert>
<Copy StartSeek="10618" EndSeek="10625"/>
<Insert>int32_t mmp_tonegen_set_tone( int16_t profile_id,
</Insert>
<Copy StartSeek="10675" EndSeek="10705"/>
<Insert>							  mmp_utg_tone_t *tone);
</Insert>
<Copy StartSeek="10737" EndSeek="10742"/>
<Insert> * mmp_tone_start
</Insert>
<Copy StartSeek="10760" EndSeek="11067"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="11111" EndSeek="11146"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INACTIVE_LINE
 *    MMP_INVALID_PROF_ID
 *    MMP_INVALID_TONE_ID
 *    MMP_INVALID_DIR
</Insert>
<Copy StartSeek="11319" EndSeek="11326"/>
<Insert>int32_t mmp_tone_start( int32_t          line_id, 
                        mmp_media_path_t mpath, 
</Insert>
<Copy StartSeek="11426" EndSeek="11542"/>
<Insert> * mmp_tone_stop
</Insert>
<Copy StartSeek="11559" EndSeek="11700"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="11744" EndSeek="11779"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INACTIVE_LINE
</Insert>
<Copy StartSeek="11878" EndSeek="11885"/>
<Insert>int32_t mmp_tone_stop(int32_t line_id);
</Insert>
<Copy StartSeek="11925" EndSeek="11930"/>
<Insert> * mmp_tone_detection_enable
</Insert>
<Copy StartSeek="11959" EndSeek="12035"/>
<Insert> * Detected tones info reported via MMP_EVENT_TYPE_TONE_DETECTION event
</Insert>
<Copy StartSeek="12107" EndSeek="12550"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="12594" EndSeek="12629"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INACTIVE_LINE
 *    MMP_INVALID_PROF_ID
</Insert>
<Copy StartSeek="12754" EndSeek="12761"/>
<Insert>int32_t mmp_tone_detection_enable(int32_t          line_id,
								  mmp_media_path_t mpath,                                   
</Insert>
<Copy StartSeek="12890" EndSeek="12998"/>
<Insert> * mmp_lec_enable
</Insert>
<Copy StartSeek="13016" EndSeek="13265"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="13309" EndSeek="13344"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INACTIVE_LINE
</Insert>
<Copy StartSeek="13443" EndSeek="13450"/>
<Insert>int32_t mmp_lec_enable(int32_t line_id, 
</Insert>
<Copy StartSeek="13491" EndSeek="13536"/>
<Insert> * mmp_lec_set_params
</Insert>
<Copy StartSeek="13558" EndSeek="13689"/>
<Insert> * mmp_lec_params  - LEC parameters.
</Insert>
<Copy StartSeek="13726" EndSeek="13741"/>
<Insert> * On success, the function returns MMP_OK. 
</Insert>
<Copy StartSeek="13786" EndSeek="13821"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INACTIVE_LINE
 *    MMP_INVALID_PARAM
</Insert>
<Copy StartSeek="13944" EndSeek="13952"/>
<Insert>int32_t mmp_lec_set_params(int32_t line_id, mmp_lec_params_t* lec_params);
</Insert>
<Copy StartSeek="14027" EndSeek="14031"/>
<Insert> * mmp_lec_get_params
</Insert>
<Copy StartSeek="14053" EndSeek="14192"/>
<Insert> * mmp_lec_params  - Returned LEC parameters.
</Insert>
<Copy StartSeek="14238" EndSeek="14253"/>
<Insert> * On success, the function returns MMP_OK. 
</Insert>
<Copy StartSeek="14298" EndSeek="14333"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INACTIVE_LINE
 *    MMP_INVALID_PARAM
</Insert>
<Copy StartSeek="14456" EndSeek="14463"/>
<Insert>int32_t mmp_lec_get_params(int32_t line_id, mmp_lec_params_t* lec_params);
</Insert>
<Copy StartSeek="14538" EndSeek="14542"/>
<Insert> * mmp_caller_id_start
</Insert>
<Copy StartSeek="14565" EndSeek="15069"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="15113" EndSeek="15148"/>
<Insert> *                               MMP_INVALID_LINEID
 *                               MMP_API_EXEC_FAIL
 *                               MMP_NOT_INITIALIZED
 *                               MMP_INVALID_PROF_ID
 *                               MMP_INACTIVE_LINE
</Insert>
<Copy StartSeek="15408" EndSeek="15415"/>
<Insert>int32_t mmp_caller_id_start(int32_t       line_id, 
</Insert>
<Copy StartSeek="15467" EndSeek="15525"/>
<Insert>                            mmp_cid_msg_t *msg);
</Insert>
<Copy StartSeek="15574" EndSeek="15579"/>
<Insert> * mmp_caller_id_stop
</Insert>
<Copy StartSeek="15601" EndSeek="15800"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="15844" EndSeek="15879"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INACTIVE_LINE
</Insert>
<Copy StartSeek="15978" EndSeek="15985"/>
<Insert>int32_t mmp_caller_id_stop(int32_t line_id);
</Insert>
<Copy StartSeek="16030" EndSeek="16035"/>
<Insert> * mmp_agc_enable
</Insert>
<Copy StartSeek="16053" EndSeek="16405"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="16449" EndSeek="16484"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INACTIVE_LINE
 *    MMP_INVALID_PROF_ID
</Insert>
<Copy StartSeek="16609" EndSeek="16616"/>
<Insert>int32_t mmp_agc_enable(int32_t          line_id, 
                       mmp_media_path_t mpath,
</Insert>
<Copy StartSeek="16713" EndSeek="16775"/>
<Insert> * mmp_set_gain
</Insert>
<Copy StartSeek="16791" EndSeek="17128"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="17172" EndSeek="17207"/>
<Insert> *    MMP_INVALID_LINEID
 *    MMP_API_EXEC_FAIL
 *    MMP_NOT_INITIALIZED
 *    MMP_INVALID_PARAM3
</Insert>
<Copy StartSeek="17307" EndSeek="17314"/>
<Insert>int32_t mmp_set_gain(int32_t          line_id, 
                     mmp_media_path_t mpath,
</Insert>
<Copy StartSeek="17407" EndSeek="17460"/>
<Insert> * mmp_rtcp_enable:
</Insert>
<Copy StartSeek="17480" EndSeek="17812"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="17900" EndSeek="17907"/>
<Insert>int32_t mmp_rtcp_enable(int32_t         line_id,
                        mmp_rtcp_mode_t mode,
</Insert>
<Copy StartSeek="18002" EndSeek="18168"/>
<Insert> * mmp_get_line_stats
</Insert>
<Copy StartSeek="18190" EndSeek="18347"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="18435" EndSeek="18442"/>
<Insert>int32_t mmp_get_line_stats(int32_t           line_id, 
                           mmp_line_stats_t* stats);
</Insert>
<Copy StartSeek="18550" EndSeek="18555"/>
<Insert> * mmp_playback_line_write
</Insert>
<Copy StartSeek="18582" EndSeek="18916"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="19004" EndSeek="19011"/>
<Insert>int32_t mmp_playback_line_write(int32_t   line_id, 
</Insert>
<Copy StartSeek="19063" EndSeek="19225"/>
<Insert> * mmp_playback_line_read
</Insert>
<Copy StartSeek="19251" EndSeek="19600"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="19688" EndSeek="19695"/>
<Insert>int32_t mmp_playback_line_read(int32_t   line_id, 
</Insert>
<Copy StartSeek="19746" EndSeek="19939"/>
<Insert> * mmp_set_voice_quality_alarm
</Insert>
<Copy StartSeek="19970" EndSeek="20243"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="20331" EndSeek="20338"/>
<Insert>int32_t mmp_set_voice_quality_alarm(int32_t line_id,
                                    mmp_voice_quality_alarm_params_t* params);
</Insert>
<Copy StartSeek="20470" EndSeek="20511"/>
<Insert> * mmp_set_jb_params
</Insert>
<Copy StartSeek="20532" EndSeek="20740"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="20828" EndSeek="20835"/>
<Insert>int32_t mmp_set_jb_params(int32_t         line_id, 
                          mmp_jb_params_t* params);
</Insert>
<Copy StartSeek="20939" EndSeek="20944"/>
<Insert> * mmp_get_jb_params()
</Insert>
<Copy StartSeek="20967" EndSeek="21159"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="21247" EndSeek="21254"/>
<Insert>int32_t mmp_get_jb_params(int32_t          line_id, 
                          mmp_jb_params_t* params);
</Insert>
<Copy StartSeek="21359" EndSeek="21364"/>
<Insert> * mmp_get_jb_stats
</Insert>
<Copy StartSeek="21384" EndSeek="21562"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="21650" EndSeek="21657"/>
<Insert>int32_t mmp_get_jb_stats(int32_t        line_id, 
                        mmp_jb_stats_t* stats);
</Insert>
<Copy StartSeek="21755" EndSeek="21760"/>
<Insert> * mmp_rfc2833_enable
</Insert>
<Copy StartSeek="21782" EndSeek="22081"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="22169" EndSeek="22176"/>
<Insert>int32_t mmp_rfc2833_enable(int32_t            line_id, 
                           mmp_rfc2833_mode_t mode, 
</Insert>
<Copy StartSeek="22285" EndSeek="22398"/>
<Insert> * mmp_silence_suppression_enable
</Insert>
<Copy StartSeek="22432" EndSeek="22639"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="22727" EndSeek="22734"/>
<Insert>int32_t mmp_silence_suppression_enable(int32_t                  line_id,
                                       mmp_silence_suppr_mode_t mode);
</Insert>
<Copy StartSeek="22878" EndSeek="22883"/>
<Insert> * mmp_get_call_id
</Insert>
<Copy StartSeek="22902" EndSeek="23139"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="23227" EndSeek="23234"/>
<Insert>int32_t mmp_get_call_id(int32_t  line_id, 
</Insert>
<Copy StartSeek="23277" EndSeek="23325"/>
<Insert> * mmp_get_active_calls_num
</Insert>
<Copy StartSeek="23353" EndSeek="23545"/>
<Insert>int32_t mmp_get_active_calls_num(void);
</Insert>
<Copy StartSeek="23585" EndSeek="23590"/>
<Insert> * mmp_get_active_calls
</Insert>
<Copy StartSeek="23614" EndSeek="23915"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="24003" EndSeek="24010"/>
<Insert>int32_t mmp_get_active_calls(int32_t calls[], 
</Insert>
<Copy StartSeek="24057" EndSeek="24107"/>
<Insert> * mmp_get_lines
</Insert>
<Copy StartSeek="24124" EndSeek="24535"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="24623" EndSeek="24630"/>
<Insert>int32_t mmp_get_lines(int32_t call_id, 
</Insert>
<Copy StartSeek="24670" EndSeek="24775"/>
<Insert> * mmp_get_line_info
</Insert>
<Copy StartSeek="24796" EndSeek="25013"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="25101" EndSeek="25108"/>
<Insert>int32_t mmp_get_line_info(int32_t          line_id, 
                          mmp_line_info_t* line_info);
</Insert>
<Copy StartSeek="25216" EndSeek="25221"/>
<Insert> * mmp_register_events
</Insert>
<Copy StartSeek="25244" EndSeek="25267"/>
<Insert> * Register application callbacks to receive MMP events.
</Insert>
<Copy StartSeek="25324" EndSeek="25486"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="25574" EndSeek="25581"/>
<Insert>int32_t mmp_register_events(mmp_event_mask_t event_mask, mmp_event_handler_t* event_handler);
</Insert>
<Copy StartSeek="25675" EndSeek="25680"/>
<Insert> * mmp_get_version()
</Insert>
<Copy StartSeek="25701" EndSeek="25738"/>
<Insert> * Retrieve MMP version.
</Insert>
<Copy StartSeek="25763" EndSeek="25812"/>
<Insert> * On success, the function returns a string with MMP version.
</Insert>
<Copy StartSeek="25875" EndSeek="25922"/>
<Insert>const char* mmp_get_version(void);
</Insert>
<Copy StartSeek="25957" EndSeek="25961"/>
<Insert> * mmp_enable_media_path:
</Insert>
<Copy StartSeek="25987" EndSeek="26188"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="26276" EndSeek="26283"/>
<Insert>int32_t mmp_enable_media_path(int32_t          line_id, 
                              mmp_media_path_t path);
</Insert>
<Copy StartSeek="26394" EndSeek="26399"/>
<Insert> * mmp_set_ssrc
</Insert>
<Copy StartSeek="26415" EndSeek="26621"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="26709" EndSeek="26717"/>
<Insert>int32_t mmp_set_ssrc(int32_t  line_id, 
</Insert>
<Copy StartSeek="26757" EndSeek="26799"/>
<Insert> * mmp_get_ssrc
</Insert>
<Copy StartSeek="26815" EndSeek="27035"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="27123" EndSeek="27130"/>
<Insert>int32_t mmp_get_ssrc(int32_t   line_id, 
</Insert>
<Copy StartSeek="27171" EndSeek="27215"/>
<Insert> * mmp_set_loopback
</Insert>
<Copy StartSeek="27235" EndSeek="27471"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="27559" EndSeek="27566"/>
<Insert>int32_t mmp_set_loopback(int32_t              line_id1,
</Insert>
<Copy StartSeek="27622" EndSeek="27678"/>
<Insert>                         mmp_loopback_point_t loopback_point,
</Insert>
<Copy StartSeek="27740" EndSeek="27801"/>
<Insert> * mmp_get_stats
</Insert>
<Copy StartSeek="27818" EndSeek="27841"/>
<Insert> * Retrieve mmp system statistics.
</Insert>
<Copy StartSeek="27876" EndSeek="27901"/>
<Insert> * stats   - Returned mmp statistics.
</Insert>
<Copy StartSeek="27939" EndSeek="27957"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="28045" EndSeek="28052"/>
<Insert>int32_t mmp_get_stats(mmp_stats_t* stats);
</Insert>
<Copy StartSeek="28095" EndSeek="28100"/>
<Insert> * mmp_set_rfc2833_event
</Insert>
<Copy StartSeek="28125" EndSeek="28347"/>
<Insert> * On success, the function returns MMP_OK.
 * On error, the function returns MMP_FAIL.
</Insert>
<Copy StartSeek="28435" EndSeek="28442"/>
<Insert>int32_t mmp_set_rfc2833_event(mmp_media_path_t direction,
</Insert>
<Copy StartSeek="28500" EndSeek="28680"/>
<Insert> * mmp_set_log_level
</Insert>
<Copy StartSeek="28701" EndSeek="28831"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="28875" EndSeek="28882"/>
<Insert>  int32_t mmp_set_log_level(mmp_log_unit_t id, int32_t log_level);
</Insert>
<Copy StartSeek="28949" EndSeek="28956"/>
<Insert> * mmp_get_log_level
</Insert>
<Copy StartSeek="28977" EndSeek="29107"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="29151" EndSeek="29158"/>
<Insert>int32_t mmp_get_log_level(mmp_log_unit_t id, int32_t* log_level);
</Insert>
<Copy StartSeek="29224" EndSeek="29229"/>
<Insert> * mmp_set_rfc2198_params
</Insert>
<Copy StartSeek="29255" EndSeek="29411"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="29455" EndSeek="29462"/>
<Insert>  int32_t mmp_set_rfc2198_params(int32_t line_id, mmp_rfc2198_params_t* params);
</Insert>
<Copy StartSeek="29543" EndSeek="29550"/>
<Insert> * mmp_get_rfc2198_params
</Insert>
<Copy StartSeek="29576" EndSeek="29733"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="29777" EndSeek="29784"/>
<Insert>int32_t mmp_get_rfc2198_params(int32_t line_id, mmp_rfc2198_params_t* params);
</Insert>
<Copy StartSeek="29863" EndSeek="29872"/>
<Insert> * mmp_set_packet_capture_params
</Insert>
<Copy StartSeek="29905" EndSeek="30051"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="30095" EndSeek="30102"/>
<Insert>int32_t mmp_set_packet_capture_params(mmp_packet_capture_params_t* params);
</Insert>
<Copy StartSeek="30178" EndSeek="30185"/>
<Insert> * mmp_get_packet_capture_params
</Insert>
<Copy StartSeek="30218" EndSeek="30364"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="30408" EndSeek="30415"/>
<Insert>int32_t mmp_get_packet_capture_params(mmp_packet_capture_params_t* params);
</Insert>
<Copy StartSeek="30491" EndSeek="30497"/>
<Insert> * mmp_set_capture_point_status
</Insert>
<Copy StartSeek="30529" EndSeek="30693"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="30737" EndSeek="30744"/>
<Insert>int32_t mmp_set_capture_point_status(mmp_capture_point_t id, bool status);
</Insert>
<Copy StartSeek="30819" EndSeek="30825"/>
<Insert> * mmp_get_capture_point_status
</Insert>
<Copy StartSeek="30857" EndSeek="31017"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="31061" EndSeek="31068"/>
<Insert>int32_t mmp_get_capture_point_status(mmp_capture_point_t id, bool* status);
</Insert>
<Copy StartSeek="31144" EndSeek="31150"/>
<Insert> * mmp_set_log_params
</Insert>
<Copy StartSeek="31172" EndSeek="31296"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="31340" EndSeek="31347"/>
<Insert>int32_t mmp_set_log_params(mmp_log_params_t* params);
</Insert>
<Copy StartSeek="31401" EndSeek="31407"/>
<Insert> * mmp_get_log_params
</Insert>
<Copy StartSeek="31429" EndSeek="31553"/>
<Insert> * On success, the function returns MMP_OK.
</Insert>
<Copy StartSeek="31597" EndSeek="31604"/>
<Insert>int32_t mmp_get_log_params(mmp_log_params_t* params);
</Insert>
<Copy StartSeek="31658" EndSeek="31699"/>
</Delta>
<Delta Version="2" Comment="" NL="\10" Encoding="text" Date="2012/03/22" Time="09:48:50000">
<Copy StartSeek="0" EndSeek="1267"/>
<Insert> * dpa_open_phone_line
 *
 * Description: 
 * 
 * Activate a local phone (FXS, FXO or Speakerphone) line.
 * Phone lines configuration is defined in &lt;PhoneLineSettings&gt; 
 * configuration section.
 * Line Echo Cancelling (LEC) is enabled by default.
 *  
 * Parameters:
 * 
 * line_id - ID of local phone interface (0 - 63)
 *
 * Returns:  
 * 
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 * 
 */
int32_t dpa_open_phone_line(int32_t line_id);


/*
 * dpa_open_ip_line
 *
 * Description: 
 *
 * Create an IP connection suitable for voice, voice-band-data or
 * fax relay communication. By default, IP line is created in VoIP mode 
 * with codec G711a, payload type 8 and packetization time 10ms.
 *
 * Parameters:
 *
 * local_ip    - Local IP address to use for network communication with
 *               remote party.
 * local_port  - Local network port to use for network communication with
 *               remote party.
 * remote_ip   - IP address of the remote party.
 * remote_port - Network port of the remote party.
 * line_id     - Returned ID of the remote voice line.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK. 
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_open_ip_line(dpa_ipaddr_t  local_ip,
                         uint16_t      local_port,
                         dpa_ipaddr_t  remote_ip,
                         uint16_t      remote_port,
                         int32_t*      line_id);


/*
 * dpa_open_playback_line
 *
 * Description:  
 *
 * Create a playback line.
 *
 * Parameters:
 *
 * codec          - Voice codec to use.
 * rx_frames_num  - Number of frames to receive in the receive callback.
 *                  [Deprecated]
 * line_id        - Returned ID of the virtual voice line.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK. 
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_open_playback_line(dpa_codec_type_t codec, 
                               int32_t          rx_frames_num, 
                               int32_t*         line_id);


/*
 * dpa_set_ip_params
 *
 * Description: 
 *
 * Modify IP parameters of an existing IP line.
 * The existing VoIP, FoIP or VBD sessions are terminated.
 *
 * Parameters:
 *
 * local_ip    - Local IP address to use for network communication with
 *               remote party.
 * local_port  - Local network port to use for network communication with
 *               remote party.
 * remote_ip   - IP address of the remote party.
 * remote_port - Network port of the remote party.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK. 
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_set_ip_params(int32_t       line_id,
                          dpa_ipaddr_t  local_ip,
                          uint16_t      local_port,
                          dpa_ipaddr_t  remote_ip,
                          uint16_t      remote_port);

/* 
 *  dpa_bind_to_device - Bind IP line a network interface.
 *
 *  line_id: IP line id.
 *  @dev_name: Network interface name
 */
int32_t dpa_bind_to_device(int32_t line_id,
                           char    *dev_name);
/*
 * dpa_get_tos
 *
 * Description: 
 *
 * Modify the current default ToS setting used when creating IP lines
 * with dpa_open_ip_line API. The existing IP lines are not affected.
 *
 * Parameters:
 *
 * tos - New default ToS setting.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK. 
 * On error, the function returns DPA_FAIL.
 *
 */                          
int32_t dpa_set_tos(uint8_t tos);

/*
 * dpa_set_tos
 *
 * Description: 
 *
 * Retrieve the current default ToS setting used when creating IP lines
 * with dpa_open_ip_line API.
 *
 * Parameters:
 *
 * tos - Pointer to the returned current ToS setting.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK. 
 * On error, the function returns DPA_FAIL.
 *
 */                          
int32_t dpa_get_tos(uint8_t *tos);

/*
 * dpa_set_voip_mode
 *
 * Description: 
 *
 * Switch IP line to VoIP mode or change VoIP parameters.
 * When changing to VOIP from FOIP, the current FOIP session is terminated.
 * 
 * When changing from VOIP to VOIP, the current ssrc and timestamp attributtes
 * are preserved.
 * 
 * tx_payload_type and rx_payload_type parameters can be used to specify
 * a non-standard RTP payload type. A special value of 0xFF indicates that
 * a standard payload type must be used.
 * 
 * rx_codec and rx_payload_type define the preferred codec in the return direction.
 * However, the actual codec is automatically chosen to match the incoming RTP packet.
 * The return direction RTP packerization time is also detected automatically based on
 * the incoming RTP packet size and its payload. 
 * 
 * Parameters:
 *
 * line_id           - ID of an IP line.
 * tx_codec          - Forward direction voice codec.
 * tx_payload_type   - Forward direction RTP payload type associated with tx_codec.
 * tx_pkt_time_ms    - Forward direction RTP packetization time, milliseconds.
 * rx_codec          - Return direction voice codec.
 * rx_payload_type   - Return direction RTP payload type associated with rx_codec.
 *
 * Returns: 
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INVALID_IP_ADDR
 *    DPA_BIND_ERROR
 *    DPA_INACTIVE_LINE
 *
 */
int32_t dpa_set_voip_mode(int32_t           line_id, 
                          dpa_codec_type_t  tx_codec,
                          uint8_t           tx_payload_type,
                          uint32_t          tx_pkt_time_ms,
                          dpa_codec_type_t  rx_codec,
                          uint8_t           rx_payload_type);

/*
 * dpa_set_foip_mode
 *
 * Description: 
 * 
 * Switch IP line to FoIP (T.38) mode.
 * When changing to FOIP from VOIP or VBD, the current session is terminated.
 *
 * Parameters:
 *
 * line_id - ID of an IP line.
 * opt     - T.38 relay options
 *
 * Returns:
 * 
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *
 */
int32_t dpa_set_foip_mode(int32_t             line_id, 
                          dpa_foip_options_t* opt);

 
/*
 * dpa_set_vbd_mode
 *
 * Description: 
 * 
 * Switch IP line to VBD (Voice-Band-Data) mode.
 * When changing to FOIP from VOIP or VBD, the current session is terminated.
 *
 * Parameters:
 * 
 * line_id - ID of an IP line.
 * params  - Voice band data mode parameters. 
 *
 * Returns:    
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INVALID_PARAM2
 *
 */
int32_t dpa_set_vbd_mode(int32_t            line_id,
                         dpa_vbd_params_t  *params);


/*
 * dpa_close_line
 *
 * Description:  
 *
 * Close active line.
 *
 * Parameters:
 *
 * line_id - ID of a phone, IP or playback line.
 *
 * Returns:    
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INACTIVE_LINE
 *
 */
int32_t dpa_close_line(int32_t line_id);

/*
 * dpa_create_call
 *
 * Description: 
 *
 * Create a voice call.
 *
 * Parameters:
 * call_id - Returned ID of a new voice call
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 */
int32_t dpa_create_call(int32_t *call_id);


/*
 * dpa_join_call()
 *
 * DESCRIPTION: 
 *       Join a voice call. At any time up to six participants are allowed in a call.
 *
 * Parameters:
 *
 * call_id  - ID of a call to join.
 * line_id  - ID of a voice line joining the call.
 *
 * RETURNS:
 *       DPA_OK   - On success.
 *       DPA_FAIL - On error. 
 *
 */
int32_t dpa_join_call(int32_t call_id, 
                      int32_t line_id);


/*
 * dpa_leave_call
 *
 * Description: Leave a voice call.
 *
 * Parameters:
 *
 * call_id - ID of a call to leave.
 * line_id - ID of a voice line leaving the call.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL. 
 *
 */
int32_t dpa_leave_call(int32_t call_id, 
                       int32_t line_id);


/*
 * dpa_destroy_call
 *
 * Description: 
 *
 * Destroy a voice call.
 *
 * Parameters:
 *
 * call_id           - ID of a call to leave
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL. 
 *
 */
int32_t dpa_destroy_call(int32_t call_id);


/*
 * dpa_tonegen_set_tone
 *
 * Description: 
 *
 * Updates Universal Tones Generation tone entry. 
 *
 * Parameters:
 *
 * line_id         - ID of a line.
 * mpath           - Media path direction to start the tone at.
 * tone_profile_id - Tone profile id (0 ... 9).
 * tone_id         - Tone ID in the tone profile (0 ... 23).
 * tone            - Generated tone parameters.
 *
 * Returns: 
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INACTIVE_LINE
 *    DPA_INVALID_PROF_ID
 *    DPA_INVALID_TONE_ID
 *    DPA_INVALID_PARAM3
 *
 */
int32_t dpa_tonegen_set_tone( int16_t profile_id,
						      int16_t tone_id, 
							  dpa_utg_tone_t *tone);


/*
 * dpa_tone_start
 *
 * Description: 
 *
 * Start playing a tone on a line. 
 *
 * Parameters:
 *
 * line_id         - ID of a line.
 * mpath           - Media path direction to start the tone at.
 * tone_profile_id - Tone profile id (0 ... 9).
 * tone_id         - Tone ID in the tone profile (0 ... 23).
 *
 * Returns: 
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INACTIVE_LINE
 *    DPA_INVALID_PROF_ID
 *    DPA_INVALID_TONE_ID
 *    DPA_INVALID_DIR
 *
 */
int32_t dpa_tone_start( int32_t          line_id, 
                        dpa_media_path_t mpath, 
                        int32_t          tone_profile_id, 
                        int32_t          tone_id);



/*
 * dpa_tone_stop
 *
 * Description: 
 *
 * Stop the tone currently playing tone on a line.
 *
 * Parameters:
 *
 * line_id - ID of a line.
 *
 * Returns: 
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INACTIVE_LINE
 *
 */
int32_t dpa_tone_stop(int32_t line_id);


/*
 * dpa_tone_detection_enable
 *
 * Description: 
 *
 * Activate tone detection on an Phone or IP lines. 
 * Detected tones info reported via DPA_EVENT_TYPE_TONE_DETECTION event
 *
 * Parameters:
 *
 * line_id         - ID of a line
 * mpath           - Media direction in the line (forward, return, both)
 * tone_profile_id - Tones profile from the configuration 
 *                   &lt;ToneDetection/Profile&gt; section
 * tone_id         - Tone from the tone profile specified by the tones profile
 * enable          -  true - Enable tone detection.
 *                    false - Disable tone detection.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INACTIVE_LINE
 *    DPA_INVALID_PROF_ID
 *
 */
int32_t dpa_tone_detection_enable(int32_t          line_id,
								  dpa_media_path_t mpath,                                   
								  int32_t          tone_profile_id,
                                  bool             enable);

/*
 * dpa_lec_enable
 *
 * Description: 
 *
 * Enable or disable line echo cancellation (LEC) on an phone line.
 *
 * Parameters:
 *
 * line_id -  ID of local phone line (0 - 63).
 * enable  -  true:  Enable LEC.
 *            false: Disable LEC.
 * 
 * Returns:    
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INACTIVE_LINE
 *
 */
int32_t dpa_lec_enable(int32_t line_id, 
                       bool    enable);


/*
 * dpa_lec_set_params
 *
 * Description: 
 * 
 * Set the LEC parameters.
 *
 * Parameters:
 * 
 * line_id         - ID of local phone interface (0 - 63)
 * dpa_lec_params  - LEC parameters.
 *
 * Returns:
 * On success, the function returns DPA_OK. 
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INACTIVE_LINE
 *    DPA_INVALID_PARAM
 *
 */

int32_t dpa_lec_set_params(int32_t line_id, dpa_lec_params_t* lec_params);

/*
 * dpa_lec_get_params
 *
 * Description: 
 * 
 * Get the current LEC parameters.
 *
 * Parameters:
 * 
 * line_id         - ID of local phone interface (0 - 63)
 * dpa_lec_params  - Returned LEC parameters.
 *
 * Returns:
 * On success, the function returns DPA_OK. 
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INACTIVE_LINE
 *    DPA_INVALID_PARAM
 *
 */
int32_t dpa_lec_get_params(int32_t line_id, dpa_lec_params_t* lec_params);

/*
 * dpa_caller_id_start
 *
 * Description:  
 *
 * Activate caller ID generation/detection on a phone interface.
 *
 * Parameters:
 * line_id        - ID of the phone interface (0 - 63)
 * cid_profile_id - Specifies the predefined caller ID generation/detection
 *                  sequence from the configuration &lt;Telephony/CallerID/Profile&gt; 
 *                  section.
 * msg            - Message to use for caller ID generation. Must be NULL 
 *                  for caller ID detection.
 *
 * Returns:    
 *             
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *                               DPA_INVALID_LINEID
 *                               DPA_API_EXEC_FAIL
 *                               DPA_NOT_INITIALIZED
 *                               DPA_INVALID_PROF_ID
 *                               DPA_INACTIVE_LINE
 *
 */
int32_t dpa_caller_id_start(int32_t       line_id, 
                            int32_t       cid_profile_id,
                            dpa_cid_msg_t *msg);


/*
 * dpa_caller_id_stop
 *
 * Description:
 * 
 * Stop caller ID generation/detection sequence on a phone interface.
 *
 * Parameters:
 *
 * line_id - ID of local phone interface (0 - 63)
 *
 * Returns:    
 *             
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INACTIVE_LINE
 *
 */
int32_t dpa_caller_id_stop(int32_t line_id);


/*
 * dpa_agc_enable
 *
 * Description:  
 * 
 * Enables AGC (Automatic Gain Control) on the specified line.
 * Additinal AGC parameters avalible in &lt;SpeechEnhancement/AGC&gt; configuration
 * section.
 *
 * Parameters:
 *
 * line_id        - ID of a line.
 * mpath          - Media path to set the gain.
 * agc_profile_id - AGC profile id.
 *
 * Returns:    
 *             
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INACTIVE_LINE
 *    DPA_INVALID_PROF_ID
 *
 */
int32_t dpa_agc_enable(int32_t          line_id, 
                       dpa_media_path_t mpath,
                       int32_t          agc_profile_id);


/*
 * dpa_set_gain
 *
 * Description: 
 *
 * Enable constant digital gain in the receive/transmit path of phone/ip/playback line.
 *
 * Parameters:
 *
 * line_id - ID of a line.
 * mpath   - Media path to set the gain. 
 * gain_db - Gain in dB (range: -32db ... + 32db).
 *           0db value is disabling gain control.
 *
 * Returns:    
 *             
 * On success, the function returns DPA_OK.
 * On error, the function returns:
 *    DPA_INVALID_LINEID
 *    DPA_API_EXEC_FAIL
 *    DPA_NOT_INITIALIZED
 *    DPA_INVALID_PARAM3
 *
 */
int32_t dpa_set_gain(int32_t          line_id, 
                     dpa_media_path_t mpath,
                     int16_t          gain_db);


/*
 * dpa_rtcp_enable:
 *
 * Description: 
 *
 * Set RTCP mode on IP line in VOIP mode.
 *
 * Parameters:
 *
 * line_id        - ID of a line.
 * mode           - RTCP mode to set.
 * local_port     - Local network port to use with RTCP.
 * remote_port    - Remote network port to use with RTCP.
 * canonical_name - RTCP canonical name.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_rtcp_enable(int32_t         line_id,
                        dpa_rtcp_mode_t mode,
                        uint16_t        local_port,
                        uint16_t        remote_port,
                        char*           canonical_name);

/*
 * dpa_get_line_stats
 *
 * Description: 
 *
 * Retrieve line statistics.
 *
 * Parameters:
 *
 * line_id - ID of a line.
 * stats   - Returned RTCP statistics.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_get_line_stats(int32_t           line_id, 
                           dpa_line_stats_t* stats);


/*
 * dpa_playback_line_write
 *
 * Description:
 * 
 * Send voice bit-stream to a playback line.
 *
 * Parameters:
 *
 * line_id         - ID of a playback line.
 * data            - Pointer to application data.
 * size            - Size in bytes of the application data.
 * remaining_space - Returned remaining size of data hat can be written.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_playback_line_write(int32_t   line_id, 
                                uint8_t*  data, 
                                uint32_t  size,
                                uint32_t* remaining_space);


/*
 * dpa_playback_line_read
 *
 * Description: 
 *
 * Receive voice bit-stream from a playback line.
 *
 * Parameters:
 *
 * line_id            - ID of a playback line.
 * data               - Pointer to application data.
 * size               - Size in bytes of the application data.
 * remaining_data_len - Returned remaining size of data that can be read.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_playback_line_read(int32_t   line_id, 
                               uint8_t*  data, 
                               uint32_t  size,
                               uint32_t* remaining_data_len);

                               
/*
 * dpa_set_voice_quality_alarm
 *
 * Description: 
 *
 * Enable Voice Quality Monitoring according to G.107 specification
 * requirements.
 *
 * Parameters:
 *
 * line_id                   - ID of IP line in VoIP mode.
 * params                    - Params for the voice quality alarm.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_set_voice_quality_alarm(int32_t line_id,
                                    dpa_voice_quality_alarm_params_t* params);

                                    
/*
 * dpa_set_jb_params
 *
 * Description: 
 *
 * Set jitter buffer operation mode on a IP line.
 *
 * Parameters:
 *
 * line_id   - ID of a remote voice line.
 * params    - Jitter buffer configuration parameters
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_set_jb_params(int32_t         line_id, 
                          dpa_jb_params_t* params);


/*
 * dpa_get_jb_params()
 *
 * Description: Get jitter buffer operation mode on a IP line.
 *
 * Parameters:
 * line_id - ID of a remote voice line
 * mode    - Returned jitter buffer operation mode
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_get_jb_params(int32_t          line_id, 
                          dpa_jb_params_t* params);


/*
 * dpa_get_jb_stats
 *
 * Description: 
 *
 * Get jitter buffer statistics.
 *
 * Parameters:
 *
 * line_id - ID of a remote voice line
 * stats    - Returned jitter buffer stats.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_get_jb_stats(int32_t        line_id, 
                        dpa_jb_stats_t* stats);


/*
 * dpa_rfc2833_enable
 *
 * Description: 
 *
 * Enable DTMF signaling transport for a remote voice line.
 *
 * Parameters:
 *
 * line_id - ID of a remote voice line.
 * mode    - DTMF transport mode.
 * rx_pt   - Incoming RTP payload type for DTMF. 
 * tx_pt   - Outgoing RTP payload type for DTMF. 
 *
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_rfc2833_enable(int32_t            line_id, 
                           dpa_rfc2833_mode_t mode, 
                           uint8_t            rx_pt, 
                           uint8_t            tx_pt);


/*
 * dpa_silence_suppression_enable
 *
 * Description: 
 *
 * Enable or disable silence suppression for a remote voice line.
 *
 * Parameters:
 *
 * line_id - ID of a remote voice line.
 * mode    - Silence suppression mode.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_silence_suppression_enable(int32_t                  line_id,
                                       dpa_silence_suppr_mode_t mode);


/*
 * dpa_get_call_id
 *
 * Description: 
 *
 * Return the call ID associated with a line.
 *
 * Parameters:
 *
 * line_id - ID of a line.
 * call_id - Returned ID of an associated call or -1 if the line is not 
 *           part of a call.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_get_call_id(int32_t  line_id, 
                        int32_t* call_id);


/*
 * dpa_get_active_calls_num
 *
 * Description:
 *
 * Retrieve the number of currently active calls.
 *
 * Parameters:
 *
 * None.
 *
 * Returns:
 *
 * The number of currently active calls or 0 if there are no calls.
 */
int32_t dpa_get_active_calls_num(void);


/*
 * dpa_get_active_calls
 *
 * Description: 
 *
 * Retrieve the list of currently active calls.
 *
 * Parameters:
 *
 * calls - Pointer to application array which receives the call IDs.
 * size  - The number of elements in the calls array. 
 *         Upon return, size will contain the actual number calls.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_get_active_calls(int32_t calls[], 
                             int32_t* size);

/* 
 * dpa_get_lines
 *
 * Description:  
 *
 * Retrieve the list of active media lines.
 *
 * Parameters:
 *
 * call_id - ID of the call of participating lines, or -1 for all active lines.
 * lines   - Array to receive the list of line IDs.
 * size    - The number of elements in the lines array.
 *           Upon return, size will contain the actual number 
 *           of line IDs present in the lines array.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_get_lines(int32_t call_id, 
                      int32_t lines[], 
                      int32_t *size);

                      
/*
 * dpa_get_line_info
 *
 * Description: 
 * 
 * Retrieve information of an active media line.
 *
 * Parameters:
 *
 * line_id   - ID of a media line.
 * line_info - Pointer to application structure to receieve the info.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_get_line_info(int32_t          line_id, 
                          dpa_line_info_t* line_info);


/*
 * dpa_register_events
 *
 * Description: 
 *
 * Register application callbacks to receive DPA events.
 *
 * Parameters:
 * event_mask     - Mask of the events the applications is interested in.
 * event_handler  - Application callback function. 
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_register_events(dpa_event_mask_t event_mask, dpa_event_handler_t* event_handler);


/*
 * dpa_get_version()
 *
 * Description: 
 *              
 * Retrieve DPA version.
 *
 * Parameters:
 * 
 * None.
 *
 * Returns:
 *
 * On success, the function returns a string with DPA version.
 * On error, the function returns NULL.
 *
 */
const char* dpa_get_version(void);

/*
 * dpa_enable_media_path:
 *
 * Description: 
 *
 * Enable or disable media processing in the specified direction of a media line.
 *
 * Parameters:
 *
 * line_id - ID of a line.
 * path    - Media direction.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_enable_media_path(int32_t          line_id, 
                              dpa_media_path_t path);


/*
 * dpa_set_ssrc
 *
 * Description:
 *
 * Set RTP session synchronization source for an IP line in VoIP mode. 
 *
 * Parameters:
 * 
 * line_id - ID of a line.
 * ssrc    - Session synchronization source.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 * 
 */
int32_t dpa_set_ssrc(int32_t  line_id, 
                     uint32_t ssrc);


/*
 * dpa_get_ssrc
 *
 * Description: 
 *
 * Retrieve RTP session synchronization source of an IP line in VoIP mode. 
 *
 * Parameters:
 * 
 * line_id - ID of a line.
 * ssrc    - Returned session synchronization source.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_get_ssrc(int32_t   line_id, 
                     uint32_t* ssrc);



/*
 * dpa_set_loopback
 *
 * Description: 
 *
 * Create or destroy a loopback between two lines.
 *
 * Parameters:
 * 
 * line_id1 - ID of line1.
 * line_id2 - ID of line2
 * loopback_point - Where to do loopback.
 * status - enable/disable
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_set_loopback(int32_t              line_id1,
                         int32_t              line_id2,
                         dpa_loopback_point_t loopback_point,
                         bool                 status);



/*
</Insert>
<Copy StartSeek="1267" EndSeek="1562"/>
<Insert>
/*
 * dpa_set_rfc2833_event
 *
 * Description: 
 *
 * Set rfc2833 translation
 *
 * Parameters:
 * 
 * direction  - Direction.
 * event_id   - Event id according to rfc 2833
 * profile_id - Tone profile id.
 * tone_id    - Tone id.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
int32_t dpa_set_rfc2833_event(dpa_media_path_t direction,
                              int32_t          event_id,
                              int32_t          profile_id,
                              int32_t          tone_id);




</Insert>
<Copy StartSeek="1562" EndSeek="1835"/>
<Insert>


</Insert>
<Copy StartSeek="1835" EndSeek="2107"/>
<Insert>
/*
 * dpa_set_rfc2198_params
 *
 * Description: 
 *
 * Set rfc2198 parameters
 *
 * Parameters:
 * 
 * line_id        - line id
 * params         - rfc2198 parameters
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 *
 */
  int32_t dpa_set_rfc2198_params(int32_t line_id, dpa_rfc2198_params_t* params);




/*
 * dpa_get_rfc2198_params
 *
 * Description: 
 *
 * Get rfc2198 parameters
 *
 * Parameters:
 * 
 * line_id        - line id 
 * params         - rfc2198 parameters
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 *
 */
int32_t dpa_get_rfc2198_params(int32_t line_id, dpa_rfc2198_params_t* params);






/*
 * dpa_set_packet_capture_params
 *
 * Description: 
 *
 * Set packet capture parameters
 *
 * Parameters:
 * 
 * 
 * params         - packet capture parameters
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 *
 */
int32_t dpa_set_packet_capture_params(dpa_packet_capture_params_t* params);




/*
 * dpa_get_packet_capture_params
 *
 * Description: 
 *
 * Get packet capture parameters
 *
 * Parameters:
 * 
 * 
 * params         - packet capture parameters
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 *
 */
int32_t dpa_get_packet_capture_params(dpa_packet_capture_params_t* params);



/*
 * dpa_set_capture_point_status
 *
 * Description: 
 *
 * Set capture point status
 *
 * Parameters:
 * 
 * 
 * id          - id of capture point
 * status      - Enable/Disable
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 *
 */
int32_t dpa_set_capture_point_status(dpa_capture_point_t id, bool status);



/*
 * dpa_get_capture_point_status
 *
 * Description: 
 *
 * Get capture point status
 *
 * Parameters:
 * 
 * 
 * id        - id of capture point
 * status    - Enable/Disable
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 *
 */
int32_t dpa_get_capture_point_status(dpa_capture_point_t id, bool* status);



/*
 * dpa_set_log_params
 *
 * Description: 
 *
 * Set log parameters
 *
 * Parameters:
 * 
 * 
 * params         - log parameters
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 *
 */
int32_t dpa_set_log_params(dpa_log_params_t* params);



/*
 * dpa_get_log_params
 *
 * Description: 
 *
 * Get log parameters
 *
 * Parameters:
 * 
 * 
 * params         - log parameters
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 *
 */
int32_t dpa_get_log_params(dpa_log_params_t* params);



</Insert>
<Copy StartSeek="2107" EndSeek="2145"/>
</Delta>
<Delta Version="3" Comment="" NL="\10" Encoding="text" Date="2012/03/22" Time="11:08:12000">
<Copy StartSeek="0" EndSeek="1767"/>
<Insert>  int32_t dpa_set_log_level(dpa_log_unit_t id, int32_t log_level);
</Insert>
<Copy StartSeek="1832" EndSeek="2105"/>
<Copy StartSeek="2325" EndSeek="2363"/>
</Delta>
<Delta Version="4" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="09:53:35000">
<Copy StartSeek="0" EndSeek="2220"/>
<Insert>int  nfp_bridge_is_aging_enabled(void);
</Insert>
<Copy StartSeek="2259" EndSeek="2362"/>
</Delta>
<Delta Version="5" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="09:54:2000">
<Copy StartSeek="0" EndSeek="2140"/>
<Insert>int  nfp_bridge_is_learning_enabled(void);
</Insert>
<Copy StartSeek="2182" EndSeek="2361"/>
</Delta>
<Delta Version="6" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="09:54:50000">
<Copy StartSeek="0" EndSeek="2105"/>
<Insert>#ifdef CONFIG_MV_ETH_NFP_FDB_LEARN
int nfp_bridge_is_learning_enabled(void);
int nfp_bridge_learn_enable(int en);
int nfp_bridge_is_aging_enabled(void);
int nfp_bridge_age_enable(int en);
</Insert>
<Copy StartSeek="2293" EndSeek="2361"/>
</Delta>
<Delta Version="7" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="09:55:3000">
<Copy StartSeek="0" EndSeek="2322"/>
<Insert>
</Insert>
<Copy StartSeek="3496" EndSeek="3534"/>
</Delta>
<Delta Version="8" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="09:56:4000">
<Copy StartSeek="0" EndSeek="3493"/>
<Insert>


#ifdef __cplusplus
}
</Insert>
<Copy StartSeek="3493" EndSeek="3502"/>
<Copy StartSeek="3523" EndSeek="3531"/>
</Delta>
<Delta Version="9" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="09:57:6000">
<Copy StartSeek="0" EndSeek="2521"/>
<Insert>int dpa_fdb_rule_add(int br_index, int if_index, u8 *mac, bool is_local);
int dpa_fdb_rule_age(int br_index, u8 *mac);
int dpa_fdb_rule_del(int br_index, u8 *mac);
</Insert>
<Copy StartSeek="2700" EndSeek="2738"/>
<Insert>int dpa_bridge_rule_add(u8 *sa, u8 *da, int iif, int oif);
int dpa_bridge_rule_del(u8 *sa, u8 *da, int iif);
int dpa_bridge_rule_age(u8 *sa, u8 *da, int iif);
</Insert>
<Copy StartSeek="2927" EndSeek="3006"/>
<Insert>int dpa_bridge_vlan_prio_set(u8 *sa, u8 *da, int iif, int eth_type, int vlan_prio);
int dpa_bridge_vlan_prio_del(u8 *sa, u8 *da, int iif, int eth_type);
int dpa_bridge_txq_set(u8 *sa, u8 *da, int iif, int txq);
int dpa_bridge_txq_del(u8 *sa, u8 *da, int iif);
int dpa_bridge_txp_set(u8 *sa, u8 *da, int iif, int txp);
int dpa_bridge_txp_del(u8 *sa, u8 *da, int iif);
int dpa_bridge_mh_set(u8 *sa, u8 *da, int iif, u16 mh);
int dpa_bridge_mh_del(u8 *sa, u8 *da, int iif);
</Insert>
<Copy StartSeek="3557" EndSeek="3659"/>
</Delta>
<Delta Version="10" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:05:49000">
<Copy StartSeek="0" EndSeek="3433"/>
<Insert>int dpa_bridge_mh_set(uint8_t *sa, uint8_t *da, int iif, u16 mh);
</Insert>
<Copy StartSeek="3504" EndSeek="3664"/>
</Delta>
<Delta Version="11" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:06:22000">
<Copy StartSeek="0" EndSeek="2478"/>
<Insert>#ifdef DPA_FDB_MODE
/* Add/Del FDB rule */
int dpa_fdb_rule_add(int br_index, int if_index, uint8_t *mac, bool is_local);
int dpa_fdb_rule_age(int br_index, uint8_t *mac);
int dpa_fdb_rule_del(int br_index, uint8_t *mac);
#else
</Insert>
<Copy StartSeek="2479" EndSeek="2700"/>
<Insert>#endif /* DPA_FDB_MODE */
</Insert>
<Copy StartSeek="2701" EndSeek="2702"/>
<Insert>#if defined(DPA_CLASSIFY) &amp;&amp; !defined(DPA_FDB_MODE)
</Insert>
<Copy StartSeek="2702" EndSeek="3258"/>
<Insert>#endif /* defined(DPA_CLASSIFY) &amp;&amp; !defined(DPA_FDB_MODE) */
</Insert>
<Copy StartSeek="3259" EndSeek="3300"/>
</Delta>
<Delta Version="12" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:07:28000">
<Copy StartSeek="0" EndSeek="2140"/>
<Insert>int dpa_bridge_is_learning_enabled(void);
int dpa_bridge_learn_enable(int en);
int dpa_bridge_is_aging_enabled(void);
int dpa_bridge_age_enable(int en);
</Insert>
<Copy StartSeek="2317" EndSeek="2364"/>
<Insert>int dpa_if_to_bridge_add(int bridge_if, int port_if);
int dpa_if_to_bridge_del(int bridge_if, int port_if);
</Insert>
<Copy StartSeek="2496" EndSeek="2559"/>
<Insert>int dpa_bridge_rule_add(uint8_t *sa, uint8_t *da, int iif, int oif);
int dpa_bridge_rule_del(uint8_t *sa, uint8_t *da, int iif);
int dpa_bridge_rule_age(uint8_t *sa, uint8_t *da, int iif);
</Insert>
<Copy StartSeek="2776" EndSeek="2778"/>
<Insert>int dpa_bridge_vlan_prio_set(uint8_t *sa, uint8_t *da, int iif, int eth_type, int vlan_prio);
int dpa_bridge_vlan_prio_del(uint8_t *sa, uint8_t *da, int iif, int eth_type);
int dpa_bridge_txq_set(uint8_t *sa, uint8_t *da, int iif, int txq);
int dpa_bridge_txq_del(uint8_t *sa, uint8_t *da, int iif);
int dpa_bridge_txp_set(uint8_t *sa, uint8_t *da, int iif, int txp);
int dpa_bridge_txp_del(uint8_t *sa, uint8_t *da, int iif);
int dpa_bridge_mh_set(uint8_t *sa, uint8_t *da, int iif, uint16_t mh);
int dpa_bridge_mh_del(uint8_t *sa, uint8_t *da, int iif);
</Insert>
<Copy StartSeek="3418" EndSeek="3460"/>
</Delta>
<Delta Version="13" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:08:28000">
<Copy StartSeek="0" EndSeek="2778"/>
<Insert>int32_t dpa_bridge_vlan_prio_set(uint8_t *sa, uint8_t *da, int32_t iif, int32_t eth_type, int32_t vlan_prio);
int32_t dpa_bridge_vlan_prio_del(uint8_t *sa, uint8_t *da, int32_t iif, int32_t eth_type);
</Insert>
<Copy StartSeek="2991" EndSeek="3472"/>
</Delta>
<Delta Version="14" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:09:1000">
<Copy StartSeek="0" EndSeek="2105"/>
<Copy StartSeek="2108" EndSeek="3434"/>
<Insert>#endif
</Insert>
<Copy StartSeek="3458" EndSeek="3492"/>
</Delta>
<Delta Version="15" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:09:39000">
<Copy StartSeek="0" EndSeek="2341"/>
<Insert>#endif
</Insert>
<Copy StartSeek="2382" EndSeek="3526"/>
</Delta>
<Delta Version="16" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:09:49000">
<Copy StartSeek="0" EndSeek="2815"/>
<Insert>int32_t dpa_bridge_vlan_prio_set(uint8_t *sa, uint8_t *da, int32_t iif, 
				 int32_t eth_type, int32_t vlan_prio);
int32_t dpa_bridge_vlan_prio_del(uint8_t *sa, uint8_t *da, int32_t iif, 
				 int32_t eth_type);
</Insert>
<Copy StartSeek="2980" EndSeek="3478"/>
</Delta>
<Delta Version="17" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:12:6000">
<Copy StartSeek="0" EndSeek="3419"/>
<Insert>
</Insert>
<Copy StartSeek="3419" EndSeek="3477"/>
</Delta>
<Delta Version="18" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:12:51000">
<Copy StartSeek="0" EndSeek="2563"/>
<Insert>
</Insert>
<Copy StartSeek="2563" EndSeek="2813"/>
<Insert>
</Insert>
<Copy StartSeek="2813" EndSeek="3475"/>
</Delta>
<Delta Version="19" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:12:57000">
<Copy StartSeek="0" EndSeek="2108"/>
<Insert>#ifdef CONFIG_MV_ETH_DPA_FDB_LEARN
</Insert>
<Copy StartSeek="2126" EndSeek="2324"/>
<Insert>#endif /* CONFIG_MV_ETH_DPA_FDB_LEARN */
</Insert>
<Copy StartSeek="2325" EndSeek="2326"/>
<Insert>#ifdef DPA_BRIDGE
</Insert>
<Copy StartSeek="2326" EndSeek="3400"/>
</Delta>
<Delta Version="20" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:13:38000">
<Copy StartSeek="0" EndSeek="2325"/>
<Insert>
</Insert>
<Copy StartSeek="2325" EndSeek="3399"/>
</Delta>
<Delta Version="21" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:13:41000">
<Copy StartSeek="0" EndSeek="2217"/>
<Insert>int32_t dpa_bridge_is_aging_enabled(void);
int32_t dpa_bridge_age_enable(int32_t en);
</Insert>
<Copy StartSeek="2217" EndSeek="3313"/>
</Delta>
<Delta Version="22" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:16:49000">
<Copy StartSeek="0" EndSeek="2401"/>
<Insert>/* Add/Del/Age bridging rule */
</Insert>
<Copy StartSeek="2429" EndSeek="2578"/>
<Insert>int32_t dpa_bridge_rule_age(uint8_t *sa, uint8_t *da, int32_t iif);

</Insert>
<Copy StartSeek="2579" EndSeek="3241"/>
</Delta>
<Delta Version="23" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:18:33000">
<Copy StartSeek="0" EndSeek="3208"/>
<Insert>
</Insert>
<Copy StartSeek="3859" EndSeek="3891"/>
</Delta>
<Delta Version="24" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:22:48000">
<Copy StartSeek="0" EndSeek="2579"/>
<Copy StartSeek="2595" EndSeek="2760"/>
<Copy StartSeek="2782" EndSeek="3929"/>
</Delta>
<Delta Version="25" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:23:5000">
<Copy StartSeek="0" EndSeek="3517"/>
<Insert>
</Insert>
<Copy StartSeek="3517" EndSeek="3928"/>
</Delta>
<Delta Version="26" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:23:15000">
<Copy StartSeek="0" EndSeek="3655"/>
<Insert>
</Insert>
<Copy StartSeek="3655" EndSeek="3927"/>
</Delta>
<Delta Version="27" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:23:27000">
<Copy StartSeek="0" EndSeek="3679"/>
<Insert>int dpa_vlan_pvid_set(int if_index, u16 pvid);
int dpa_vlan_vid_set(int if_index, u16 vid);
int dpa_vlan_rx_mode_set(int if_index, int mode);
int dpa_vlan_tx_mode_set(int if_index, int mode);
</Insert>
<Copy StartSeek="3921" EndSeek="3977"/>
</Delta>
<Delta Version="28" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:24:47000">
<Copy StartSeek="0" EndSeek="2107"/>
<Insert>
</Insert>
<Copy StartSeek="2107" EndSeek="3976"/>
</Delta>
<Delta Version="29" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:25:58000">
<Copy StartSeek="0" EndSeek="2171"/>
<Insert>int32_t dpa_bridge_learn_enable(int32_t en);
</Insert>
<Copy StartSeek="2213" EndSeek="3973"/>
</Delta>
<Delta Version="30" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:31:22000">
<Copy StartSeek="0" EndSeek="2125"/>
<Insert>int32_t dpa_bridge_is_learning_enabled(void);
</Insert>
<Copy StartSeek="2125" EndSeek="2167"/>
<Copy StartSeek="2213" EndSeek="3973"/>
</Delta>
<Delta Version="31" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:31:31000">
<Copy StartSeek="0" EndSeek="2213"/>
<Insert>void fdb_sync(void);

</Insert>
<Copy StartSeek="2214" EndSeek="3952"/>
</Delta>
<Delta Version="32" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:31:40000">
<Copy StartSeek="0" EndSeek="2214"/>
<Insert>int32_t dpa_if_to_bridge_add(int32_t bridge_if, int32_t port_if);
int32_t dpa_if_to_bridge_del(int32_t bridge_if, int32_t port_if);
</Insert>
<Copy StartSeek="2339" EndSeek="3945"/>
</Delta>
<Delta Version="33" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:32:3000">
<Copy StartSeek="0" EndSeek="2277"/>
<Insert>int32_t dpa_brige_if_del(int32_t bridge_if, int32_t port_if);
</Insert>
<Copy StartSeek="2340" EndSeek="3946"/>
</Delta>
<Delta Version="34" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:32:9000">
<Copy StartSeek="0" EndSeek="2340"/>
<Insert>void dpa_bridge_clean(void);
</Insert>
<Copy StartSeek="2369" EndSeek="3946"/>
</Delta>
<Delta Version="35" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:33:31000">
<Copy StartSeek="0" EndSeek="2548"/>
<Insert>#ifdef DPA_VLAN
int32_t dpa_bridge_vlan_prio_set(uint8_t *sa, uint8_t *da, int32_t iif, int32_t vlan_prio);
int32_t dpa_bridge_vlan_prio_del(uint8_t *sa, uint8_t *da, int32_t iif);
#endif /* DPA_VLAN */
</Insert>
<Copy StartSeek="2548" EndSeek="3743"/>
</Delta>
<Delta Version="36" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="10:50:45000">
<Copy StartSeek="0" EndSeek="2214"/>
<Insert>int32_t dpa_bridge_if_add(int32_t bridge_if, int32_t port_if);
int32_t dpa_bridge_if_del(int32_t bridge_if, int32_t port_if);
</Insert>
<Copy StartSeek="2334" EndSeek="3737"/>
</Delta>
<Delta Version="37" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:05:21000">
<Copy StartSeek="0" EndSeek="2214"/>
<Insert>int32_t dpa_bridge_if_add(int32_t bridge, int32_t port_if);
int32_t dpa_bridge_if_del(int32_t bridge, int32_t port_if);
</Insert>
<Copy StartSeek="2328" EndSeek="3731"/>
</Delta>
<Delta Version="38" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:05:45000">
<Copy StartSeek="0" EndSeek="2358"/>
<Copy StartSeek="2548" EndSeek="3921"/>
</Delta>
<Delta Version="39" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:08:41000">
<Copy StartSeek="0" EndSeek="2521"/>
<Insert>#endif /* NFP_CLASSIFY */
</Insert>
<Copy StartSeek="2523" EndSeek="3897"/>
</Delta>
<Delta Version="40" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:08:50000">
<Copy StartSeek="0" EndSeek="2358"/>
<Insert>typedef struct dpa_bridge_rule {
</Insert>
<Copy StartSeek="2383" EndSeek="2513"/>
<Insert>}
</Insert>
<Copy StartSeek="2516" EndSeek="3890"/>
</Delta>
<Delta Version="41" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:09:1000">
<Copy StartSeek="0" EndSeek="2383"/>
<Insert>	MV_U8	da[MV_MAC_ADDR_SIZE];
	MV_U8	sa[MV_MAC_ADDR_SIZE];
	int	iif;
	int	oif;
</Insert>
<Copy StartSeek="2473" EndSeek="3902"/>
</Delta>
<Delta Version="42" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:10:13000">
<Copy StartSeek="0" EndSeek="2445"/>
<Insert>	int32_t	iif;
	int32_t	oif;
</Insert>
<Copy StartSeek="2475" EndSeek="3904"/>
</Delta>
<Delta Version="43" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:10:20000">
<Copy StartSeek="0" EndSeek="2475"/>
<Insert>	MV_U32	flags;
</Insert>
<Copy StartSeek="2492" EndSeek="3906"/>
</Delta>
<Delta Version="44" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:10:28000">
<Copy StartSeek="0" EndSeek="2492"/>
<Insert>	MV_U8	txq;
</Insert>
<Copy StartSeek="2506" EndSeek="3908"/>
</Delta>
<Delta Version="45" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:10:35000">
<Copy StartSeek="0" EndSeek="2506"/>
<Insert>	MV_U8	txp;
</Insert>
<Copy StartSeek="2520" EndSeek="3910"/>
</Delta>
<Delta Version="46" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:10:41000">
<Copy StartSeek="0" EndSeek="2520"/>
<Insert>	MV_U16  mh;
</Insert>
<Copy StartSeek="2534" EndSeek="3911"/>
</Delta>
<Delta Version="47" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:10:49000">
<Copy StartSeek="0" EndSeek="2492"/>
<Insert>	uint8_t	txq;
	uint8_t	txp;
	uint16_t mh;
</Insert>
<Copy StartSeek="2492" EndSeek="3869"/>
</Delta>
<Delta Version="48" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:11:48000">
<Copy StartSeek="0" EndSeek="2383"/>
<Insert>	uint8_t	da[MV_MAC_ADDR_SIZE];
	uint8_t	sa[MV_MAC_ADDR_SIZE];
</Insert>
<Copy StartSeek="2411" EndSeek="3835"/>
</Delta>
<Delta Version="49" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:13:0000">
<Copy StartSeek="0" EndSeek="2358"/>
<Insert>struct dpa_bridge_rule {
</Insert>
<Copy StartSeek="2391" EndSeek="2466"/>
<Insert>};
</Insert>
<Copy StartSeek="2487" EndSeek="3861"/>
</Delta>
<Delta Version="50" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:13:44000">
<Copy StartSeek="0" EndSeek="2516"/>
<Insert>int32_t dpa_bridge_rule_add(uint8_t *sa, uint8_t *da, int32_t iif, int32_t oif);
int32_t dpa_bridge_rule_del(uint8_t *sa, uint8_t *da, int32_t iif);
</Insert>
<Copy StartSeek="2624" EndSeek="3820"/>
</Delta>
<Delta Version="51" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:13:57000">
<Copy StartSeek="0" EndSeek="2391"/>
<Copy StartSeek="2408" EndSeek="2466"/>
<Insert>	uint32_t flags;
</Insert>
<Copy StartSeek="2468" EndSeek="3822"/>
</Delta>
<Delta Version="52" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:14:29000">
<Copy StartSeek="0" EndSeek="2466"/>
<Insert>	
</Insert>
<Copy StartSeek="2466" EndSeek="3820"/>
</Delta>
<Delta Version="53" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:14:32000">
<Copy StartSeek="0" EndSeek="2625"/>
<Insert>int32_t dpa_bridge_txq_set(uint8_t *sa, uint8_t *da, int32_t iif, int32_t txq);
int32_t dpa_bridge_txq_del(uint8_t *sa, uint8_t *da, int32_t iif);
int32_t dpa_bridge_txp_set(uint8_t *sa, uint8_t *da, int32_t iif, int32_t txp);
int32_t dpa_bridge_txp_del(uint8_t *sa, uint8_t *da, int32_t iif);
int32_t dpa_bridge_mh_set(uint8_t *sa, uint8_t *da, int32_t iif, uint16_t mh);
int32_t dpa_bridge_mh_del(uint8_t *sa, uint8_t *da, int32_t iif);
</Insert>
<Copy StartSeek="2625" EndSeek="3381"/>
</Delta>
<Delta Version="54" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:14:55000">
<Copy StartSeek="0" EndSeek="2624"/>
<Insert>
</Insert>
<Copy StartSeek="2624" EndSeek="3380"/>
</Delta>
<Delta Version="55" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:15:26000">
<Copy StartSeek="0" EndSeek="2125"/>
<Insert>int32_t dpa_bridge_learn_set(int32_t en);
int32_t dpa_bridge_is_learning_enabled(void);

</Insert>
<Copy StartSeek="2125" EndSeek="2535"/>
<Copy StartSeek="2624" EndSeek="3380"/>
</Delta>
<Delta Version="56" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:15:45000">
<Copy StartSeek="0" EndSeek="2535"/>
<Insert>
int32_t dpa_bridge_learn_set(int32_t en);
int32_t dpa_bridge_is_learning_enabled(void);
</Insert>
<Copy StartSeek="2535" EndSeek="3291"/>
</Delta>
<Delta Version="57" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:15:52000">
<Copy StartSeek="0" EndSeek="1012"/>
<Insert>int32_t dpa_init(const char* dpa_config);
</Insert>
<Copy StartSeek="1057" EndSeek="3294"/>
</Delta>
<Delta Version="58" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:17:35000">
<Copy StartSeek="0" EndSeek="2272"/>
<Copy StartSeek="2344" EndSeek="2377"/>
<Insert>	uint32_t flags;
</Insert>
<Copy StartSeek="2400" EndSeek="3372"/>
</Delta>
<Delta Version="59" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:21:29000">
<Copy StartSeek="0" EndSeek="2314"/>
<Insert>} MV_DPA_BRIDGE_RULE_FLAGS;
</Insert>
<Copy StartSeek="2336" EndSeek="3366"/>
</Delta>
<Delta Version="60" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:21:31000">
<Copy StartSeek="0" EndSeek="2287"/>
<Insert>	MV_DPA_BR_RULE_DROP	= 1,

</Insert>
<Copy StartSeek="2339" EndSeek="3391"/>
</Delta>
<Delta Version="61" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:22:14000">
<Copy StartSeek="0" EndSeek="2396"/>
<Insert>	MV_DPA_BR_RULE flags;
</Insert>
<Copy StartSeek="2433" EndSeek="3405"/>
</Delta>
<Delta Version="62" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:22:31000">
<Copy StartSeek="0" EndSeek="2396"/>
<Insert>	MV_DPA_BR_RULE flags; /*bitfield */
</Insert>
<Copy StartSeek="2434" EndSeek="3406"/>
</Delta>
<Delta Version="63" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:22:33000">
<Copy StartSeek="0" EndSeek="2338"/>
<Insert>
</Insert>
<Copy StartSeek="2338" EndSeek="3405"/>
</Delta>
<Delta Version="64" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:22:38000">
<Copy StartSeek="0" EndSeek="3287"/>
<Insert>int32_t dpa_vlan_tx_mode_set(int32_t if_index, int32_t mode);
</Insert>
<Copy StartSeek="3361" EndSeek="3417"/>
</Delta>
<Delta Version="65" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:24:48000">
<Copy StartSeek="0" EndSeek="2945"/>
<Insert>} MV_DPA_VLAN_RX_MODE;
</Insert>
<Copy StartSeek="2968" EndSeek="3225"/>
<Insert>int32_t dpa_vlan_rx_mode_set(int32_t if_index, int32_t mode);
</Insert>
<Copy StartSeek="3299" EndSeek="3429"/>
</Delta>
<Delta Version="66" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:24:53000">
<Copy StartSeek="0" EndSeek="2108"/>
<Insert>

</Insert>
<Copy StartSeek="2108" EndSeek="3427"/>
</Delta>
<Delta Version="67" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:25:10000">
<Copy StartSeek="0" EndSeek="2647"/>
<Copy StartSeek="2684" EndSeek="3464"/>
</Delta>
<Delta Version="68" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:31:52000">
<Copy StartSeek="0" EndSeek="2684"/>
<Copy StartSeek="2685" EndSeek="3465"/>
</Delta>
<Delta Version="69" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:31:56000">
<Copy StartSeek="0" EndSeek="2647"/>
<Insert>/* HAIM: TODO define print method */

</Insert>
<Copy StartSeek="2683" EndSeek="3463"/>
</Delta>
<Delta Version="70" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:32:9000">
<Copy StartSeek="0" EndSeek="3430"/>
<Insert>
</Insert>
<Copy StartSeek="3453" EndSeek="3485"/>
</Delta>
<Delta Version="71" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:33:21000">
<Copy StartSeek="0" EndSeek="3430"/>
<Insert>#ifdef DPA_FIB
</Insert>
<Copy StartSeek="3451" EndSeek="3491"/>
</Delta>
<Delta Version="72" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:34:28000">
<Copy StartSeek="0" EndSeek="3450"/>
<Insert>
#endif

</Insert>
<Copy StartSeek="3523" EndSeek="3555"/>
</Delta>
<Delta Version="73" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:37:7000">
<Copy StartSeek="0" EndSeek="2979"/>
<Insert>} MV_DPA_VLAN_TX_MODE;
</Insert>
<Copy StartSeek="3002" EndSeek="3117"/>
<Insert>} MV_DPA_VLAN_TX_MODE;
</Insert>
<Copy StartSeek="3140" EndSeek="3259"/>
<Insert>int32_t dpa_vlan_rx_mode_set(int32_t if_index, MV_DPA_VLAN_TX_MODE mode);
</Insert>
<Copy StartSeek="3333" EndSeek="3450"/>
<Insert>uint32_t mvNfpFibRuleAdd(NFP_RULE_FIB *fib2)
</Insert>
<Copy StartSeek="3496" EndSeek="3556"/>
</Delta>
<Delta Version="74" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:38:13000">
<Copy StartSeek="0" EndSeek="3333"/>
<Insert>int32_t dpa_vlan_tx_mode_set(int32_t if_index, MV_DPA_VLAN_TX_MODE mode);
</Insert>
<Copy StartSeek="3407" EndSeek="3556"/>
</Delta>
<Delta Version="75" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:38:19000">
<Copy StartSeek="0" EndSeek="3450"/>
<Insert>uint32_t dpa_fwd_rule_add(NFP_RULE_FIB *fib2)
</Insert>
<Copy StartSeek="3499" EndSeek="3559"/>
</Delta>
<Delta Version="76" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:40:59000">
<Copy StartSeek="0" EndSeek="3450"/>
<Insert>uint32_t dpa_l3_fwd_rule_add(NFP_RULE_FIB *fib2)
</Insert>
<Copy StartSeek="3498" EndSeek="3558"/>
</Delta>
<Delta Version="77" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:41:4000">
<Copy StartSeek="0" EndSeek="3450"/>
<Insert>uint32_t dpa_l3fwd_rule_add(NFP_RULE_FIB *fib2)
</Insert>
<Copy StartSeek="3495" EndSeek="3555"/>
</Delta>
<Delta Version="78" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:41:21000">
<Copy StartSeek="0" EndSeek="3450"/>
<Insert>uint32_t dpa_l3_rule_add(NFP_RULE_FIB *fib2)
</Insert>
<Copy StartSeek="3496" EndSeek="3556"/>
</Delta>
<Delta Version="79" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:41:35000">
<Copy StartSeek="0" EndSeek="3450"/>
<Copy StartSeek="3728" EndSeek="3834"/>
</Delta>
<Delta Version="80" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:46:56000">
<Copy StartSeek="0" EndSeek="3450"/>
<Insert>typedef struct nfp_rule_fib {
</Insert>
<Copy StartSeek="3480" EndSeek="3688"/>
<Insert>} nfp_rule_fib_t;
#endif /* NFP_FIB */
</Insert>
<Copy StartSeek="3727" EndSeek="3728"/>
<Insert>uint32_t dpa_fib_rule_add(NFP_RULE_FIB *fib2)
</Insert>
<Copy StartSeek="3774" EndSeek="3834"/>
</Delta>
<Delta Version="81" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:47:3000">
<Copy StartSeek="0" EndSeek="3493"/>
<Insert>	MV_U8	srcL3[MV_MAX_L3_ADDR_SIZE];
	MV_U8	dstL3[MV_MAX_L3_ADDR_SIZE];
	MV_U8	da[MV_MAC_ADDR_SIZE];
	MV_U8	sa[MV_MAC_ADDR_SIZE];
	MV_U8	defGtwL3[MV_MAX_L3_ADDR_SIZE];
	MV_U32	flags;
</Insert>
<Copy StartSeek="3686" EndSeek="3846"/>
</Delta>
<Delta Version="82" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:47:37000">
<Copy StartSeek="0" EndSeek="3718"/>
<Copy StartSeek="3767" EndSeek="3789"/>
<Insert>uint32_t dpa_fib_rule_add(DPA_RULE_FIB *fib2)
</Insert>
<Copy StartSeek="3790" EndSeek="3850"/>
</Delta>
<Delta Version="83" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:47:50000">
<Copy StartSeek="0" EndSeek="3719"/>
<Insert>uint32_t dpa_fib_rule_add(dpa_rule_fib_t *fib2)
</Insert>
<Copy StartSeek="3766" EndSeek="3849"/>
</Delta>
<Delta Version="84" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:47:52000">
<Copy StartSeek="0" EndSeek="3719"/>
<Insert>uint32_t dpa_fib_rule_add(dpa_rule_fib_t *fib)
</Insert>
<Copy StartSeek="3767" EndSeek="3850"/>
</Delta>
<Delta Version="85" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:47:54000">
<Copy StartSeek="0" EndSeek="3719"/>
<Insert>uint32_t dpa_fib_rule_add(dpa_rule_fib_t *rule)
</Insert>
<Copy StartSeek="3768" EndSeek="3851"/>
</Delta>
<Delta Version="86" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:47:59000">
<Copy StartSeek="0" EndSeek="3768"/>
<Copy StartSeek="3817" EndSeek="3900"/>
</Delta>
<Delta Version="87" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:48:4000">
<Copy StartSeek="0" EndSeek="3480"/>
<Insert>	int	family;
</Insert>
<Copy StartSeek="3498" EndSeek="3905"/>
</Delta>
<Delta Version="88" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:48:28000">
<Copy StartSeek="0" EndSeek="3634"/>
<Insert>	unit8_t	defGtwL3[MV_MAX_L3_ADDR_SIZE];
</Insert>
<Copy StartSeek="3634" EndSeek="3865"/>
</Delta>
<Delta Version="89" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:48:57000">
<Copy StartSeek="0" EndSeek="3498"/>
<Insert>	unit8_t	srcL3[MV_MAX_L3_ADDR_SIZE];
	unit8_t	dstL3[MV_MAX_L3_ADDR_SIZE];
</Insert>
<Copy StartSeek="3574" EndSeek="3867"/>
</Delta>
<Delta Version="90" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:50:56000">
<Copy StartSeek="0" EndSeek="3653"/>
<Insert>	int     oif;
</Insert>
<Copy StartSeek="3667" EndSeek="3867"/>
</Delta>
<Delta Version="91" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:51:4000">
<Copy StartSeek="0" EndSeek="3480"/>
<Insert>	unit32_t family;
	unit8_t	src_l3[MV_MAX_L3_ADDR_SIZE];
	unit8_t	dst_l3[MV_MAX_L3_ADDR_SIZE];
	unit8_t	da[MV_MAC_ADDR_SIZE];
	unit8_t	sa[MV_MAC_ADDR_SIZE];
	unit32_t flags;
</Insert>
<Copy StartSeek="3653" EndSeek="3867"/>
</Delta>
<Delta Version="92" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:51:30000">
<Copy StartSeek="0" EndSeek="3653"/>
<Insert>	unit_32 oif;
</Insert>
<Copy StartSeek="3668" EndSeek="3868"/>
</Delta>
<Delta Version="93" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:51:40000">
<Copy StartSeek="0" EndSeek="3480"/>
<Insert>	uint32_t family;
</Insert>
<Copy StartSeek="3480" EndSeek="3618"/>
<Copy StartSeek="3636" EndSeek="3868"/>
</Delta>
<Delta Version="94" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:52:6000">
<Copy StartSeek="0" EndSeek="3450"/>
<Insert>typedef struct dpa_rule_fib {
</Insert>
<Copy StartSeek="3480" EndSeek="3868"/>
</Delta>
<Delta Version="95" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:53:30000">
<Copy StartSeek="0" EndSeek="3668"/>
<Insert>} dpa_rule_fib_t;
</Insert>
<Copy StartSeek="3686" EndSeek="3687"/>
<Insert>uint32_t dpa_fib_rule_add(dpa_rule_fib_t *rule);
uint32_t dpa_fib_rule_del(dpa_rule_fib_t *rule);
</Insert>
<Copy StartSeek="3784" EndSeek="3867"/>
</Delta>
<Delta Version="96" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:53:43000">
<Copy StartSeek="0" EndSeek="3736"/>
<Insert>uint32_t dpa_fib_rule_del(dpa_fib_rule_t*rule);
</Insert>
<Copy StartSeek="3785" EndSeek="3868"/>
</Delta>
<Delta Version="97" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:53:44000">
<Copy StartSeek="0" EndSeek="3785"/>
<Insert>#endif /* DPA_FIB */
</Insert>
<Copy StartSeek="3811" EndSeek="3873"/>
</Delta>
<Delta Version="98" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:54:14000">
<Copy StartSeek="0" EndSeek="2647"/>
<Insert>/* HAIM FIXME : add print method */
</Insert>
<Copy StartSeek="2647" EndSeek="3837"/>
</Delta>
<Delta Version="99" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:54:48000">
<Copy StartSeek="0" EndSeek="3414"/>
<Copy StartSeek="3500" EndSeek="3923"/>
</Delta>
<Delta Version="100" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:56:42000">
<Copy StartSeek="0" EndSeek="3415"/>
<Insert>uint32_t dpa_arp_add(NFP_RULE_ARP *arp2);
uint32_t dpa_arp_del(NFP_RULE_ARP *arp2);
</Insert>
<Copy StartSeek="3497" EndSeek="3921"/>
</Delta>
<Delta Version="101" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:56:53000">
<Copy StartSeek="0" EndSeek="3415"/>
<Insert>uint32_t dpa_arp_add(NFP_RULE_ARP *arp);
uint32_t dpa_arp_del(NFP_RULE_ARP *arp);

</Insert>
<Copy StartSeek="3647" EndSeek="4070"/>
</Delta>
<Delta Version="102" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:57:43000">
<Copy StartSeek="0" EndSeek="3445"/>
<Insert>	MV_U8	nextHopL3[MV_MAX_L3_ADDR_SIZE];
	MV_U8	da[MV_MAC_ADDR_SIZE];
</Insert>
<Copy StartSeek="3513" EndSeek="4070"/>
</Delta>
<Delta Version="103" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:57:49000">
<Copy StartSeek="0" EndSeek="3445"/>
<Insert>	MV_U8 nextHopL3[MV_MAX_L3_ADDR_SIZE];
</Insert>
<Copy StartSeek="3486" EndSeek="4072"/>
</Delta>
<Delta Version="104" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:58:1000">
<Copy StartSeek="0" EndSeek="3445"/>
<Insert>	MV_U8 next_hop_l3[MV_MAX_L3_ADDR_SIZE];
</Insert>
<Copy StartSeek="3481" EndSeek="4067"/>
</Delta>
<Delta Version="105" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:58:25000">
<Copy StartSeek="0" EndSeek="3445"/>
<Insert>	MV_U8 dst_l3[MV_MAX_L3_ADDR_SIZE];
	MV_U8 da[MV_MAC_ADDR_SIZE];
</Insert>
<Copy StartSeek="3477" EndSeek="4034"/>
</Delta>
<Delta Version="106" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:59:20000">
<Copy StartSeek="0" EndSeek="3415"/>
<Insert>typedef struct dpa_rule_arp {
</Insert>
<Copy StartSeek="3446" EndSeek="3512"/>
<Insert>} DPA_RULE_ARP;
</Insert>
<Copy StartSeek="3531" EndSeek="4038"/>
</Delta>
<Delta Version="107" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="11:59:54000">
<Copy StartSeek="0" EndSeek="3532"/>
<Insert>uint32_t dpa_arp_add(DPA_RULE_ARP *arp);
uint32_t dpa_arp_del(DPA_RULE_ARP *arp);
</Insert>
<Copy StartSeek="3620" EndSeek="4044"/>
</Delta>
<Delta Version="108" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:00:1000">
<Copy StartSeek="0" EndSeek="3511"/>
<Insert>
</Insert>
<Copy StartSeek="3511" EndSeek="4043"/>
</Delta>
<Delta Version="109" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:00:6000">
<Copy StartSeek="0" EndSeek="3619"/>
<Insert>
</Insert>
<Copy StartSeek="3650" EndSeek="4073"/>
</Delta>
<Delta Version="110" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:00:38000">
<Copy StartSeek="0" EndSeek="3464"/>
<Insert>	uint8_t *da;
</Insert>
<Copy StartSeek="3481" EndSeek="4076"/>
</Delta>
<Delta Version="111" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:01:23000">
<Copy StartSeek="0" EndSeek="3464"/>
<Insert>	uint8_t *da_l2;
</Insert>
<Copy StartSeek="3482" EndSeek="4077"/>
</Delta>
<Delta Version="112" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:01:38000">
<Copy StartSeek="0" EndSeek="3989"/>
<Copy StartSeek="4024" EndSeek="4112"/>
</Delta>
<Delta Version="113" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:04:29000">
<Copy StartSeek="0" EndSeek="3684"/>
<Insert>	uint8_t	src_l3[MV_MAX_L3_ADDR_SIZE];
	uint8_t	dst_l3[MV_MAX_L3_ADDR_SIZE];
	uint8_t	da[MV_MAC_ADDR_SIZE];
	uint8_t	sa[MV_MAC_ADDR_SIZE];
</Insert>
<Copy StartSeek="3754" EndSeek="4044"/>
</Delta>
<Delta Version="114" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:05:25000">
<Copy StartSeek="0" EndSeek="3720"/>
<Insert>	uint8_t	da_mac;
	uint8_t	sa_mac;
</Insert>
<Copy StartSeek="3756" EndSeek="4046"/>
</Delta>
<Delta Version="115" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:05:32000">
<Copy StartSeek="0" EndSeek="940"/>
<Insert> *        DPA_TDM_INIT_FAILED - ON TDM unit initialization failure.
</Insert>
<Copy StartSeek="940" EndSeek="3978"/>
</Delta>
<Delta Version="116" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:07:9000">
<Copy StartSeek="0" EndSeek="3917"/>
<Insert>

#endif /* DPA_IPV4_FWD */

</Insert>
<Copy StartSeek="3917" EndSeek="3948"/>
<Insert>
</Insert>
</Delta>
<Delta Version="117" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:08:3000">
<Copy StartSeek="0" EndSeek="3946"/>
<Insert>

</Insert>
<Copy StartSeek="3946" EndSeek="3971"/>
</Delta>
<Delta Version="118" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:08:11000">
<Copy StartSeek="0" EndSeek="3616"/>
<Insert>	uint8_t	*src_l3;
</Insert>
<Copy StartSeek="3641" EndSeek="3677"/>
<Insert>	uint8_t	*sa_mac;
</Insert>
<Copy StartSeek="3702" EndSeek="3985"/>
</Delta>
<Delta Version="119" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:14:12000">
<Copy StartSeek="0" EndSeek="3616"/>
<Insert>//      uint8_t	*src_l3;
</Insert>
<Copy StartSeek="3678" EndSeek="4022"/>
</Delta>
<Delta Version="120" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:16:10000">
<Copy StartSeek="0" EndSeek="3616"/>
<Insert>//      uint8_t	*src_l3; /* HAIM : do we realy need it  ?? */
</Insert>
<Copy StartSeek="3616" EndSeek="3634"/>
<Copy StartSeek="3655" EndSeek="3981"/>
</Delta>
<Delta Version="121" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:17:37000">
<Copy StartSeek="0" EndSeek="3673"/>
<Insert>//      uint8_t	*sa_mac;
</Insert>
<Copy StartSeek="3673" EndSeek="3956"/>
</Delta>
<Delta Version="122" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:19:28000">
<Copy StartSeek="0" EndSeek="3616"/>
<Insert>	uint8_t	*dst_l3;
	uint8_t	*dst_l3_gw;
</Insert>
<Copy StartSeek="3655" EndSeek="3956"/>
</Delta>
<Delta Version="123" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:20:27000">
<Copy StartSeek="0" EndSeek="3616"/>
<Insert>	uint32_t dst_l3;
	uint32_t dst_l3_gw;
</Insert>
<Copy StartSeek="3655" EndSeek="3956"/>
</Delta>
<Delta Version="124" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:20:48000">
<Copy StartSeek="0" EndSeek="3378"/>
<Insert>	uint8_t *dst_l3;
</Insert>
<Copy StartSeek="3416" EndSeek="3636"/>
<Insert>	uint8_t	*dst_l3;
	uint8_t	*dst_l3_gw;
</Insert>
<Copy StartSeek="3715" EndSeek="4016"/>
</Delta>
<Delta Version="125" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:25:45000">
<Copy StartSeek="0" EndSeek="3416"/>
<Insert>	uint8_t *da_mac;
</Insert>
<Copy StartSeek="3451" EndSeek="3732"/>
<Insert>	uint8_t	*da_mac;
</Insert>
<Copy StartSeek="3767" EndSeek="4050"/>
</Delta>
<Delta Version="126" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:26:22000">
<Copy StartSeek="0" EndSeek="3653"/>
<Copy StartSeek="3672" EndSeek="4069"/>
</Delta>
<Delta Version="127" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:30:0000">
<Copy StartSeek="0" EndSeek="3653"/>
<Insert>	uint32_t dst_len;
</Insert>
<Copy StartSeek="3673" EndSeek="4070"/>
</Delta>
<Delta Version="128" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:30:24000">
<Copy StartSeek="0" EndSeek="3653"/>
<Insert>	uint32_t dst_mask;
</Insert>
<Copy StartSeek="3690" EndSeek="4087"/>
</Delta>
<Delta Version="129" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:30:40000">
<Copy StartSeek="0" EndSeek="3653"/>
<Insert>	uint32_t dst_len; /* dst mask len*/
</Insert>
<Copy StartSeek="3691" EndSeek="4088"/>
</Delta>
<Delta Version="130" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:32:55000">
<Copy StartSeek="0" EndSeek="3653"/>
<Insert>	uint32_t dst_len; /* dst mask len */
</Insert>
<Copy StartSeek="3653" EndSeek="3691"/>
<Copy StartSeek="3729" EndSeek="4088"/>
</Delta>
<Delta Version="131" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:33:36000">
<Copy StartSeek="0" EndSeek="3691"/>
<Insert>	uint32_t dst_len; /* dst mask len */
</Insert>
<Copy StartSeek="3715" EndSeek="4074"/>
</Delta>
<Delta Version="132" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="12:51:6000">
<Copy StartSeek="0" EndSeek="2268"/>
<Insert>} MV_DPA_BRIDGE_RULE;
</Insert>
<Copy StartSeek="2286" EndSeek="4070"/>
</Delta>
<Delta Version="133" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="13:07:6000">
<Copy StartSeek="0" EndSeek="2268"/>
<Insert>} mv_dpa_br_rule;
</Insert>
<Copy StartSeek="2296" EndSeek="4080"/>
</Delta>
<Delta Version="134" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="13:07:34000">
<Copy StartSeek="0" EndSeek="2331"/>
<Insert>	MV_DPA_BR_RULE flags; /* bitfield */
</Insert>
<Copy StartSeek="2370" EndSeek="4081"/>
</Delta>
<Delta Version="135" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="13:07:48000">
<Copy StartSeek="0" EndSeek="2331"/>
<Insert>	MV_DPA_BR_RULE flags; /* bit field */
</Insert>
<Copy StartSeek="2380" EndSeek="4091"/>
</Delta>
<Delta Version="136" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="13:07:57000">
<Copy StartSeek="0" EndSeek="2331"/>
<Insert>	MV_DPA_BRIDGE_RULE_FLAGS flags; /* bit field */
</Insert>
<Copy StartSeek="2331" EndSeek="2389"/>
<Copy StartSeek="2438" EndSeek="4091"/>
</Delta>
<Delta Version="137" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="13:08:1000">
<Copy StartSeek="0" EndSeek="2217"/>
<Insert>	MV_DPA_BR_RULE_ENA	= 1,
	MV_DPA_BR_RULE_DROP	= 2,
</Insert>
<Copy StartSeek="2243" EndSeek="4066"/>
</Delta>
<Delta Version="138" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="13:09:1000">
<Copy StartSeek="0" EndSeek="2039"/>
<Insert>
</Insert>
<Copy StartSeek="2072" EndSeek="4098"/>
</Delta>
<Delta Version="139" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="13:12:7000">
<Copy StartSeek="0" EndSeek="2039"/>
<Copy StartSeek="2040" EndSeek="4099"/>
</Delta>
<Delta Version="140" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="13:12:49000">
<Copy StartSeek="0" EndSeek="1768"/>
<Insert>/*
 * dpa_get_log_level
 *
 * Description: 
 *
 * Get log level
 *
 * Parameters:
 * 
 * id        - log unit 
 * log_level - log level
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 *
 */
int32_t dpa_get_log_level(dpa_log_unit_t id, int32_t* log_level);

</Insert>
<Copy StartSeek="1768" EndSeek="3827"/>
</Delta>
<Delta Version="141" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="13:13:3000">
<Copy StartSeek="0" EndSeek="3509"/>
<Insert>	uint8_t	da_mac[MV_MAC_ADDR_SIZE];
</Insert>
<Copy StartSeek="3509" EndSeek="3792"/>
</Delta>
<Delta Version="142" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:44:13000">
<Copy StartSeek="0" EndSeek="2388"/>
<Insert>	MV_DPA_VLAN_RX_TRANSPARENT                = 0,
	MV_DPA_VLAN_RX_DROP_UNTAGGED              = 1,
	MV_DPA_VLAN_RX_DROP_TAGGED                = 2,
	MV_DPA_VLAN_RX_DROP_UNKNOWN               = 3,
	MV_DPA_VLAN_RX_DROP_UNTAGGED_AND_UNKNOWN  = 4,
</Insert>
<Copy StartSeek="2613" EndSeek="3777"/>
</Delta>
<Delta Version="143" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:44:26000">
<Copy StartSeek="0" EndSeek="1978"/>
<Insert>	MV_DPA_BR_RULE_DROP	= 1,
} MV_DPA_BRIDGE_RULE_FLAGS;
</Insert>
<Copy StartSeek="2026" EndSeek="2119"/>
<Insert>	MV_DPA_BRIDGE_RULE_FLAGS flags; /* bit field */
</Insert>
<Copy StartSeek="2165" EndSeek="2604"/>
<Insert>} mv_dpa_vlan_rx_mode;
</Insert>
<Copy StartSeek="2624" EndSeek="2640"/>
<Insert>	MV_DPA_VLAN_TX_TRANSPARENT = 0,
	MV_DPA_VLAN_TX_UNTAGGED    = 1,
	MV_DPA_VLAN_TX_TAGGED      = 2,
} mv_dpa_vlan_tx_mode;
</Insert>
<Copy StartSeek="2750" EndSeek="2869"/>
<Insert>int32_t dpa_vlan_rx_mode_set(int32_t if_index, mv_dpa_vlan_rx_mode mode);
int32_t dpa_vlan_tx_mode_set(int32_t if_index, mv_dpa_vlan_tx_mode mode);
</Insert>
<Copy StartSeek="3011" EndSeek="3747"/>
</Delta>
<Delta Version="144" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:45:9000">
<Copy StartSeek="0" EndSeek="2061"/>
<Insert>	uint8_t	*da;
	uint8_t	*sa;
</Insert>
<Copy StartSeek="2123" EndSeek="3781"/>
</Delta>
<Delta Version="145" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:45:37000">
<Copy StartSeek="0" EndSeek="1801"/>
<Copy StartSeek="1872" EndSeek="3852"/>
</Delta>
<Delta Version="146" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:46:47000">
<Copy StartSeek="0" EndSeek="1801"/>
<Copy StartSeek="1829" EndSeek="3880"/>
</Delta>
<Delta Version="147" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:47:3000">
<Copy StartSeek="0" EndSeek="1801"/>
<Insert>/* bind/unbind if to dpa */
</Insert>
<Copy StartSeek="1836" EndSeek="3887"/>
</Delta>
<Delta Version="148" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:47:12000">
<Copy StartSeek="0" EndSeek="3833"/>
<Copy StartSeek="4749" EndSeek="4803"/>
</Delta>
<Delta Version="149" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:52:18000">
<Copy StartSeek="0" EndSeek="4012"/>
<Insert>	MV_U32 ports;
	MV_U16 proto;
	MV_U16 reserved;	/* for alignment */
</Insert>
<Copy StartSeek="4046" EndSeek="4081"/>
<Insert>	MV_U32 new_sip;
	MV_U32 new_dip;
	MV_U16 new_sport;
	MV_U16 new_dport;
</Insert>
<Copy StartSeek="4161" EndSeek="4579"/>
<Insert>	MV_U16 mh;
</Insert>
<Copy StartSeek="4593" EndSeek="4619"/>
<Insert>	MV_U32 flags;
	MV_U32 age;
	MV_U32 hit_cntr;
</Insert>
<Copy StartSeek="4671" EndSeek="4785"/>
</Delta>
<Delta Version="150" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:52:59000">
<Copy StartSeek="0" EndSeek="4182"/>
<Insert>
#ifdef DPA_LIMIT
	/* Token Bucket Filter information */
	DPA_TBF_INFO *tbfInfo;
#endif /* DPA_LIMIT */

#ifdef DPA_CLASSIFY
	/* indexes 0..63 are the old dscp, values in the array cells are the new dscp. index 64 is for global mapping */
	DPA_DSCP_MAP_INFO  dscp_map[DPA_DSCP_MAP_SIZE];
	DPA_VPRI_MAP_INFO  vpri_map[DPA_VPRI_MAP_SIZE];
	DPA_TXQ_MAP_INFO   txq_map[DPA_DSCP_MAP_SIZE];
	MV_U8 txp;
	uint16_t mh;
#endif /* DPA_CLASSIFY */
</Insert>
<Copy StartSeek="4182" EndSeek="4348"/>
</Delta>
<Delta Version="151" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:53:47000">
<Copy StartSeek="0" EndSeek="4214"/>
<Insert>	uint32_t hit_cntr;
	MV_U8 visited;
</Insert>
<Copy StartSeek="4214" EndSeek="4312"/>
</Delta>
<Delta Version="152" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:54:0000">
<Copy StartSeek="0" EndSeek="4214"/>
<Insert>} DPA_RULE_CT;
</Insert>
<Copy StartSeek="4231" EndSeek="4314"/>
</Delta>
<Delta Version="153" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:54:8000">
<Copy StartSeek="0" EndSeek="3883"/>
<Insert>	struct dpa_rule_ct *next;
</Insert>
<Copy StartSeek="3883" EndSeek="4287"/>
</Delta>
<Delta Version="154" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:54:13000">
<Copy StartSeek="0" EndSeek="3902"/>
<Insert>	int family;
	MV_U8 srcL3[MV_MAX_L3_ADDR_SIZE];
	MV_U8 dstL3[MV_MAX_L3_ADDR_SIZE];
</Insert>
<Copy StartSeek="3992" EndSeek="4294"/>
</Delta>
<Delta Version="155" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:54:37000">
<Copy StartSeek="0" EndSeek="3920"/>
<Insert>	uint8_tsrcL3[MV_MAX_L3_ADDR_SIZE];
	uint8_tdstL3[MV_MAX_L3_ADDR_SIZE];
</Insert>
<Copy StartSeek="3994" EndSeek="4296"/>
</Delta>
<Delta Version="156" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:54:50000">
<Copy StartSeek="0" EndSeek="4028"/>
<Insert>	DPA_RULE_FIB *fib;
</Insert>
<Copy StartSeek="4028" EndSeek="4276"/>
</Delta>
<Delta Version="157" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:55:19000">
<Copy StartSeek="0" EndSeek="3471"/>
<Insert>typedef struct dpa_fib_rule {
</Insert>
<Copy StartSeek="3503" EndSeek="3656"/>
<Insert>} dpa_fib_rule_t;
</Insert>
<Copy StartSeek="3676" EndSeek="3677"/>
<Insert>uint32_t dpa_fib_rule_add(dpa_fib_rule_t *rule);
uint32_t dpa_fib_rule_del(dpa_fib_rule_t *rule);
uint32_t dpa_fib_rule_flush(void);
</Insert>
<Copy StartSeek="3820" EndSeek="4290"/>
</Delta>
<Delta Version="158" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:56:36000">
<Copy StartSeek="0" EndSeek="3471"/>
<Insert>typedef struct dpa_route_rule {
</Insert>
<Copy StartSeek="3500" EndSeek="3653"/>
<Insert>} dpa_route_rule_t;
</Insert>
<Copy StartSeek="3670" EndSeek="3671"/>
<Insert>uint32_t dpa_route_rule_add(dpa_route_rule_t *rule);
uint32_t dpa_route_rule_del(dpa_route_rule_t *rule);
uint32_t dpa_route_rule_flush(void);
</Insert>
<Copy StartSeek="3799" EndSeek="4269"/>
</Delta>
<Delta Version="159" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:56:47000">
<Copy StartSeek="0" EndSeek="4186"/>
<Insert>
</Insert>
<Copy StartSeek="4186" EndSeek="4268"/>
</Delta>
<Delta Version="160" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:57:19000">
<Copy StartSeek="0" EndSeek="3194"/>
<Insert>
</Insert>
<Copy StartSeek="3194" EndSeek="4267"/>
</Delta>
<Delta Version="161" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="16:57:56000">
<Copy StartSeek="0" EndSeek="3986"/>
<Insert>	uint32_t ports;
</Insert>
<Copy StartSeek="4020" EndSeek="4284"/>
</Delta>
<Delta Version="162" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:00:24000">
<Copy StartSeek="0" EndSeek="3986"/>
<Copy StartSeek="4003" EndSeek="4037"/>
<Insert>	uint16_t proto;
</Insert>
<Copy StartSeek="4039" EndSeek="4286"/>
</Delta>
<Delta Version="163" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:00:32000">
<Copy StartSeek="0" EndSeek="4037"/>
<Insert>	
</Insert>
<Copy StartSeek="4037" EndSeek="4284"/>
</Delta>
<Delta Version="164" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:00:34000">
<Copy StartSeek="0" EndSeek="3875"/>
<Insert>	/* 5 tuple key */
</Insert>
<Copy StartSeek="3875" EndSeek="4265"/>
</Delta>
<Delta Version="165" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:01:28000">
<Copy StartSeek="0" EndSeek="4033"/>
<Insert>	uint32_t new_sip;
	uint32_t new_dip;
</Insert>
<Copy StartSeek="4115" EndSeek="4309"/>
</Delta>
<Delta Version="166" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:02:5000">
<Copy StartSeek="0" EndSeek="4033"/>
<Insert>	uint8_t new_srcL3[MV_MAX_L3_ADDR_SIZE];
	uint8_t new_dstL3[MV_MAX_L3_ADDR_SIZE];
</Insert>
<Copy StartSeek="4071" EndSeek="4265"/>
</Delta>
<Delta Version="167" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:02:11000">
<Copy StartSeek="0" EndSeek="4018"/>
<Insert>#ifdef DPA_NAT
</Insert>
<Copy StartSeek="4049" EndSeek="4281"/>
</Delta>
<Delta Version="168" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:02:32000">
<Copy StartSeek="0" EndSeek="3846"/>
<Copy StartSeek="4366" EndSeek="4719"/>
<Copy StartSeek="4720" EndSeek="4802"/>
</Delta>
<Delta Version="169" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:04:50000">
<Copy StartSeek="0" EndSeek="3861"/>
<Insert>#define	NFP_F_CT_SNAT           0x1
#define	NFP_F_CT_DNAT           0x2
#define NFP_F_CT_DROP           0x4
#define NFP_F_CT_SET_DSCP       0x8
#define NFP_F_CT_SET_VLAN_PRIO  0x10
#define NFP_F_CT_SET_TXQ        0x20
#define NFP_F_CT_SET_TXP        0x40
#define NFP_F_CT_SET_MH         0x80
#define NFP_F_CT_LIMIT          0x100
#define NFP_F_CT_FIB_INV        0x200
#define NFP_F_CT_HWF            0x400
#define NFP_F_CT_UDP_CSUM       0x800
#define NFP_F_CT_NOT_EXIST      0x1000
</Insert>
<Copy StartSeek="4277" EndSeek="4735"/>
</Delta>
<Delta Version="170" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:05:30000">
<Copy StartSeek="0" EndSeek="3861"/>
<Insert>	NFP_F_CT_SNAT         = 0x1
	NFP_F_CT_DNAT          = 0x2,
	NFP_F_CT_DROP          = 0x4,
	NFP_F_CT_SET_DSCP      = 0x8,
	NFP_F_CT_SET_VLAN_PRIO = 0x10,
	NFP_F_CT_SET_TXQ       = 0x20,
	NFP_F_CT_SET_TXP       = 0x40,
	NFP_F_CT_SET_MH        = 0x80,
	NFP_F_CT_LIMIT         = 0x100,
	NFP_F_CT_FIB_INV       = 0x200,
	NFP_F_CT_HWF           = 0x400,
	NFP_F_CT_UDP_CSUM      = 0x800,
	NFP_F_CT_NOT_EXIST     = 0x1000,
</Insert>
<Copy StartSeek="4278" EndSeek="4736"/>
</Delta>
<Delta Version="171" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:05:52000">
<Copy StartSeek="0" EndSeek="3861"/>
<Insert>	nfp_f_ct_snat          = 0x1
	nfp_f_ct_dnat          = 0x2,
	nfp_f_ct_drop          = 0x4,
	nfp_f_ct_set_dscp      = 0x8,
	nfp_f_ct_set_vlan_prio = 0x10,
	nfp_f_ct_set_txq       = 0x20,
	nfp_f_ct_set_txp       = 0x40,
	nfp_f_ct_set_mh        = 0x80,
	nfp_f_ct_limit         = 0x100,
	nfp_f_ct_fib_inv       = 0x200,
	nfp_f_ct_hwf           = 0x400,
	nfp_f_ct_udp_csum      = 0x800,
	nfp_f_ct_not_exist     = 0x1000,
</Insert>
<Copy StartSeek="4382" EndSeek="4840"/>
</Delta>
<Delta Version="172" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:06:54000">
<Copy StartSeek="0" EndSeek="4176"/>
<Insert>	DPA_CT_RULE_FLAG_LIMIT         = 0X100,
	DPA_CT_RULE_FLAG_FIB_INV       = 0X200,
	DPA_CT_RULE_FLAG_HWF           = 0X400,
	DPA_CT_RULE_FLAG_UDP_CSUM      = 0X800,
	DPA_CT_RULE_FLAG_NOT_EXIST     = 0X1000,
</Insert>
<Copy StartSeek="4176" EndSeek="4634"/>
</Delta>
<Delta Version="173" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:07:32000">
<Copy StartSeek="0" EndSeek="4502"/>
<Insert>	uint32_t flags;
</Insert>
<Copy StartSeek="4528" EndSeek="4643"/>
</Delta>
<Delta Version="174" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:08:17000">
<Copy StartSeek="0" EndSeek="4561"/>
<Copy StartSeek="4658" EndSeek="4740"/>
</Delta>
<Delta Version="175" Comment="" NL="\10" Encoding="text" Date="2012/03/25" Time="17:08:46000">
<Copy StartSeek="0" EndSeek="1801"/>
<Insert>/* bind/unbind interface to dpa */
</Insert>
<Copy StartSeek="1833" EndSeek="4737"/>
</Delta>
<Delta Version="176" Comment="" NL="\10" Encoding="text" Date="2012/03/26" Time="09:57:50000">
<Copy StartSeek="0" EndSeek="613"/>
<Insert>/*
 * dpa_init
 *
 * Description:
 *       Initialize DPA engine.
 *
 * Parameters:
 *       dpa_config - DPA engine configuration profile in xml format
 *
 * Returns:  
 *        DPA_OK              - On success. 
 *        DPA_CONFIG_ERROR    - On configuration error.
 *        DPA_OUT_OF_MEMORY   - On out of memory error.
 */
</Insert>
<Copy StartSeek="613" EndSeek="658"/>
<Insert>

/*
 * dpa_shutdown
 *
 * Description:  
 *       Shutdown DPA engine.
 *
 * Parameters:
 *       None.    
 *
 * Returns: 
 *       DPA_OK - The function always succeeds.
 *
 */
</Insert>
<Copy StartSeek="658" EndSeek="686"/>
<Insert>

/*
 * dpa_get_stats
 *
 * Description: 
 *
 * Retrieve dpa system statistics.
 *
 * Parameters:
 *
 * 
 * stats   - Returned dpa statistics.
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 * On error, the function returns DPA_FAIL.
 *
 */
</Insert>
<Copy StartSeek="686" EndSeek="729"/>
<Insert>
/*
 * dpa_set_log_level
 *
 * Description: 
 *
 * Set log level
 *
 * Parameters:
 * 
 * id        - log unit 
 * log_level - log level
 *
 * Returns:
 *
 * On success, the function returns DPA_OK.
 *
 */
</Insert>
<Copy StartSeek="729" EndSeek="795"/>
<Copy StartSeek="836" EndSeek="3805"/>
</Delta>
</DeltaFile>
