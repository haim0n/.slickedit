<!DOCTYPE DeltaFile SYSTEM "http://www.slickedit.com/dtd/vse/vsdelta/9.0/vsdelta.dtd">
<DeltaFile FormatVersion="9.0.0">
<MostRecent Version="0" Comment="" Date="2012/04/01" Time="17:34:10000" NL="\10" Encoding="text">
<Insert>#include &lt;asm/types.h&gt;

#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;netinet/in.h&gt;

#include &lt;linux/netlink.h&gt;
#include &lt;linux/rtnetlink.h&gt;

#define KLNA_GRP (RTMGRP_IPV4_ROUTE | RTMGRP_NEIGH | RTNLGRP_LINK)

struct msgnames_t {
	int id;
	char *msg;
} typenames[] = {
#define MSG(x) { x, #x }
	MSG(RTM_NEWROUTE),
	MSG(RTM_DELROUTE),
	MSG(RTM_GETROUTE),
	MSG(RTM_NEWNEIGH),
	MSG(RTM_DELNEIGH),
	MSG(RTM_NEWLINK),
	MSG(RTM_DELLINK),
#undef MSG
	{0,0}
};



#if 0
/* buffer to hold the RTNETLINK request */
struct {
	struct nlmsghdr nl;
	struct rtmsg    rt;
	char            buf[8192];
} req;

// variables used for
// socket communications
int fd;
struct sockaddr_nl la;
struct sockaddr_nl pa;
struct msghdr msg;
struct iovec iov;
int rtn;

// RTNETLINK message pointers &amp; lengths
// used when processing messages
struct nlmsghdr *nlp;
int nll;
struct rtmsg *rtp;
int rtl;
struct rtattr *rtap;


void __read_reply(void)
{
	// string to hold content of the route
	// table (i.e. one entry)
	char dsts[24], gws[24], ifs[16], ms[24];

	// outer loop: loops thru all the NETLINK
	// headers that also include the route entry
	// header
	nlp = (struct nlmsghdr *) buf;
	for (;NLMSG_OK(nlp, nll);nlp=NLMSG_NEXT(nlp, nll)) {

		// get route entry header
		rtp = (struct rtmsg *) NLMSG_DATA(nlp);

		// we are only concerned about the
		// main route table
		if (rtp-&gt;rtm_table != RT_TABLE_MAIN)
			continue;

		// init all the strings
		bzero(dsts, sizeof(dsts));
		bzero(gws, sizeof(gws));
		bzero(ifs, sizeof(ifs));
		bzero(ms, sizeof(ms));

		// inner loop: loop thru all the attributes of
		// one route entry
		rtap = (struct rtattr *) RTM_RTA(rtp);
		rtl = RTM_PAYLOAD(nlp);
		for (;RTA_OK(rtap, rtl);rtap=RTA_NEXT(rtap,rtl)) {
			switch (rtap-&gt;rta_type) {
			// destination IPv4 address
			case RTA_DST:
				inet_ntop(AF_INET, RTA_DATA(rtap),
					  dsts, 24);
				break;

				// next hop IPv4 address
			case RTA_GATEWAY:
				inet_ntop(AF_INET, RTA_DATA(rtap),
					  gws, 24);
				break;

				// unique ID associated with the network
				// interface
			case RTA_OIF:
				sprintf(ifs, "%d",
					*((int *) RTA_DATA(rtap)));
			default:
				break;
			}
		}
		sprintf(ms, "%d", rtp-&gt;rtm_dst_len);

		printf("dst %s/%s gw %s if %s\n",
		       dsts, ms, gws, ifs);
	}
}
#endif /* sample code for review */

char *klna_lookup_name(struct msgnames_t *db,int id)
{
	static char name[512];
	struct msgnames_t *msgnamesiter;
	for (msgnamesiter=db;msgnamesiter-&gt;msg;++msgnamesiter) {
		if (msgnamesiter-&gt;id == id)
			break;
	}
	if (msgnamesiter-&gt;msg) {
		return msgnamesiter-&gt;msg;
	}
	snprintf(name,sizeof(name),"#%i",id);
	return name;
}

#ifndef NIPQUAD
	#define NIPQUAD(addr) \
	((unsigned char *)&amp;addr)[0], \
	((unsigned char *)&amp;addr)[1], \
	((unsigned char *)&amp;addr)[2], \
	((unsigned char *)&amp;addr)[3]
	#define NIPQUAD_FMT "%u.%u.%u.%u"
#endif

static int klna_ev_route(struct nlmsghdr *nlh, void *buffer)
{
	struct rtmsg *rtm;
	struct rtattr *rta;
	int rtl;
	rtm = (struct rtmsg *)buffer;
	rta = (struct rtattr*)RTM_RTA(rtm);
	rtl = RTM_PAYLOAD(nlh);
	printf("family: %u\n", rtm-&gt;rtm_family);
	/* parse each attr */
	for (; RTA_OK(rta, rtl); rta = RTA_NEXT(rta, rtl)) {
		if (rta-&gt;rta_type == RTA_DST) {
			uint32_t dst_addr = *((uint32_t *)RTA_DATA(rta));
			printf("dst " NIPQUAD_FMT "/%u\n", NIPQUAD(dst_addr),
			       rtm-&gt;rtm_dst_len);
		}
		if (rta-&gt;rta_type == RTA_GATEWAY) {
			uint32_t dst_gw = *((uint32_t *)RTA_DATA(rta));
			printf("gw " NIPQUAD_FMT "\n", NIPQUAD(dst_gw));
		}
		if (rta-&gt;rta_type == RTA_OIF) {
			uint32_t oif = *((uint32_t *)RTA_DATA(rta));
			printf("oif_index %u\n", oif);
		}
	}
	if (nlh-&gt;nlmsg_type == RTM_NEWROUTE) {
		/* dpa_rt_rule_add */
	} else {
		/* dpa_rt_rule_del */
	}

	return 0;
}

static int klna_ev_link(struct nlmsghdr *nlh, void *buffer)
{
	struct ifinfomsg *ndm;
	struct rtattr *rta;
	int rtl;
	int new_neigh;

	ndm = (struct ndmsg *)buffer;
	rta = (struct rtattr*)RTM_RTA(ndm);
	rtl = RTM_PAYLOAD(nlh);
	printf("family: %u\n", ndm-&gt;ndm_family);
	/* parse each attr */
	for (; RTA_OK(rta, rtl); rta = RTA_NEXT(rta, rtl)) {
		if (rta-&gt;rta_type == NDA_DST) {
			uint32_t dst_addr = *((uint32_t *)RTA_DATA(rta));
			printf("ip " NIPQUAD_FMT "\n", NIPQUAD(dst_addr));
			continue;
		}
		if (rta-&gt;rta_type == NDA_LLADDR) {
			#define MAX_BUF_LEN 6
			uint8_t ha[MAX_BUF_LEN];
			uint8_t *data = (uint8_t *)RTA_DATA(rta);
			uint32_t data_len =
				rta-&gt;rta_len &lt; MAX_BUF_LEN ? rta-&gt;rta_len : MAX_BUF_LEN;
			uint32_t i;

			new_neigh = 1; /* NDA_LLADDR appears only in new entry */
			memcpy(ha, data, data_len);
			for (i = 0; i &lt; data_len; i++) {
				printf("%x:", ha[i]);
			}
			printf("\n");
			continue;
		}
//      	if (rta-&gt;rta_type == NDA_CACHEINFO) {
//      		printf(" NDA_CACHEINFO\n");
//      		continue;
//      	}
	}
	if (new_neigh) {
		/* dpa_arp_rule_add */
	} else {
		/* dpa_arp_rule_del */
	}
	return 0;
}

static int klna_ev_arp(struct nlmsghdr *nlh, void *buffer)
{

	return 0;
}

static int klna_read_event(int sock)
{
	struct sockaddr_nl nladdr;
	struct msghdr msg;
	struct iovec iov[2];
	struct nlmsghdr nlh;
	char buffer[1024]; /* pointer to |rtmsg header|rtm_data| */
	int ret, nll;

	iov[0].iov_base = (void *)&amp;nlh;
	iov[0].iov_len = sizeof(nlh);
	iov[1].iov_base = (void *)buffer;
	iov[1].iov_len = sizeof(buffer);
	msg.msg_name = (void *)&amp;(nladdr);
	msg.msg_namelen = sizeof(nladdr);
	msg.msg_iov = iov;
	msg.msg_iovlen = sizeof(iov)/sizeof(iov[0]);
	ret=recvmsg(sock, &amp;msg, 0);

	if (ret&lt;0) {
		return ret;
	}

	printf("nlmsg_type: %i (%s)\n",(nlh.nlmsg_type), klna_lookup_name(typenames,nlh.nlmsg_type));
	if (nlh.nlmsg_type == RTM_NEWROUTE ||
	    nlh.nlmsg_type == RTM_DELROUTE) {
		return klna_ev_route(&amp;nlh, buffer);
	}
	if (nlh.nlmsg_type == RTM_NEWNEIGH ||
	    nlh.nlmsg_type == RTM_DELNEIGH) {
		return klna_ev_arp(&amp;nlh, buffer);
	}
	if (nlh.nlmsg_type == RTM_NEWLINK||
	    nlh.nlmsg_type == RTM_DELLINK) {
		return klna_ev_link(&amp;nlh, buffer);
	}

	return 0;
}

int klna_open_netlink()
{
	int sock = socket(AF_NETLINK,SOCK_RAW, NETLINK_ROUTE);
	struct sockaddr_nl addr;

	memset((void *)&amp;addr, 0, sizeof(addr));

	if (sock&lt;0)
		return sock;
	addr.nl_family = AF_NETLINK;
	addr.nl_pid = getpid();
	addr.nl_groups = KLNA_GRP;
	if (bind(sock,(struct sockaddr *)&amp;addr,sizeof(addr))&lt;0)
		return -1;
	return sock;
}

int main(int argc, char *argv[])
{
	int nls = klna_open_netlink();
	if (nls&lt;0) {
		err(1,"netlink");
	}

	while (1)
		klna_read_event(nls);
	return 0;
}
</Insert>
</MostRecent>
</DeltaFile>
